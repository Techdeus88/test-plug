SCRIPT  /Users/techdeus/.local/share/nvim-test/site/pack/deps/opt/nvim-ts-context-commentstring/plugin/ts_context_commentstring.lua
Sourced 2 times
Total time:   0.002035
 Self time:   0.002035

count  total (s)   self (s)
Cannot open file!

SCRIPT  /Users/techdeus/.local/share/nvim-test/site/pack/deps/opt/plenary.nvim/plugin/plenary.vim
Sourced 4 times
Total time:   0.000189
 Self time:   0.000189

count  total (s)   self (s)
                            
                            " Create command for running busted
    4              0.000050 command! -nargs=1 -complete=file PlenaryBustedFile
                                  \ lua require('plenary.test_harness').test_file([[<args>]])
                            
    4              0.000020 command! -nargs=+ -complete=file PlenaryBustedDirectory
                                  \ lua require('plenary.test_harness').test_directory_command([[<args>]])
                            
    4              0.000043 nnoremap <Plug>PlenaryTestFile :lua require('plenary.test_harness').test_file(vim.fn.expand("%:p"))<CR>

SCRIPT  /Users/techdeus/.local/share/nvim-test/site/pack/deps/opt/snacks.nvim/plugin/snacks.lua
Sourced 2 times
Total time:   0.001902
 Self time:   0.001902

count  total (s)   self (s)
                            require("snacks")

SCRIPT  /usr/local/Cellar/neovim/0.11.2/share/nvim/runtime/filetype.lua
Sourced 1 time
Total time:   0.000391
 Self time:   0.000291

count  total (s)   self (s)
    1              0.000006 if vim.g.did_load_filetypes then
    1              0.000090   return
    1              0.000001 end
                            vim.g.did_load_filetypes = 1
                            
                            vim.api.nvim_create_augroup('filetypedetect', { clear = false })
                            
                            vim.api.nvim_create_autocmd({ 'BufRead', 'BufNewFile', 'StdinReadPost' }, {
                              group = 'filetypedetect',
                              callback = function(args)
                                if not vim.api.nvim_buf_is_valid(args.buf) then
                                  return
                                end
                                local ft, on_detect = vim.filetype.match({
                                  -- The unexpanded file name is needed here. #27914
                                  -- However, bufname() can't be used, as it doesn't work with :doautocmd. #31306
                                  filename = args.file,
                                  buf = args.buf,
                                })
                                if not ft then
                                  -- Generic configuration file used as fallback
                                  ft = require('vim.filetype.detect').conf(args.file, args.buf)
                                  if ft then
                                    vim._with({ buf = args.buf }, function()
                                      vim.api.nvim_cmd({ cmd = 'setf', args = { 'FALLBACK', ft } }, {})
                                    end)
                                  end
                                else
                                  -- on_detect is called before setting the filetype so that it can set any buffer local
                                  -- variables that may be used the filetype's ftplugin
                                  if on_detect then
                                    on_detect(args.buf)
                                  end
                            
                                  vim._with({ buf = args.buf }, function()
                                    vim.api.nvim_cmd({ cmd = 'setf', args = { ft } }, {})
                                  end)
                                end
                              end,
                            })
                            
                            -- Set up the autocmd for user scripts.vim
                            vim.api.nvim_create_autocmd({ 'BufRead', 'BufNewFile' }, {
                              group = 'filetypedetect',
                              command = "if !did_filetype() && expand('<amatch>') !~ g:ft_ignore_pat | runtime! scripts.vim | endif",
                            })
                            
                            vim.api.nvim_create_autocmd('StdinReadPost', {
                              group = 'filetypedetect',
                              command = 'if !did_filetype() | runtime! scripts.vim | endif',
                            })
                            
                            if not vim.g.ft_ignore_pat then
                              vim.g.ft_ignore_pat = '\\.\\(Z\\|gz\\|bz2\\|zip\\|tgz\\)$'
                            end
                            
                            -- These *must* be sourced after the autocommands above are created
                            vim.cmd([[
                              augroup filetypedetect
                              runtime! ftdetect/*.{vim,lua}
                              augroup END
                            ]])

SCRIPT  /usr/local/Cellar/neovim/0.11.2/share/nvim/runtime/syntax/syntax.vim
Sourced 1 time
Total time:   0.000463
 Self time:   0.000276

count  total (s)   self (s)
                            " Vim syntax support file
                            " Maintainer:	The Vim Project <https://github.com/vim/vim>
                            " Last Change:	2023 Aug 10
                            " Former Maintainer:	Bram Moolenaar <Bram@vim.org>
                            
                            " This file is used for ":syntax on".
                            " It installs the autocommands and starts highlighting for all buffers.
                            
    1              0.000009 if !has("syntax")
                              finish
    1              0.000001 endif
                            
                            " If Syntax highlighting appears to be on already, turn it off first, so that
                            " any leftovers are cleared.
    1              0.000004 if exists("syntax_on") || exists("syntax_manual")
                              so <sfile>:p:h/nosyntax.vim
    1              0.000001 endif
                            
                            " Load the Syntax autocommands and set the default methods for highlighting.
    1   0.000334   0.000216 runtime syntax/synload.vim
                            
                            " Load the FileType autocommands if not done yet.
    1              0.000003 if exists("did_load_filetypes")
    1              0.000002   let s:did_ft = 1
                            else
                              filetype on
                              let s:did_ft = 0
    1              0.000001 endif
                            
                            " Set up the connection between FileType and Syntax autocommands.
                            " This makes the syntax automatically set when the file type is detected
                            " unless treesitter highlighting is enabled.
                            " Avoid an error when 'verbose' is set and <amatch> expansion fails.
    1              0.000002 augroup syntaxset
    1              0.000003   au! FileType *	if !exists('b:ts_highlight') | 0verbose exe "set syntax=" . expand("<amatch>") | endif
    1              0.000001 augroup END
                            
                            " Execute the syntax autocommands for the each buffer.
                            " If the filetype wasn't detected yet, do that now.
                            " Always do the syntaxset autocommands, for buffers where the 'filetype'
                            " already was set manually (e.g., help buffers).
    1   0.000073   0.000003 doautoall syntaxset FileType
    1              0.000001 if !s:did_ft
                              doautoall filetypedetect BufRead
    1              0.000003 endif

SCRIPT  /usr/local/Cellar/neovim/0.11.2/share/nvim/runtime/syntax/synload.vim
Sourced 1 time
Total time:   0.000101
 Self time:   0.000101

count  total (s)   self (s)
                            " Vim syntax support file
                            " Maintainer:	The Vim Project <https://github.com/vim/vim>
                            " Last Change:	2023 Aug 10
                            " Former Maintainer:	Bram Moolenaar <Bram@vim.org>
                            
                            " This file sets up for syntax highlighting.
                            " It is loaded from "syntax.vim" and "manual.vim".
                            " 1. Set the default highlight groups.
                            " 2. Install Syntax autocommands for all the available syntax files.
                            
    1              0.000006 if !has("syntax")
                              finish
    1              0.000001 endif
                            
                            " let others know that syntax has been switched on
    1              0.000003 let syntax_on = 1
                            
                            " Line continuation is used here, remove 'C' from 'cpoptions'
    1              0.000003 let s:cpo_save = &cpo
    1              0.000004 set cpo&vim
                            
                            " First remove all old syntax autocommands.
    1              0.000002 au! Syntax
                            
    1              0.000003 au Syntax *		call s:SynSet()
                            
    1              0.000003 fun! s:SynSet()
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
                              syn clear
                              if exists("b:current_syntax")
                                unlet b:current_syntax
                              endif
                            
                              0verbose let s = expand("<amatch>")
                              if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
                              elseif s == "OFF"
                                let s = ""
                              endif
                            
                              if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.  Skip empty entries.
                                for name in split(s, '\.')
                                  if !empty(name)
                                    " XXX: "[.]" in the first pattern makes it a wildcard on Windows
                                    exe $'runtime! syntax/{name}[.]{{vim,lua}} syntax/{name}/*.{{vim,lua}}'
                                  endif
                                endfor
                              endif
                            endfun
                            
                            
                            " Handle adding doxygen to other languages (C, C++, C#, IDL, java, php, DataScript)
    1              0.000016 au Syntax c,cpp,cs,idl,java,php,datascript
                            	\ if (exists('b:load_doxygen_syntax') && b:load_doxygen_syntax)
                            	\	|| (exists('g:load_doxygen_syntax') && g:load_doxygen_syntax)
                            	\   | runtime! syntax/doxygen.vim
                            	\ | endif
                            
                            
                            " Source the user-specified syntax highlighting file
    1              0.000003 if exists("mysyntaxfile")
                              let s:fname = expand(mysyntaxfile)
                              if filereadable(s:fname)
                                execute "source " . fnameescape(s:fname)
                              endif
    1              0.000001 endif
                            
                            " Restore 'cpoptions'
    1              0.000006 let &cpo = s:cpo_save
    1              0.000005 unlet s:cpo_save

SCRIPT  /Users/techdeus/.local/share/nvim-test/site/pack/deps/start/plugman.nvim/plugin/plugman.lua
Sourced 2 times
Total time:   0.000324
 Self time:   0.000324

count  total (s)   self (s)
                            -- Prevent loading twice
                            if vim.g.loaded_plugman then
                              return
                            end
                            vim.g.loaded_plugman = 1
                            if not vim.g.plugman_no_auto_setup then
                              -- Auto-setup if config exists
                              local config_path = vim.fn.stdpath('config') .. '/lua/plugman_config.lua'
                              if vim.loop.fs_stat(config_path) then
                                local ok, config = pcall(dofile, config_path)
                                if ok then
                                  require('plugman').setup(config)
                                end
                              end
                            end

SCRIPT  /usr/local/Cellar/neovim/0.11.2/share/nvim/runtime/plugin/gzip.vim
Sourced 1 time
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
                            " Vim plugin for editing compressed files.
                            " Maintainer:	The Vim Project <https://github.com/vim/vim>
                            " Last Change:	2025 Feb 28
                            " Former Maintainer:	Bram Moolenaar <Bram@vim.org>
                            
                            " Exit quickly when:
                            " - this plugin was already loaded
                            " - when 'compatible' is set
                            " - some autocommands are already taking care of compressed files
    1              0.000007 if exists("loaded_gzip") || &cp || exists("#BufReadPre#*.gz")
    1              0.000001   finish
                            endif
                            let loaded_gzip = 1
                            
                            augroup gzip
                              " Remove all gzip autocommands
                              au!
                            
                              " Enable editing of gzipped files.
                              " The functions are defined in autoload/gzip.vim.
                              "
                              " Set binary mode before reading the file.
                              autocmd BufReadPre,FileReadPre	*.gz,*.bz2,*.bz3,*.Z,*.lzma,*.xz,*.lz,*.zst,*.br,*.lzo,*.lz4 setlocal bin
                            
                              " Use "gzip -d" and similar commands, gunzip isn't always available.
                              autocmd BufReadPost,FileReadPost	*.br call gzip#read("brotli -d --rm")
                              autocmd BufReadPost,FileReadPost	*.bz2 call gzip#read("bzip2 -d")
                              autocmd BufReadPost,FileReadPost	*.bz3 call gzip#read("bzip3 -d")
                              autocmd BufReadPost,FileReadPost	*.gz  call gzip#read("gzip -dn")
                              autocmd BufReadPost,FileReadPost	*.lz  call gzip#read("lzip -d")
                              autocmd BufReadPost,FileReadPost	*.lz4 call gzip#read("lz4 -d -q --rm")
                              autocmd BufReadPost,FileReadPost	*.lzma call gzip#read("lzma -d")
                              autocmd BufReadPost,FileReadPost	*.lzo call gzip#read("lzop -d -U")
                              autocmd BufReadPost,FileReadPost	*.xz  call gzip#read("xz -d")
                              autocmd BufReadPost,FileReadPost	*.Z   call gzip#read("uncompress")
                              autocmd BufReadPost,FileReadPost	*.zst call gzip#read("zstd -d --rm")
                            
                              autocmd BufWritePost,FileWritePost	*.br  call gzip#write("brotli --rm")
                              autocmd BufWritePost,FileWritePost	*.bz2 call gzip#write("bzip2")
                              autocmd BufWritePost,FileWritePost	*.bz3 call gzip#write("bzip3")
                              autocmd BufWritePost,FileWritePost	*.gz  call gzip#write("gzip")
                              autocmd BufWritePost,FileWritePost	*.lz  call gzip#write("lzip")
                              autocmd BufWritePost,FileWritePost	*.lz4  call gzip#write("lz4 -q --rm")
                              autocmd BufWritePost,FileWritePost	*.lzma call gzip#write("lzma -z")
                              autocmd BufWritePost,FileWritePost	*.lzo  call gzip#write("lzop -U")
                              autocmd BufWritePost,FileWritePost	*.xz  call gzip#write("xz -z")
                              autocmd BufWritePost,FileWritePost	*.Z   call gzip#write("compress -f")
                              autocmd BufWritePost,FileWritePost	*.zst  call gzip#write("zstd --rm")
                            
                              autocmd FileAppendPre			*.br call gzip#appre("brotli -d --rm")
                              autocmd FileAppendPre			*.bz2 call gzip#appre("bzip2 -d")
                              autocmd FileAppendPre			*.bz3 call gzip#appre("bzip3 -d")
                              autocmd FileAppendPre			*.gz  call gzip#appre("gzip -dn")
                              autocmd FileAppendPre			*.lz   call gzip#appre("lzip -d")
                              autocmd FileAppendPre			*.lz4 call gzip#appre("lz4 -d -q --rm")
                              autocmd FileAppendPre			*.lzma call gzip#appre("lzma -d")
                              autocmd FileAppendPre			*.lzo call gzip#appre("lzop -d -U")
                              autocmd FileAppendPre			*.xz   call gzip#appre("xz -d")
                              autocmd FileAppendPre			*.Z   call gzip#appre("uncompress")
                              autocmd FileAppendPre			*.zst call gzip#appre("zstd -d --rm")
                            
                              autocmd FileAppendPost		*.br call gzip#write("brotli --rm")
                              autocmd FileAppendPost		*.bz2 call gzip#write("bzip2")
                              autocmd FileAppendPost		*.bz3 call gzip#write("bzip3")
                              autocmd FileAppendPost		*.gz  call gzip#write("gzip")
                              autocmd FileAppendPost		*.lz call gzip#write("lzip")
                              autocmd FileAppendPost		*.lz4 call gzip#write("lz4 --rm")
                              autocmd FileAppendPost		*.lzma call gzip#write("lzma -z")
                              autocmd FileAppendPost		*.lzo call gzip#write("lzop -U")
                              autocmd FileAppendPost		*.xz call gzip#write("xz -z")
                              autocmd FileAppendPost		*.Z   call gzip#write("compress -f")
                              autocmd FileAppendPost		*.zst call gzip#write("zstd --rm")
                            augroup END

SCRIPT  /usr/local/Cellar/neovim/0.11.2/share/nvim/runtime/plugin/matchit.vim
Sourced 1 time
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
                            " Nvim: load the matchit plugin by default.
    1              0.000008 if !exists("g:loaded_matchit") && stridx(&packpath, $VIMRUNTIME) >= 0
                              packadd matchit
    1              0.000002 endif

SCRIPT  /usr/local/Cellar/neovim/0.11.2/share/nvim/runtime/plugin/matchparen.vim
Sourced 1 time
Total time:   0.000168
 Self time:   0.000168

count  total (s)   self (s)
                            " Vim plugin for showing matching parens
                            " Maintainer:	The Vim Project <https://github.com/vim/vim>
                            " Last Change:	2025 Mar 14
                            " Former Maintainer:	Bram Moolenaar <Bram@vim.org>
                            
                            " Exit quickly when:
                            " - this plugin was already loaded (or disabled)
                            " - when 'compatible' is set
                            " - Vim has no support for :defer
    1              0.000008 if exists("g:loaded_matchparen") || &cp ||
                                  \ exists(":defer") != 2
                              finish
    1              0.000001 endif
    1              0.000002 let g:loaded_matchparen = 1
                            
    1              0.000002 if !exists("g:matchparen_timeout")
    1              0.000001   let g:matchparen_timeout = 300
    1              0.000001 endif
    1              0.000002 if !exists("g:matchparen_insert_timeout")
    1              0.000001   let g:matchparen_insert_timeout = 60
    1              0.000000 endif
    1              0.000002 if !exists("g:matchparen_disable_cursor_hl")
    1              0.000002   let g:matchparen_disable_cursor_hl = 0
    1              0.000000 endif
                            
    1              0.000002 augroup matchparen
                              " Replace all matchparen autocommands
    1              0.000007   autocmd! CursorMoved,CursorMovedI,WinEnter,WinScrolled * call s:Highlight_Matching_Pair()
    1              0.000002   autocmd! BufWinEnter * autocmd SafeState * ++once call s:Highlight_Matching_Pair()
    1              0.000003   autocmd! WinLeave,BufLeave * call s:Remove_Matches()
    1              0.000003   autocmd! TextChanged,TextChangedI * call s:Highlight_Matching_Pair()
    1              0.000002   autocmd! TextChangedP * call s:Remove_Matches()
    1              0.000001 augroup END
                            
                            " Skip the rest if it was already done.
    1              0.000004 if exists("*s:Highlight_Matching_Pair")
                              finish
    1              0.000001 endif
                            
    1              0.000002 let s:cpo_save = &cpo
    1              0.000003 set cpo-=C
                            
                            " The function that is invoked (very often) to define a ":match" highlighting
                            " for any matching paren.
    1              0.000002 func s:Highlight_Matching_Pair()
                              if !exists("w:matchparen_ids")
                                let w:matchparen_ids = []
                              endif
                              " Remove any previous match.
                              call s:Remove_Matches()
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
                              if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
                              let c_lnum = line('.')
                              let c_col = col('.')
                              let before = 0
                            
                              let text = getline(c_lnum)
                              let c_before = text->strpart(0, c_col - 1)->slice(-1)
                              let c = text->strpart(c_col - 1)->slice(0, 1)
                              let plist = split(&matchpairs, '.\zs[:,]')
                              let i = index(plist, c)
                              if i < 0
                                " not found, in Insert mode try character before the cursor
                                if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = strlen(c_before)
                                  let c = c_before
                                  let i = index(plist, c)
                                endif
                                if i < 0
                                  " not found, nothing to do
                                  return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let save_cursor = getcurpos()
                                call cursor(c_lnum, c_col - before)
                                defer setpos('.', save_cursor)
                              endif
                            
                              if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
                              elseif exists("b:ts_highlight") && &syntax != 'on'
                                let s_skip = "match(v:lua.vim.treesitter.get_captures_at_cursor(), '"
                                      \ .. 'string\|character\|singlequote\|escape\|symbol\|comment'
                                      \ .. "') != -1"
                              else
                                " do not attempt to match when the syntax item where the cursor is
                                " indicates there does not exist a matching parenthesis, e.g. for shells
                                " case statement: "case $var in foobar)"
                                "
                                " add the check behind a filetype check, so it only needs to be
                                " evaluated for certain filetypes
                                if ['sh']->index(&filetype) >= 0 &&
                                    \ synstack(".", col("."))->indexof({_, id -> synIDattr(id, "name")
                                    \ =~? "shSnglCase"}) >= 0
                                  return
                                endif
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial, and
                                " match "symbol" for lispBarSymbol.
                                let s_skip = 'synstack(".", col("."))'
                                    \ . '->indexof({_, id -> synIDattr(id, "name") =~? '
                                    \ . '"string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
                                try
                                  execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
                                endtry
                              endif
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom
                                if !g:matchparen_disable_cursor_hl
                                  call add(w:matchparen_ids, matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10))
                                else
                                  call add(w:matchparen_ids, matchaddpos('MatchParen', [[m_lnum, m_col]], 10))
                                endif
                                let w:paren_hl_on = 1
                              endif
                            endfunction
                            
    1              0.000002 func s:Remove_Matches()
                              if exists('w:paren_hl_on') && w:paren_hl_on
                                while !empty(w:matchparen_ids)
                                  silent! call remove(w:matchparen_ids, 0)->matchdelete()
                                endwhile
                                let w:paren_hl_on = 0
                              endif
                            endfunc
                            
                            " Define commands that will disable and enable the plugin.
    1              0.000003 command DoMatchParen call s:DoMatchParen()
    1              0.000002 command NoMatchParen call s:NoMatchParen()
                            
    1              0.000001 func s:NoMatchParen()
                              let w = winnr()
                              noau windo call s:Remove_Matches()
                              unlet! g:loaded_matchparen
                              exe "noau ". w . "wincmd w"
                              au! matchparen
                            endfunc
                            
    1              0.000001 func s:DoMatchParen()
                              runtime plugin/matchparen.vim
                              let w = winnr()
                              silent windo doau CursorMoved
                              exe "noau ". w . "wincmd w"
                            endfunc
                            
    1              0.000004 let &cpo = s:cpo_save
    1              0.000003 unlet s:cpo_save

SCRIPT  /usr/local/Cellar/neovim/0.11.2/share/nvim/runtime/plugin/netrwPlugin.vim
Sourced 1 time
Total time:   0.000041
 Self time:   0.000041

count  total (s)   self (s)
                            " Load the netrw package.
                            
    1              0.000008 if &cp || exists("g:loaded_netrw") || exists("g:loaded_netrwPlugin")
    1              0.000001   finish
                            endif
                            
                            packadd netrw
                            
                            " vim:ts=8 sts=2 sw=2 et

SCRIPT  /usr/local/Cellar/neovim/0.11.2/share/nvim/runtime/plugin/rplugin.vim
Sourced 1 time
Total time:   0.000188
 Self time:   0.000070

count  total (s)   self (s)
    1              0.000006 if exists('g:loaded_remote_plugins')
                              finish
    1              0.000001 endif
    1              0.000002 let g:loaded_remote_plugins = '/path/to/manifest'
                            
                            " Get the path to the rplugin manifest file.
    1              0.000002 function! s:GetManifestPath() abort
                              let manifest_base = ''
                            
                              if exists('$NVIM_RPLUGIN_MANIFEST')
                                return fnamemodify($NVIM_RPLUGIN_MANIFEST, ':p')
                              endif
                            
                              let dest = stdpath('data')
                              if !empty(dest)
                                if !isdirectory(dest)
                                  if getftype(dest) != "link"
                                    call mkdir(dest, 'p', 0700)
                                  endif
                                endif
                                let manifest_base = dest
                              endif
                            
                              return manifest_base.'/rplugin.vim'
                            endfunction
                            
                            " Old manifest file based on known script locations.
    1              0.000001 function! s:GetOldManifestPaths() abort
                              let prefix = exists('$MYVIMRC')
                                    \ ? $MYVIMRC
                                    \ : matchstr(get(split(execute('scriptnames'), '\n'), 0, ''), '\f\+$')
                              let origpath = fnamemodify(expand(prefix, 1), ':h')
                                    \.'/.'.fnamemodify(prefix, ':t').'-rplugin~'
                              if !has('win32')
                                return [origpath]
                              endif
                              " Windows used to use $APPLOCALDATA/nvim but stdpath('data') is
                              " $XDG_DATA_DIR/nvim-data
                              let pseudostdpath = exists('$LOCALAPPDATA') ? '$LOCALAPPDATA' : '~/AppData/Local'
                              let pseudostdpath = fnamemodify(expand(pseudostdpath), ':p')
                              return [substitute(pseudostdpath, '[/\\]\=$', '/', '') . 'nvim/rplugin.vim', origpath]
                            endfunction
                            
    1              0.000001 function! s:GetManifest() abort
                              let manifest = s:GetManifestPath()
                              if !filereadable(manifest)
                                " Check if an old manifest file exists and move it to the new location.
                                for old_manifest in s:GetOldManifestPaths()
                                  if filereadable(old_manifest)
                                    call rename(old_manifest, manifest)
                                    break
                                  endif
                                endfor
                              endif
                              return manifest
                            endfunction
                            
    1              0.000001 function! s:LoadRemotePlugins() abort
                              let g:loaded_remote_plugins = s:GetManifest()
                              if filereadable(g:loaded_remote_plugins)
                                execute 'source' fnameescape(g:loaded_remote_plugins)
                              endif
                            endfunction
                            
    1              0.000004 command! -bar UpdateRemotePlugins call remote#host#UpdateRemotePlugins()
                            
    1              0.000007 if index(v:argv, "--clean") < 0
    1   0.000125   0.000007   call s:LoadRemotePlugins()
    1              0.000003 endif

SCRIPT  /usr/local/Cellar/neovim/0.11.2/share/nvim/runtime/plugin/shada.vim
Sourced 1 time
Total time:   0.000070
 Self time:   0.000070

count  total (s)   self (s)
    1              0.000006 if exists('g:loaded_shada_plugin')
                              finish
    1              0.000001 endif
    1              0.000003 let g:loaded_shada_plugin = 1
                            
    1              0.000002 augroup ShaDaCommands
    1              0.000005   autocmd!
    1              0.000010   autocmd BufReadCmd *.shada,*.shada.tmp.[a-z]
                                    \ :if !empty(v:cmdarg)|throw '++opt not supported'|endif
                                    \ |call setline('.', shada#get_strings(readfile(expand('<afile>'),'b')))
                                    \ |setlocal filetype=shada
    1              0.000005   autocmd FileReadCmd *.shada,*.shada.tmp.[a-z]
                                    \ :if !empty(v:cmdarg)|throw '++opt not supported'|endif
                                    \ |call append("'[", shada#get_strings(readfile(expand('<afile>'), 'b')))
    1              0.000007   autocmd BufWriteCmd *.shada,*.shada.tmp.[a-z]
                                    \ :if !empty(v:cmdarg)|throw '++opt not supported'|endif
                                    \ |if writefile(shada#get_binstrings(getline(1, '$')),
                                                   \expand('<afile>'), 'b') == 0
                                    \ |  let &l:modified = (expand('<afile>') is# bufname(+expand('<abuf>'))
                                                           \? 0
                                                           \: stridx(&cpoptions, '+') != -1)
                                    \ |endif
    1              0.000006   autocmd FileWriteCmd *.shada,*.shada.tmp.[a-z]
                                    \ :if !empty(v:cmdarg)|throw '++opt not supported'|endif
                                    \ |call writefile(
                                          \shada#get_binstrings(getline(min([line("'["), line("']")]),
                                                                       \max([line("'["), line("']")]))),
                                          \expand('<afile>'),
                                          \'b')
    1              0.000010   autocmd FileAppendCmd *.shada,*.shada.tmp.[a-z]
                                    \ :if !empty(v:cmdarg)|throw '++opt not supported'|endif
                                    \ |call writefile(
                                          \shada#get_binstrings(getline(min([line("'["), line("']")]),
                                                                       \max([line("'["), line("']")]))),
                                          \expand('<afile>'),
                                          \'ab')
    1              0.000004   autocmd SourceCmd *.shada,*.shada.tmp.[a-z]
                                    \ :execute 'rshada' fnameescape(expand('<afile>'))
    1              0.000003 augroup END

SCRIPT  /usr/local/Cellar/neovim/0.11.2/share/nvim/runtime/plugin/spellfile.vim
Sourced 1 time
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
                            " Vim plugin for downloading spell files
                            
    1              0.000006 if exists("loaded_spellfile_plugin") || &cp || exists("#SpellFileMissing")
    1              0.000001   finish
                            endif
                            let loaded_spellfile_plugin = 1
                            
                            autocmd SpellFileMissing * call spellfile#LoadFile(expand('<amatch>'))

SCRIPT  /usr/local/Cellar/neovim/0.11.2/share/nvim/runtime/plugin/tarPlugin.vim
Sourced 1 time
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
                            " tarPlugin.vim -- a Vim plugin for browsing tarfiles
                            "
                            " Original was copyright (c) 2002, Michael C. Toren <mct@toren.net>
                            " Modified by Charles E. Campbell
                            " Distributed under the GNU General Public License.
                            "
                            " Updates are available from <http://michael.toren.net/code/>.  If you
                            " find this script useful, or have suggestions for improvements, please
                            " let me know.
                            " Also look there for further comments and documentation.
                            "
                            " This part only sets the autocommands.  The functions are in autoload/tar.vim.
                            " ---------------------------------------------------------------------
                            "  Load Once: {{{1
    1              0.000005 if &cp || exists("g:loaded_tarPlugin")
    1              0.000001  finish
                            endif
                            let g:loaded_tarPlugin = "v32"
                            let s:keepcpo          = &cpo
                            set cpo&vim
                            
                            " ---------------------------------------------------------------------
                            "  Public Interface: {{{1
                            augroup tar
                              au!
                              au BufReadCmd   tarfile::*	call tar#Read(expand("<amatch>"), 1)
                              au FileReadCmd  tarfile::*	call tar#Read(expand("<amatch>"), 0)
                              au BufWriteCmd  tarfile::*	call tar#Write(expand("<amatch>"))
                              au FileWriteCmd tarfile::*	call tar#Write(expand("<amatch>"))
                            
                              if has("unix")
                               au BufReadCmd   tarfile::*/*	call tar#Read(expand("<amatch>"), 1)
                               au FileReadCmd  tarfile::*/*	call tar#Read(expand("<amatch>"), 0)
                               au BufWriteCmd  tarfile::*/*	call tar#Write(expand("<amatch>"))
                               au FileWriteCmd tarfile::*/*	call tar#Write(expand("<amatch>"))
                              endif
                            
                              au BufReadCmd   *.lrp			call tar#Browse(expand("<amatch>"))
                              au BufReadCmd   *.tar			call tar#Browse(expand("<amatch>"))
                              au BufReadCmd   *.tar.bz2		call tar#Browse(expand("<amatch>"))
                              au BufReadCmd   *.tar.bz3		call tar#Browse(expand("<amatch>"))
                              au BufReadCmd   *.tar.gz		call tar#Browse(expand("<amatch>"))
                              au BufReadCmd   *.tar.lz4		call tar#Browse(expand("<amatch>"))
                              au BufReadCmd   *.tar.lzma		call tar#Browse(expand("<amatch>"))
                              au BufReadCmd   *.tar.xz		call tar#Browse(expand("<amatch>"))
                              au BufReadCmd   *.tar.Z		call tar#Browse(expand("<amatch>"))
                              au BufReadCmd   *.tar.zst		call tar#Browse(expand("<amatch>"))
                              au BufReadCmd   *.tbz			call tar#Browse(expand("<amatch>"))
                              au BufReadCmd   *.tgz			call tar#Browse(expand("<amatch>"))
                              au BufReadCmd   *.tlz4		call tar#Browse(expand("<amatch>"))
                              au BufReadCmd   *.txz			call tar#Browse(expand("<amatch>"))
                              au BufReadCmd   *.tzst		call tar#Browse(expand("<amatch>"))
                            augroup END
                            
                            " ---------------------------------------------------------------------
                            " Restoration And Modelines: {{{1
                            " vim: fdm=marker
                            let &cpo= s:keepcpo
                            unlet s:keepcpo

SCRIPT  /usr/local/Cellar/neovim/0.11.2/share/nvim/runtime/plugin/tutor.vim
Sourced 1 time
Total time:   0.000031
 Self time:   0.000031

count  total (s)   self (s)
                            " Tutor:	New Style Tutor Plugin :h vim-tutor-mode
                            " Maintainer:	This runtime file is looking for a new maintainer.
                            " Contributors:	Phạm Bình An <phambinhanctb2004@gmail.com>
                            " Original Author: Felipe Morales <hel.sheep@gmail.com>
                            " Date: 2025 May 12
                            
    1              0.000007 if exists('g:loaded_tutor_mode_plugin') || &compatible
                                finish
    1              0.000001 endif
    1              0.000003 let g:loaded_tutor_mode_plugin = 1
                            
    1              0.000007 command! -nargs=? -complete=custom,tutor#TutorCmdComplete Tutor call tutor#TutorCmd(<q-args>)

SCRIPT  /usr/local/Cellar/neovim/0.11.2/share/nvim/runtime/plugin/zipPlugin.vim
Sourced 1 time
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
                            " zipPlugin.vim: Handles browsing zipfiles
                            "            PLUGIN PORTION
                            " Date:			Dec 07, 2021
                            " Maintainer:	This runtime file is looking for a new maintainer.
                            " Former Maintainer:	Charles E Campbell
                            " License:		Vim License  (see vim's :help license)
                            " Copyright:    Copyright (C) 2005-2016 Charles E. Campbell {{{1
                            "               Permission is hereby granted to use and distribute this code,
                            "               with or without modifications, provided that this copyright
                            "               notice is copied with it. Like anything else that's free,
                            "               zipPlugin.vim is provided *as is* and comes with no warranty
                            "               of any kind, either expressed or implied. By using this
                            "               plugin, you agree that in no event will the copyright
                            "               holder be liable for any damages resulting from the use
                            "               of this software.
                            "
                            " (James 4:8 WEB) Draw near to God, and he will draw near to you.
                            " Cleanse your hands, you sinners; and purify your hearts, you double-minded.
                            " ---------------------------------------------------------------------
                            " Load Once: {{{1
    1              0.000005 if &cp || exists("g:loaded_zipPlugin")
    1              0.000001  finish
                            endif
                            let g:loaded_zipPlugin = "v33"
                            let s:keepcpo          = &cpo
                            set cpo&vim
                            
                            " ---------------------------------------------------------------------
                            " Options: {{{1
                            if !exists("g:zipPlugin_ext")
                             let g:zipPlugin_ext='*.aar,*.apk,*.celzip,*.crtx,*.docm,*.docx,*.dotm,*.dotx,*.ear,*.epub,*.gcsx,*.glox,*.gqsx,*.ja,*.jar,*.kmz,*.odb,*.odc,*.odf,*.odg,*.odi,*.odm,*.odp,*.ods,*.odt,*.otc,*.otf,*.otg,*.oth,*.oti,*.otp,*.ots,*.ott,*.oxt,*.potm,*.potx,*.ppam,*.ppsm,*.ppsx,*.pptm,*.pptx,*.sldx,*.thmx,*.vdw,*.war,*.wsz,*.xap,*.xlam,*.xlsb,*.xlsm,*.xlsx,*.xltm,*.xltx,*.xpi,*.zip'
                            endif
                            
                            " ---------------------------------------------------------------------
                            " Public Interface: {{{1
                            augroup zip
                             au!
                             au BufReadCmd   zipfile:*	call zip#Read(expand("<amatch>"), 1)
                             au FileReadCmd  zipfile:*	call zip#Read(expand("<amatch>"), 0)
                             au BufWriteCmd  zipfile:*	call zip#Write(expand("<amatch>"))
                             au FileWriteCmd zipfile:*	call zip#Write(expand("<amatch>"))
                            
                             if has("unix")
                              au BufReadCmd   zipfile:*/*	call zip#Read(expand("<amatch>"), 1)
                              au FileReadCmd  zipfile:*/*	call zip#Read(expand("<amatch>"), 0)
                              au BufWriteCmd  zipfile:*/*	call zip#Write(expand("<amatch>"))
                              au FileWriteCmd zipfile:*/*	call zip#Write(expand("<amatch>"))
                             endif
                            
                             exe "au BufReadCmd ".g:zipPlugin_ext.' call zip#Browse(expand("<amatch>"))'
                            augroup END
                            
                            " ---------------------------------------------------------------------
                            "  Restoration And Modelines: {{{1
                            "  vim: fdm=marker
                            let &cpo= s:keepcpo
                            unlet s:keepcpo

SCRIPT  /usr/local/Cellar/neovim/0.11.2/share/nvim/runtime/plugin/editorconfig.lua
Sourced 1 time
Total time:   0.000143
 Self time:   0.000143

count  total (s)   self (s)
                            local group = vim.api.nvim_create_augroup('nvim.editorconfig', {})
                            vim.api.nvim_create_autocmd({ 'BufNewFile', 'BufRead', 'BufFilePost' }, {
                              group = group,
                              callback = function(args)
                                -- Buffer-local enable has higher priority
                                local enable = vim.F.if_nil(vim.b.editorconfig, vim.g.editorconfig, true)
                                if not enable then
                                  return
                                end
                            
                                require('editorconfig').config(args.buf)
                              end,
                            })

SCRIPT  /usr/local/Cellar/neovim/0.11.2/share/nvim/runtime/plugin/man.lua
Sourced 1 time
Total time:   0.000140
 Self time:   0.000140

count  total (s)   self (s)
                            if vim.g.loaded_man ~= nil then
                              return
                            end
                            vim.g.loaded_man = true
                            
                            vim.api.nvim_create_user_command('Man', function(params)
                              local man = require('man')
                              if params.bang then
                                man.init_pager()
                              else
                                local _, err = pcall(man.open_page, params.count, params.smods, params.fargs)
                                if err then
                                  vim.notify('man.lua: ' .. err, vim.log.levels.ERROR)
                                end
                              end
                            end, {
                              bang = true,
                              bar = true,
                              range = true,
                              addr = 'other',
                              nargs = '*',
                              complete = function(...)
                                return require('man').man_complete(...)
                              end,
                            })
                            
                            local augroup = vim.api.nvim_create_augroup('nvim.man', {})
                            
                            vim.api.nvim_create_autocmd('BufReadCmd', {
                              group = augroup,
                              pattern = 'man://*',
                              nested = true,
                              callback = function(params)
                                local err = require('man').read_page(assert(params.match:match('man://(.*)')))
                                if err then
                                  vim.notify('man.lua: ' .. err, vim.log.levels.ERROR)
                                end
                              end,
                            })

SCRIPT  /usr/local/Cellar/neovim/0.11.2/share/nvim/runtime/plugin/osc52.lua
Sourced 1 time
Total time:   0.000150
 Self time:   0.000150

count  total (s)   self (s)
                            --- @class (private) TermFeatures
                            --- @field osc52 boolean?
                            
                            local id = vim.api.nvim_create_augroup('nvim.osc52', { clear = true })
                            vim.api.nvim_create_autocmd('UIEnter', {
                              group = id,
                              desc = 'Enable OSC 52 feature flag if a supporting TUI is attached',
                              callback = function()
                                -- If OSC 52 is explicitly disabled by the user then don't do anything
                                if vim.g.termfeatures ~= nil and vim.g.termfeatures.osc52 == false then
                                  return
                                end
                            
                                local tty = false
                                for _, ui in ipairs(vim.api.nvim_list_uis()) do
                                  if ui.stdout_tty then
                                    tty = true
                                    break
                                  end
                                end
                            
                                -- Do not query when any of the following is true:
                                --   * No TUI is attached
                                --   * Using a badly behaved terminal
                                if not tty or vim.env.TERM_PROGRAM == 'Apple_Terminal' then
                                  local termfeatures = vim.g.termfeatures or {} ---@type TermFeatures
                                  termfeatures.osc52 = nil
                                  vim.g.termfeatures = termfeatures
                                  return
                                end
                            
                                require('vim.termcap').query('Ms', function(cap, found, seq)
                                  if not found then
                                    return
                                  end
                            
                                  assert(cap == 'Ms')
                            
                                  -- If the terminal reports a sequence other than OSC 52 for the Ms capability
                                  -- then ignore it. We only support OSC 52 (for now)
                                  if not seq or not seq:match('^\027%]52') then
                                    return
                                  end
                            
                                  local termfeatures = vim.g.termfeatures or {} ---@type TermFeatures
                                  termfeatures.osc52 = true
                                  vim.g.termfeatures = termfeatures
                                end)
                              end,
                            })
                            
                            vim.api.nvim_create_autocmd('UILeave', {
                              group = id,
                              desc = 'Reset OSC 52 feature flag if no TUIs are attached',
                              callback = function()
                                -- If OSC 52 is explicitly disabled by the user then don't do anything
                                if vim.g.termfeatures ~= nil and vim.g.termfeatures.osc52 == false then
                                  return
                                end
                            
                                -- If no TUI is connected to Nvim's stdout then reset the OSC 52 term features flag
                                for _, ui in ipairs(vim.api.nvim_list_uis()) do
                                  if ui.stdout_tty then
                                    return
                                  end
                                end
                            
                                local termfeatures = vim.g.termfeatures or {} ---@type TermFeatures
                                termfeatures.osc52 = nil
                                vim.g.termfeatures = termfeatures
                              end,
                            })

SCRIPT  /usr/local/Cellar/neovim/0.11.2/share/nvim/runtime/plugin/tohtml.lua
Sourced 1 time
Total time:   0.000145
 Self time:   0.000145

count  total (s)   self (s)
                            if vim.g.loaded_2html_plugin ~= nil then
                              return
                            end
                            vim.g.loaded_2html_plugin = true
                            
                            vim.api.nvim_create_user_command('TOhtml', function(args)
                              local outfile = args.args ~= '' and args.args or vim.fn.tempname() .. '.html'
                              local html = require('tohtml').tohtml(0, { range = { args.line1, args.line2 } })
                              vim.fn.writefile(html, outfile)
                              vim.cmd.split(outfile)
                              vim.bo.filetype = 'html'
                            end, { bar = true, nargs = '?', range = '%' })

SCRIPT  /usr/local/Cellar/neovim/0.11.2/share/nvim/runtime/autoload/provider/clipboard.vim
Sourced 1 time
Total time:   0.000301
 Self time:   0.000227

count  total (s)   self (s)
                            " The clipboard provider uses shell commands to communicate with the clipboard.
                            " The provider function will only be registered if a supported command is
                            " available.
                            
    1              0.000006 if exists('g:loaded_clipboard_provider')
                              finish
    1              0.000001 endif
                            " Default to 0.  provider#clipboard#Executable() may set 2.
                            " To force a reload:
                            "   :unlet g:loaded_clipboard_provider
                            "   :runtime autoload/provider/clipboard.vim
    1              0.000003 let g:loaded_clipboard_provider = 0
                            
    1              0.000002 let s:copy = {}
    1              0.000001 let s:paste = {}
    1              0.000001 let s:clipboard = {}
                            
                            " When caching is enabled, store the jobid of the xclip/xsel process keeping
                            " ownership of the selection, so we know how long the cache is valid.
    1              0.000004 let s:selection = { 'owner': 0, 'data': [], 'stderr_buffered': v:true }
                            
    1              0.000002 function! s:selection.on_exit(jobid, data, event) abort
                              " At this point this nvim instance might already have launched
                              " a new provider instance. Don't drop ownership in this case.
                              if self.owner == a:jobid
                                let self.owner = 0
                              endif
                              " Don't print if exit code is >= 128 ( exit is 128+SIGNUM if by signal (e.g. 143 on SIGTERM))
                              if a:data > 0 && a:data < 128
                                echohl WarningMsg
                                echomsg 'clipboard: error invoking '.get(self.argv, 0, '?').': '.join(self.stderr)
                                echohl None
                              endif
                            endfunction
                            
    1              0.000004 let s:selections = { '*': s:selection, '+': copy(s:selection) }
                            
    1              0.000002 function! s:try_cmd(cmd, ...) abort
                              let out = systemlist(a:cmd, (a:0 ? a:1 : ['']), 1)
                              if v:shell_error
                                if !exists('s:did_error_try_cmd')
                                  echohl WarningMsg
                                  echomsg "clipboard: error: ".(len(out) ? out[0] : v:shell_error)
                                  echohl None
                                  let s:did_error_try_cmd = 1
                                endif
                                return 0
                              endif
                              return out
                            endfunction
                            
                            " Returns TRUE if `cmd` exits with success, else FALSE.
    1              0.000001 function! s:cmd_ok(cmd) abort
                              call system(a:cmd)
                              return v:shell_error == 0
                            endfunction
                            
    1              0.000001 function! s:split_cmd(cmd) abort
                              return (type(a:cmd) == v:t_string) ? split(a:cmd, " ") : a:cmd
                            endfunction
                            
    1              0.000001 function! s:set_osc52() abort
                              let s:copy['+'] = v:lua.require'vim.ui.clipboard.osc52'.copy('+')
                              let s:copy['*'] = v:lua.require'vim.ui.clipboard.osc52'.copy('*')
                              let s:paste['+'] = v:lua.require'vim.ui.clipboard.osc52'.paste('+')
                              let s:paste['*'] = v:lua.require'vim.ui.clipboard.osc52'.paste('*')
                              return 'OSC 52'
                            endfunction
                            
    1              0.000001 function! s:set_pbcopy() abort
                              let s:copy['+'] = ['pbcopy']
                              let s:paste['+'] = ['pbpaste']
                              let s:copy['*'] = s:copy['+']
                              let s:paste['*'] = s:paste['+']
                              let s:cache_enabled = 0
                              return 'pbcopy'
                            endfunction
                            
    1              0.000001 function! s:set_wayland() abort
                              let s:copy['+'] = ['wl-copy', '--type', 'text/plain']
                              let s:paste['+'] = ['wl-paste', '--no-newline']
                              let s:copy['*'] = ['wl-copy', '--primary', '--type', 'text/plain']
                              let s:paste['*'] = ['wl-paste', '--no-newline', '--primary']
                              return 'wl-copy'
                            endfunction
                            
    1              0.000001 function! s:set_wayclip() abort
                              let s:copy['+'] = ['waycopy', '-t', 'text/plain']
                              let s:paste['+'] = ['waypaste', '-t', 'text/plain']
                              let s:copy['*'] = s:copy['+']
                              let s:paste['*'] = s:paste['+']
                              return 'wayclip'
                            endfunction
                            
    1              0.000001 function! s:set_xsel() abort
                              let s:copy['+'] = ['xsel', '--nodetach', '-i', '-b']
                              let s:paste['+'] = ['xsel', '-o', '-b']
                              let s:copy['*'] = ['xsel', '--nodetach', '-i', '-p']
                              let s:paste['*'] = ['xsel', '-o', '-p']
                              return 'xsel'
                            endfunction
                            
    1              0.000001 function! s:set_xclip() abort
                              let s:copy['+'] = ['xclip', '-quiet', '-i', '-selection', 'clipboard']
                              let s:paste['+'] = ['xclip', '-o', '-selection', 'clipboard']
                              let s:copy['*'] = ['xclip', '-quiet', '-i', '-selection', 'primary']
                              let s:paste['*'] = ['xclip', '-o', '-selection', 'primary']
                              return 'xclip'
                            endfunction
                            
    1              0.000001 function! s:set_lemonade() abort
                              let s:copy['+'] = ['lemonade', 'copy']
                              let s:paste['+'] = ['lemonade', 'paste']
                              let s:copy['*'] = ['lemonade', 'copy']
                              let s:paste['*'] = ['lemonade', 'paste']
                              return 'lemonade'
                            endfunction
                            
    1              0.000001 function! s:set_doitclient() abort
                              let s:copy['+'] = ['doitclient', 'wclip']
                              let s:paste['+'] = ['doitclient', 'wclip', '-r']
                              let s:copy['*'] = s:copy['+']
                              let s:paste['*'] = s:paste['+']
                              return 'doitclient'
                            endfunction
                            
    1              0.000004 function! s:set_win32yank() abort
                              if has('wsl') && getftype(exepath('win32yank.exe')) == 'link'
                                let win32yank = resolve(exepath('win32yank.exe'))
                              else
                                let win32yank = 'win32yank.exe'
                              endif
                              let s:copy['+'] = [win32yank, '-i', '--crlf']
                              let s:paste['+'] = [win32yank, '-o', '--lf']
                              let s:copy['*'] = s:copy['+']
                              let s:paste['*'] = s:paste['+']
                              return 'win32yank'
                            endfunction
                            
    1              0.000001 function! s:set_putclip() abort
                              let s:copy['+'] = ['putclip']
                              let s:paste['+'] = ['getclip']
                              let s:copy['*'] = s:copy['+']
                              let s:paste['*'] = s:paste['+']
                              return 'putclip'
                            endfunction
                            
    1              0.000001 function! s:set_clip() abort
                              let s:copy['+'] = ['clip']
                              let s:paste['+'] = ['powershell', '-NoProfile', '-NoLogo', '-Command', 'Get-Clipboard']
                              let s:copy['*'] = s:copy['+']
                              let s:paste['*'] = s:paste['+']
                              return 'clip'
                            endfunction
                            
    1              0.000001 function! s:set_termux() abort
                              let s:copy['+'] = ['termux-clipboard-set']
                              let s:paste['+'] = ['termux-clipboard-get']
                              let s:copy['*'] = s:copy['+']
                              let s:paste['*'] = s:paste['+']
                              return 'termux-clipboard'
                            endfunction
                            
    1              0.000001 function! s:set_tmux() abort
                              let tmux_v = v:lua.vim.version.parse(system(['tmux', '-V']))
                              if !empty(tmux_v) && !v:lua.vim.version.lt(tmux_v, [3,2,0])
                                let s:copy['+'] = ['tmux', 'load-buffer', '-w', '-']
                              else
                                let s:copy['+'] = ['tmux', 'load-buffer', '-']
                              endif
                              let s:paste['+'] = ['tmux', 'save-buffer', '-']
                              let s:copy['*'] = s:copy['+']
                              let s:paste['*'] = s:paste['+']
                              return 'tmux'
                            endfunction
                            
    1              0.000002 let s:cache_enabled = 1
    1              0.000001 let s:err = ''
                            
    1              0.000001 function! provider#clipboard#Error() abort
                              return s:err
                            endfunction
                            
    1              0.000001 function! provider#clipboard#Executable() abort
                              " Setting g:clipboard to v:false explicitly opts-in to using the "builtin" clipboard providers below
                              if exists('g:clipboard') && g:clipboard isnot# v:false
                                if v:t_string ==# type(g:clipboard)
                                  " Handle string form of g:clipboard for all builtin providers
                                  if 'osc52' == g:clipboard
                                    " User opted-in to OSC 52 by manually setting g:clipboard.
                                    return s:set_osc52()
                                  elseif 'pbcopy' == g:clipboard
                                    return s:set_pbcopy()
                                  elseif 'wl-copy' == g:clipboard
                                    return s:set_wayland()
                                  elseif 'wayclip' == g:clipboard
                                    return s:set_wayclip()
                                  elseif 'xsel' == g:clipboard
                                    return s:set_xsel()
                                  elseif 'xclip' == g:clipboard
                                    return s:set_xclip()
                                  elseif 'lemonade' == g:clipboard
                                    return s:set_lemonade()
                                  elseif 'doitclient' == g:clipboard
                                    return s:set_doitclient()
                                  elseif 'win32yank' == g:clipboard
                                    return s:set_win32yank()
                                  elseif 'putclip' == g:clipboard
                                    return s:set_putclip()
                                  elseif 'clip' == g:clipboard
                                    return s:set_clip()
                                  elseif 'termux' == g:clipboard
                                    return s:set_termux()
                                  elseif 'tmux' == g:clipboard
                                    return s:set_tmux()
                                  endif
                                endif
                            
                                if type({}) isnot# type(g:clipboard)
                                      \ || type({}) isnot# type(get(g:clipboard, 'copy', v:null))
                                      \ || type({}) isnot# type(get(g:clipboard, 'paste', v:null))
                                  let s:err = 'clipboard: invalid g:clipboard'
                                  return ''
                                endif
                            
                                let s:copy = {}
                                let s:copy['+'] = s:split_cmd(get(g:clipboard.copy, '+', v:null))
                                let s:copy['*'] = s:split_cmd(get(g:clipboard.copy, '*', v:null))
                            
                                let s:paste = {}
                                let s:paste['+'] = s:split_cmd(get(g:clipboard.paste, '+', v:null))
                                let s:paste['*'] = s:split_cmd(get(g:clipboard.paste, '*', v:null))
                            
                                let s:cache_enabled = get(g:clipboard, 'cache_enabled', 0)
                                return get(g:clipboard, 'name', 'g:clipboard')
                              elseif has('mac')
                                return s:set_pbcopy()
                              elseif !empty($WAYLAND_DISPLAY) && executable('wl-copy') && executable('wl-paste')
                                return s:set_wayland()
                              elseif !empty($WAYLAND_DISPLAY) && executable('waycopy') && executable('waypaste')
                                return s:set_wayclip()
                              elseif !empty($DISPLAY) && executable('xsel') && s:cmd_ok('xsel -o -b')
                                return s:set_xsel()
                              elseif !empty($DISPLAY) && executable('xclip')
                                return s:set_xclip()
                              elseif executable('lemonade')
                                return s:set_lemonade()
                              elseif executable('doitclient')
                                return s:set_doitclient()
                              elseif executable('win32yank.exe')
                                return s:set_win32yank()
                              elseif executable('putclip') && executable('getclip')
                                return s:set_putclip()
                              elseif executable('clip') && executable('powershell')
                                return s:set_clip()
                              elseif executable('termux-clipboard-set')
                                return s:set_termux()
                              elseif executable('tmux') && (!empty($TMUX) || 0 == jobwait([jobstart(['tmux', 'list-buffers'])], 2000)[0])
                                return s:set_tmux()
                              elseif get(get(g:, 'termfeatures', {}), 'osc52') && &clipboard ==# ''
                                " Don't use OSC 52 when 'clipboard' is set. It can be slow and cause a lot
                                " of user prompts. Users can opt-in to it by setting g:clipboard manually.
                                return s:set_osc52()
                              endif
                            
                              let s:err = 'clipboard: No clipboard tool. :help clipboard'
                              return ''
                            endfunction
                            
    1              0.000001 function! s:clipboard.get(reg) abort
                              if type(s:paste[a:reg]) == v:t_func
                                return s:paste[a:reg]()
                              elseif s:selections[a:reg].owner > 0
                                return s:selections[a:reg].data
                              end
                            
                              let clipboard_data = s:try_cmd(s:paste[a:reg])
                              if match(&clipboard, '\v(unnamed|unnamedplus)') >= 0
                                    \ && type(clipboard_data) == v:t_list
                                    \ && get(s:selections[a:reg].data, 0, []) ==# clipboard_data
                                " When system clipboard return is same as our cache return the cache
                                " as it contains regtype information
                                return s:selections[a:reg].data
                              end
                              return clipboard_data
                            endfunction
                            
    1              0.000001 function! s:clipboard.set(lines, regtype, reg) abort
                              if a:reg == '"'
                                call s:clipboard.set(a:lines,a:regtype,'+')
                                if s:copy['*'] != s:copy['+']
                                  call s:clipboard.set(a:lines,a:regtype,'*')
                                end
                                return 0
                              end
                            
                              if type(s:copy[a:reg]) == v:t_func
                                call s:copy[a:reg](a:lines, a:regtype)
                                return 0
                              end
                            
                              if s:cache_enabled == 0
                                call s:try_cmd(s:copy[a:reg], a:lines)
                                "Cache it anyway we can compare it later to get regtype of the yank
                                let s:selections[a:reg] = copy(s:selection)
                                let s:selections[a:reg].data = [a:lines, a:regtype]
                                return 0
                              end
                            
                              if s:selections[a:reg].owner > 0
                                let prev_job = s:selections[a:reg].owner
                              end
                              let s:selections[a:reg] = copy(s:selection)
                              let selection = s:selections[a:reg]
                              let selection.data = [a:lines, a:regtype]
                              let selection.argv = s:copy[a:reg]
                              let selection.detach = s:cache_enabled
                              let selection.cwd = "/"
                              let jobid = jobstart(selection.argv, selection)
                              if jobid > 0
                                call jobsend(jobid, a:lines)
                                call jobclose(jobid, 'stdin')
                                " xclip does not close stdout when receiving input via stdin
                                if selection.argv[0] ==# 'xclip'
                                  call jobclose(jobid, 'stdout')
                                endif
                                let selection.owner = jobid
                                let ret = 1
                              else
                                echohl WarningMsg
                                echomsg 'clipboard: failed to execute: '.(s:copy[a:reg])
                                echohl None
                                let ret = 1
                              endif
                            
                              " The previous provider instance should exit when the new one takes
                              " ownership, but kill it to be sure we don't fill up the job table.
                              if exists('prev_job')
                                call timer_start(1000, {... ->
                                      \ jobwait([prev_job], 0)[0] == -1
                                      \ && jobstop(prev_job)})
                              endif
                            
                              return ret
                            endfunction
                            
    1              0.000001 function! provider#clipboard#Call(method, args) abort
                              if get(s:, 'here', v:false)  " Clipboard provider must not recurse. #7184
                                return 0
                              endif
                              let s:here = v:true
                              try
                                return call(s:clipboard[a:method],a:args,s:clipboard)
                              finally
                                let s:here = v:false
                              endtry
                            endfunction
                            
                            " eval_has_provider() decides based on this variable.
    1   0.000084   0.000011 let g:loaded_clipboard_provider = empty(provider#clipboard#Executable()) ? 0 : 2

SCRIPT  /Users/techdeus/.local/share/nvim-test/site/pack/deps/opt/which-key.nvim/plugin/which-key.lua
Sourced 1 time
Total time:   0.000355
 Self time:   0.000355

count  total (s)   self (s)
                            local timer = (vim.uv or vim.loop).new_timer()
                            timer:start(
                              500,
                              0,
                              vim.schedule_wrap(function()
                                local wk = require("which-key")
                                if not wk.did_setup then
                                  wk.setup()
                                end
                              end)
                            )

SCRIPT  /Users/techdeus/.local/share/nvim-test/site/pack/deps/opt/fzf-lua/plugin/fzf-lua.lua
Sourced 1 time
Total time:   0.000382
 Self time:   0.000382

count  total (s)   self (s)
Cannot open file!

SCRIPT  /usr/local/Cellar/neovim/0.11.2/share/nvim/runtime/ftplugin/lua.vim
Sourced 1 time
Total time:   0.000215
 Self time:   0.000215

count  total (s)   self (s)
                            " Vim filetype plugin file.
                            " Language:		Lua
                            " Maintainer:		Doug Kearns <dougkearns@gmail.com>
                            " Previous Maintainer:	Max Ischenko <mfi@ukr.net>
                            " Contributor:		Dorai Sitaram <ds26@gte.com>
                            "			C.D. MacEachern <craig.daniel.maceachern@gmail.com>
                            "			Phạm Bình An <phambinhanctb2004@gmail.com>
                            " Last Change:		2025 Feb 27
                            
    1              0.000009 if exists("b:did_ftplugin")
                              finish
    1              0.000001 endif
    1              0.000003 let b:did_ftplugin = 1
                            
                            " keep in sync with syntax/lua.vim
    1              0.000002 if !exists("lua_version")
                              " Default is lua 5.3
    1              0.000002   let lua_version = 5
    1              0.000001   let lua_subversion = 3
                            elseif !exists("lua_subversion")
                              " lua_version exists, but lua_subversion doesn't. In this case set it to 0
                              let lua_subversion = 0
    1              0.000001 endif
                            
    1              0.000003 let s:cpo_save = &cpo
    1              0.000007 set cpo&vim
                            
    1              0.000006 setlocal comments=:---,:--
    1              0.000003 setlocal commentstring=--\ %s
    1              0.000005 setlocal formatoptions-=t formatoptions+=croql
                            
    1              0.000005 let &l:define = '\<function\|\<local\%(\s\+function\)\='
                            
    1              0.000003 let &l:include = '\<\%(\%(do\|load\)file\|require\)\s*('
    1              0.000005 setlocal includeexpr=s:LuaInclude(v:fname)
    1              0.000003 setlocal suffixesadd=.lua
                            
    1              0.000002 let b:undo_ftplugin = "setl cms< com< def< fo< inc< inex< sua<"
                            
    1              0.000004 if exists("loaded_matchit") && !exists("b:match_words")
    1              0.000002   let b:match_ignorecase = 0
    1              0.000008   let b:match_words =
                            	\ '\<\%(do\|function\|if\)\>:' ..
                            	\ '\<\%(return\|else\|elseif\)\>:' ..
                            	\ '\<end\>,' ..
                            	\ '\<repeat\>:\<until\>,' ..
                            	\ '\%(--\)\=\[\(=*\)\[:]\1]'
    1              0.000008   let b:undo_ftplugin ..= " | unlet! b:match_words b:match_ignorecase"
    1              0.000001 endif
                            
    1              0.000008 if (has("gui_win32") || has("gui_gtk")) && !exists("b:browsefilter")
                              let b:browsefilter = "Lua Source Files (*.lua)\t*.lua\n"
                              if has("win32")
                                let b:browsefilter ..= "All Files (*.*)\t*\n"
                              else
                                let b:browsefilter ..= "All Files (*)\t*\n"
                              endif
                              let b:undo_ftplugin ..= " | unlet! b:browsefilter"
    1              0.000001 endif
                            
                            " The rest of the file needs to be :sourced only once per Vim session
    1              0.000003 if exists("s:loaded_lua") || &cp
                              let &cpo = s:cpo_save
                              unlet s:cpo_save
                              finish
    1              0.000001 endif
    1              0.000001 let s:loaded_lua = 1
                            
    1              0.000003 function s:LuaInclude(fname) abort
                              let lua_ver = str2float(printf("%d.%02d", g:lua_version, g:lua_subversion))
                              let fname = tr(a:fname, '.', '/')
                              let paths = lua_ver >= 5.03 ? [fname .. ".lua", fname .. "/init.lua"] : [fname .. ".lua"]
                              for path in paths
                                if filereadable(path)
                                  return path
                                endif
                              endfor
                              return fname
                            endfunction
                            
    1              0.000005 let &cpo = s:cpo_save
    1              0.000002 unlet s:cpo_save
                            
                            " vim: nowrap sw=2 sts=2 ts=8 noet:

SCRIPT  /usr/local/Cellar/neovim/0.11.2/share/nvim/runtime/ftplugin/lua.lua
Sourced 1 time
Total time:   0.008804
 Self time:   0.008720

count  total (s)   self (s)
                            -- use treesitter over syntax
                            vim.treesitter.start()
                            
                            vim.bo.includeexpr = [[v:lua.require'vim._ftplugin.lua'.includeexpr(v:fname)]]
                            vim.bo.omnifunc = 'v:lua.vim.lua_omnifunc'
                            vim.wo[0][0].foldexpr = 'v:lua.vim.treesitter.foldexpr()'
                            
                            vim.b.undo_ftplugin = (vim.b.undo_ftplugin or '')
                              .. '\n call v:lua.vim.treesitter.stop()'
                              .. '\n setl omnifunc< foldexpr< includeexpr<'

SCRIPT  /usr/local/Cellar/neovim/0.11.2/share/nvim/runtime/indent/lua.vim
Sourced 1 time
Total time:   0.000080
 Self time:   0.000080

count  total (s)   self (s)
                            " Vim indent file
                            " Language:	Lua script
                            " Maintainer:	Marcus Aurelius Farias <marcus.cf 'at' bol.com.br>
                            " First Author:	Max Ischenko <mfi 'at' ukr.net>
                            " Last Change:	2017 Jun 13
                            "		2022 Sep 07: b:undo_indent added by Doug Kearns
                            "		2024 Jul 27: by Vim project: match '(', ')' in function GetLuaIndentIntern()
                            
                            " Only load this indent file when no other was loaded.
    1              0.000007 if exists("b:did_indent")
                              finish
    1              0.000001 endif
    1              0.000003 let b:did_indent = 1
                            
    1              0.000007 setlocal indentexpr=GetLuaIndent()
                            
                            " To make Vim call GetLuaIndent() when it finds '\s*end' or '\s*until'
                            " on the current line ('else' is default and includes 'elseif').
    1              0.000004 setlocal indentkeys+=0=end,0=until
                            
    1              0.000002 setlocal autoindent
                            
    1              0.000002 let b:undo_indent = "setlocal autoindent< indentexpr< indentkeys<"
                            
                            " Only define the function once.
    1              0.000003 if exists("*GetLuaIndent")
                              finish
    1              0.000001 endif
                            
    1              0.000002 function! GetLuaIndent()
                                let ignorecase_save = &ignorecase
                              try
                                let &ignorecase = 0
                                return GetLuaIndentIntern()
                              finally
                                let &ignorecase = ignorecase_save
                              endtry
                            endfunction
                            
    1              0.000001 function! GetLuaIndentIntern()
                              " Find a non-blank line above the current line.
                              let prevlnum = prevnonblank(v:lnum - 1)
                            
                              " Hit the start of the file, use zero indent.
                              if prevlnum == 0
                                return 0
                              endif
                            
                              " Add a 'shiftwidth' after lines that start a block:
                              " 'function', 'if', 'for', 'while', 'repeat', 'else', 'elseif', '{', '('
                              let ind = indent(prevlnum)
                              let prevline = getline(prevlnum)
                              let midx = match(prevline, '^\s*\%(if\>\|for\>\|while\>\|repeat\>\|else\>\|elseif\>\|do\>\|then\>\)')
                              if midx == -1
                                let midx = match(prevline, '\%({\|(\)\s*\%(--\%([^[].*\)\?\)\?$')
                                if midx == -1
                                  let midx = match(prevline, '\<function\>\s*\%(\k\|[.:]\)\{-}\s*(')
                                endif
                              endif
                            
                              if midx != -1
                                " Add 'shiftwidth' if what we found previously is not in a comment and
                                " an "end" or "until" is not present on the same line.
                                if synIDattr(synID(prevlnum, midx + 1, 1), "name") != "luaComment" && prevline !~ '\<end\>\|\<until\>'
                                  let ind = ind + shiftwidth()
                                endif
                              endif
                            
                              " Subtract a 'shiftwidth' on end, else, elseif, until, '}' and ')'
                              " This is the part that requires 'indentkeys'.
                              let midx = match(getline(v:lnum), '^\s*\%(end\>\|else\>\|elseif\>\|until\>\|}\|)\)')
                              if midx != -1 && synIDattr(synID(v:lnum, midx + 1, 1), "name") != "luaComment"
                                let ind = ind - shiftwidth()
                              endif
                            
                              return ind
                            endfunction

SCRIPT  /usr/local/Cellar/neovim/0.11.2/share/nvim/runtime/ftplugin/vim.vim
Sourced 1 time
Total time:   0.000380
 Self time:   0.000380

count  total (s)   self (s)
                            " Vim filetype plugin
                            " Language:          Vim
                            " Maintainer:        Doug Kearns <dougkearns@gmail.com>
                            " Last Change:       2025 Mar 05
                            " Former Maintainer: Bram Moolenaar <Bram@vim.org>
                            " Contributors:      Riley Bruins <ribru17@gmail.com> ('commentstring'),
                            "                    @Konfekt
                            "                    @tpope (s:Help())
                            
                            " Only do this when not done yet for this buffer
    1              0.000048 if exists("b:did_ftplugin")
                              finish
    1              0.000001 endif
                            
                            " Don't load another plugin for this buffer
    1              0.000003 let b:did_ftplugin = 1
                            
    1              0.000003 let s:cpo_save = &cpo
    1              0.000007 set cpo&vim
                            
    1              0.000003 if !exists('*VimFtpluginUndo')
    1              0.000002   func VimFtpluginUndo()
                                setl fo< isk< com< tw< commentstring< keywordprg<
                                sil! delc -buffer VimKeywordPrg
                                if exists('b:did_add_maps')
                                  silent! nunmap <buffer> [[
                                  silent! xunmap <buffer> [[
                                  silent! nunmap <buffer> ]]
                                  silent! xunmap <buffer> ]]
                                  silent! nunmap <buffer> []
                                  silent! xunmap <buffer> []
                                  silent! nunmap <buffer> ][
                                  silent! xunmap <buffer> ][
                                  silent! nunmap <buffer> ]"
                                  silent! xunmap <buffer> ]"
                                  silent! nunmap <buffer> ["
                                  silent! xunmap <buffer> ["
                                 endif
                                unlet! b:match_ignorecase b:match_words b:match_skip b:did_add_maps
                              endfunc
    1              0.000001 endif
                            
    1              0.000001 let b:undo_ftplugin = "call VimFtpluginUndo()"
                            
                            " Set 'formatoptions' to break comment lines but not other lines,
                            " and insert the comment leader when hitting <CR> or using "o".
    1              0.000005 setlocal fo-=t fo+=croql
                            
                            " To allow tag lookup via CTRL-] for autoload functions, '#' must be a
                            " keyword character.  E.g., for netrw#Nread().
    1              0.000013 setlocal isk+=#
                            
                            " Use :help to lookup the keyword under the cursor with K.
                            " Distinguish between commands, options and functions.
    1              0.000006 if !exists("*" .. expand("<SID>") .. "Help")
    1              0.000001   function s:Help(topic) abort
                                let topic = a:topic
                            
                                if get(g:, 'syntax_on', 0)
                                  let syn = synIDattr(synID(line('.'), col('.'), 1), 'name')
                                  if syn ==# 'vimFuncName'
                                    return topic.'()'
                                  elseif syn ==# 'vimOption'
                                    return "'".topic."'"
                                  elseif syn ==# 'vimUserAttrbKey'
                                    return ':command-'.topic
                                  elseif syn =~# 'vimCommand'
                                    return ':'.topic
                                  endif
                                endif
                            
                                let col = col('.') - 1
                                while col && getline('.')[col] =~# '\k'
                                  let col -= 1
                                endwhile
                                let pre = col == 0 ? '' : getline('.')[0 : col]
                            
                                let col = col('.') - 1
                                while col && getline('.')[col] =~# '\k'
                                  let col += 1
                                endwhile
                                let post = getline('.')[col : -1]
                            
                                if pre =~# '^\s*:\=$'
                                  return ':'.topic
                                elseif pre =~# '\<v:$'
                                  return 'v:'.topic
                                elseif pre =~# '<$'
                                  return '<'.topic.'>'
                                elseif pre =~# '\\$'
                                  return '/\'.topic
                                elseif topic ==# 'v' && post =~# ':\w\+'
                                  return 'v'.matchstr(post, ':\w\+')
                                else
                                  return topic
                                endif
                              endfunction
    1              0.000001 endif
    1              0.000033 command! -buffer -nargs=1 VimKeywordPrg :exe 'help' s:Help(<q-args>)
    1              0.000004 setlocal keywordprg=:VimKeywordPrg
                            
                            " Comments starts with # in Vim9 script.  We have to guess which one to use.
    1              0.000016 if "\n" .. getline(1, 32)->join("\n") =~# '\n\s*vim9\%[script]\>'
                              setlocal commentstring=#\ %s
    1              0.000001 else
    1              0.000003   setlocal commentstring=\"%s
    1              0.000000 endif
                            
                            " Set 'comments' to format dashed lists in comments, both in Vim9 and legacy
                            " script.
    1              0.000005 setlocal com=sO:#\ -,mO:#\ \ ,eO:##,:#\\\ ,:#,sO:\"\ -,mO:\"\ \ ,eO:\"\",:\"\\\ ,:\"
                            
                            
                            " Format comments to be up to 78 characters long
    1              0.000001 if &tw == 0
                              setlocal tw=78
    1              0.000000 endif
                            
    1              0.000003 if !exists("no_plugin_maps") && !exists("no_vim_maps")
    1              0.000002   let b:did_add_maps = 1
                            
                              " Move around functions.
    1              0.000007   nnoremap <silent><buffer> [[ m':call search('^\s*\(fu\%[nction]\\|def\)\>', "bW")<CR>
    1              0.000024   xnoremap <silent><buffer> [[ m':<C-U>exe "normal! gv"<Bar>call search('^\s*\(fu\%[nction]\\|def\)\>', "bW")<CR>
    1              0.000003   nnoremap <silent><buffer> ]] m':call search('^\s*\(fu\%[nction]\\|def\)\>', "W")<CR>
    1              0.000004   xnoremap <silent><buffer> ]] m':<C-U>exe "normal! gv"<Bar>call search('^\s*\(fu\%[nction]\\|def\)\>', "W")<CR>
    1              0.000003   nnoremap <silent><buffer> [] m':call search('^\s*end\(f\%[unction]\\|def\)\>', "bW")<CR>
    1              0.000008   xnoremap <silent><buffer> [] m':<C-U>exe "normal! gv"<Bar>call search('^\s*end\(f\%[unction]\\|def\)\>', "bW")<CR>
    1              0.000003   nnoremap <silent><buffer> ][ m':call search('^\s*end\(f\%[unction]\\|def\)\>', "W")<CR>
    1              0.000003   xnoremap <silent><buffer> ][ m':<C-U>exe "normal! gv"<Bar>call search('^\s*end\(f\%[unction]\\|def\)\>', "W")<CR>
                            
                              " Move around comments
    1              0.000003   nnoremap <silent><buffer> ]" :call search('\%(^\s*".*\n\)\@<!\%(^\s*"\)', "W")<CR>
    1              0.000003   xnoremap <silent><buffer> ]" :<C-U>exe "normal! gv"<Bar>call search('\%(^\s*".*\n\)\@<!\%(^\s*"\)', "W")<CR>
    1              0.000003   nnoremap <silent><buffer> [" :call search('\%(^\s*".*\n\)\%(^\s*"\)\@!', "bW")<CR>
    1              0.000003   xnoremap <silent><buffer> [" :<C-U>exe "normal! gv"<Bar>call search('\%(^\s*".*\n\)\%(^\s*"\)\@!', "bW")<CR>
    1              0.000000 endif
                            
                            " Let the matchit plugin know what items can be matched.
    1              0.000026 if exists("loaded_matchit")
    1              0.000002   let b:match_ignorecase = 0
                              " "func" can also be used as a type:
                              "   var Ref: func
                              " or to list functions:
                              "   func name
                              " require a parenthesis following, then there can be an "endfunc".
    1              0.000015   let b:match_words =
                              \ '\<\%(fu\%[nction]\|def\)!\=\s\+\S\+\s*(:\%(\%(^\||\)\s*\)\@<=\<retu\%[rn]\>:\%(\%(^\||\)\s*\)\@<=\<\%(endf\%[unction]\|enddef\)\>,' ..
                              \ '\<\%(wh\%[ile]\|for\)\>:\%(\%(^\||\)\s*\)\@<=\<brea\%[k]\>:\%(\%(^\||\)\s*\)\@<=\<con\%[tinue]\>:\%(\%(^\||\)\s*\)\@<=\<end\%(w\%[hile]\|fo\%[r]\)\>,' ..
                              \ '\<if\>:\%(\%(^\||\)\s*\)\@<=\<el\%[seif]\>:\%(\%(^\||\)\s*\)\@<=\<en\%[dif]\>,' ..
                              \ '{:},' ..
                              \ '\<try\>:\%(\%(^\||\)\s*\)\@<=\<cat\%[ch]\>:\%(\%(^\||\)\s*\)\@<=\<fina\%[lly]\>:\%(\%(^\||\)\s*\)\@<=\<endt\%[ry]\>,' ..
                              \ '\<aug\%[roup]\s\+\%(END\>\)\@!\S:\<aug\%[roup]\s\+END\>,' ..
                              \ '\<class\>:\<endclass\>,' ..
                              \ '\<interface\>:\<endinterface\>,' ..
                              \ '\<enum\>:\<endenum\>'
                            
                              " Ignore syntax region commands and settings, any 'en*' would clobber
                              " if-endif.
                              " - set spl=de,en
                              " - au! FileType javascript syntax region foldBraces start=/{/ end=/}/ …
                              " Also ignore here-doc and dictionary keys (vimVar).
    1              0.000003   let b:match_skip = 'synIDattr(synID(line("."), col("."), 1), "name")
                                                \ =~? "comment\\|string\\|vimSynReg\\|vimSet\\|vimLetHereDoc\\|vimVar"'
    1              0.000003 endif
                            
    1              0.000004 let &cpo = s:cpo_save
    1              0.000002 unlet s:cpo_save
                            
                            " removed this, because 'cpoptions' is a global option.
                            " setlocal cpo+=M		" makes \%( match \)
                            "
                            " vim: sw=2 et

SCRIPT  /usr/local/Cellar/neovim/0.11.2/share/nvim/runtime/indent/vim.vim
Sourced 1 time
Total time:   0.000161
 Self time:   0.000161

count  total (s)   self (s)
                            " Vim indent file
                            " Language:	Vim script
                            " Maintainer:	The Vim Project <https://github.com/vim/vim>
                            " Last Change:	2023 Aug 10
                            " Former Maintainer:	Bram Moolenaar <Bram@vim.org>
                            
                            " Only load this indent file when no other was loaded.
    1              0.000005 if exists("b:did_indent")
                              finish
    1              0.000001 endif
    1              0.000002 let b:did_indent = 1
                            
    1              0.000006 setlocal indentexpr=GetVimIndent()
    1              0.000003 setlocal indentkeys+==endif,=enddef,=endfu,=endfor,=endwh,=endtry,=},=else,=cat,=finall,=END,0\\,0=\"\\\ 
    1              0.000002 setlocal indentkeys-=0#
    1              0.000002 setlocal indentkeys-=:
                            
    1              0.000002 let b:undo_indent = "setl indentkeys< indentexpr<"
                            
                            " Only define the function once.
    1              0.000002 if exists("*GetVimIndent")
                              finish
    1              0.000000 endif
    1              0.000002 let s:keepcpo= &cpo
    1              0.000003 set cpo&vim
                            
    1              0.000001 function GetVimIndent()
                              let ignorecase_save = &ignorecase
                              try
                                let &ignorecase = 0
                                return GetVimIndentIntern()
                              finally
                                let &ignorecase = ignorecase_save
                              endtry
                            endfunc
                            
                            " Legacy script line continuation and Vim9 script operators that must mean an
                            " expression that continues from the previous line.
    1              0.000001 let s:lineContPat = '^\s*\(\\\|"\\ \|->\)'
                            
    1              0.000001 function GetVimIndentIntern()
                              " If the current line has line continuation and the previous one too, use
                              " the same indent.  This does not skip empty lines.
                              let cur_text = getline(v:lnum)
                              let cur_has_linecont = cur_text =~ s:lineContPat
                              if cur_has_linecont && v:lnum > 1 && getline(v:lnum - 1) =~ s:lineContPat
                                return indent(v:lnum - 1)
                              endif
                            
                              " Find a non-blank line above the current line.
                              let lnum = prevnonblank(v:lnum - 1)
                            
                              " The previous line, ignoring line continuation
                              let prev_text_end = lnum > 0 ? getline(lnum) : ''
                            
                              " If the current line doesn't start with '\' or '"\ ' and below a line that
                              " starts with '\' or '"\ ', use the indent of the line above it.
                              if !cur_has_linecont
                                while lnum > 0 && getline(lnum) =~ s:lineContPat
                                  let lnum = lnum - 1
                                endwhile
                              endif
                            
                              " At the start of the file use zero indent.
                              if lnum == 0
                                return 0
                              endif
                            
                              " the start of the previous line, skipping over line continuation
                              let prev_text = getline(lnum)
                              let found_cont = 0
                            
                              " Add a 'shiftwidth' after :if, :while, :try, :catch, :finally, :function
                              " and :else.  Add it three times for a line that starts with '\' or '"\ '
                              " after a line that doesn't (or g:vim_indent_cont if it exists).
                              let ind = indent(lnum)
                            
                              " In heredoc indenting works completely differently.
                              if has('syntax_items') 
                                let syn_here = synIDattr(synID(v:lnum, 1, 1), "name")
                                if syn_here =~ 'vimLetHereDocStop'
                                  " End of heredoc: use indent of matching start line
                                  let lnum = v:lnum - 1
                                  while lnum > 0
                            	let attr = synIDattr(synID(lnum, 1, 1), "name")
                            	if attr != '' && attr !~ 'vimLetHereDoc'
                            	  return indent(lnum)
                            	endif
                            	let lnum -= 1
                                  endwhile
                                  return 0
                                endif
                                if syn_here =~ 'vimLetHereDoc'
                                  if synIDattr(synID(lnum, 1, 1), "name") !~ 'vimLetHereDoc'
                            	" First line in heredoc: increase indent
                            	return ind + shiftwidth()
                                  endif
                                  " Heredoc continues: no change in indent
                                  return ind
                                endif
                              endif
                            
                              if cur_text =~ s:lineContPat && v:lnum > 1 && prev_text !~ s:lineContPat
                                let found_cont = 1
                                if exists("g:vim_indent_cont")
                                  let ind = ind + g:vim_indent_cont
                                else
                                  let ind = ind + shiftwidth() * 3
                                endif
                              elseif prev_text =~ '^\s*aug\%[roup]\s\+' && prev_text !~ '^\s*aug\%[roup]\s\+[eE][nN][dD]\>'
                                let ind = ind + shiftwidth()
                              else
                                " A line starting with :au does not increment/decrement indent.
                                " A { may start a block or a dict.  Assume that when a } follows it's a
                                " terminated dict.
                                " ":function" starts a block but "function(" doesn't.
                                if prev_text !~ '^\s*au\%[tocmd]' && prev_text !~ '^\s*{.*}'
                                  let i = match(prev_text, '\(^\||\)\s*\(export\s\+\)\?\({\|\(if\|wh\%[ile]\|for\|try\|cat\%[ch]\|fina\|finall\%[y]\|def\|el\%[seif]\)\>\|fu\%[nction][! ]\)')
                                  if i >= 0
                                    let ind += shiftwidth()
                            	if strpart(prev_text, i, 1) == '|' && has('syntax_items')
                            	      \ && synIDattr(synID(lnum, i, 1), "name") =~ '\(Comment\|String\|PatSep\)$'
                            	  let ind -= shiftwidth()
                            	endif
                                  endif
                                endif
                              endif
                            
                              " If the previous line contains an "end" after a pipe, but not in an ":au"
                              " command.  And not when there is a backslash before the pipe.
                              " And when syntax HL is enabled avoid a match inside a string.
                              let i = match(prev_text, '[^\\]|\s*\(ene\@!\)')
                              if i > 0 && prev_text !~ '^\s*au\%[tocmd]'
                                if !has('syntax_items') || synIDattr(synID(lnum, i + 2, 1), "name") !~ '\(Comment\|String\)$'
                                  let ind = ind - shiftwidth()
                                endif
                              endif
                            
                              " For a line starting with "}" find the matching "{".  Align with that line,
                              " it is either the matching block start or dictionary start.
                              " Use the mapped "%" from matchit to find the match, otherwise we may match
                              " a { inside a comment or string.
                              if cur_text =~ '^\s*}'
                                if maparg('%') != ''
                                  exe v:lnum
                                  silent! normal %
                                  if line('.') < v:lnum
                            	let ind = indent('.')
                                  endif
                                else
                                  " todo: use searchpair() to find a match
                                endif
                              endif
                            
                              " Look back for a line to align with
                              while lnum > 1
                                " Below a line starting with "}" find the matching "{".
                                if prev_text =~ '^\s*}'
                                  if maparg('%') != ''
                            	exe lnum
                            	silent! normal %
                            	if line('.') < lnum
                            	  let lnum = line('.')
                            	  let ind = indent(lnum)
                            	  let prev_text = getline(lnum)
                            	else
                            	  break
                            	endif
                                  else
                            	" todo: use searchpair() to find a match
                            	break
                                  endif
                                elseif prev_text =~ s:lineContPat
                                  " looks like a continuation like, go back one line
                                  let lnum = lnum - 1
                                  let ind = indent(lnum)
                                  let prev_text = getline(lnum)
                                else
                                  break
                                endif
                              endwhile
                            
                              " Below a line starting with "]" we must be below the end of a list.
                              " Include a "}" and "},} in case a dictionary ends too.
                              if prev_text_end =~ '^\s*\(},\=\s*\)\=]'
                                let ind = ind - shiftwidth()
                              endif
                            
                              let ends_in_comment = has('syntax_items')
                            	\ && synIDattr(synID(lnum, len(getline(lnum)), 1), "name") =~ '\(Comment\|String\)$'
                            
                              " A line ending in "{" or "[" is most likely the start of a dict/list literal,
                              " indent the next line more.  Not for a continuation line or {{{.
                              if !ends_in_comment && prev_text_end =~ '\s[{[]\s*$' && !found_cont
                                let ind = ind + shiftwidth()
                              endif
                            
                              " Subtract a 'shiftwidth' on a :endif, :endwhile, :endfor, :catch, :finally,
                              " :endtry, :endfun, :enddef, :else and :augroup END.
                              " Although ":en" would be enough only match short command names as in
                              " 'indentkeys'.
                              if cur_text =~ '^\s*\(endif\|endwh\|endfor\|endtry\|endfu\|enddef\|cat\|finall\|else\|aug\%[roup]\s\+[eE][nN][dD]\)'
                                let ind = ind - shiftwidth()
                                if ind < 0
                                  let ind = 0
                                endif
                              endif
                            
                              return ind
                            endfunction
                            
    1              0.000004 let &cpo = s:keepcpo
    1              0.000001 unlet s:keepcpo
                            
                            " vim:sw=2

SCRIPT  /usr/local/Cellar/neovim/0.11.2/share/nvim/runtime/syntax/vim.vim
Sourced 1 time
Total time:   0.005558
 Self time:   0.004877

count  total (s)   self (s)
                            " Vim syntax file
                            
                            " #############################################################################
                            " #############################################################################
                            " Note: Be careful when merging the upstream version of this file.
                            "       Much of this is generated by scripts/genvimvim.lua
                            "       (installs to $VIMRUNTIME/syntax/vim/generated.vim)
                            " #############################################################################
                            " #############################################################################
                            
                            " Quit when a syntax file was already loaded {{{2
    1              0.000007 if exists("b:current_syntax")
                              finish
    1              0.000001 endif
    1              0.000003 let s:keepcpo = &cpo
    1              0.000005 set cpo&vim
                            
    1              0.000031 let s:vim9script = "\n" .. getline(1, 32)->join("\n") =~# '\n\s*vim9\%[script]\>'
                            
                            " vimTodo: contains common special-notices for comments {{{2
                            " Use the vimCommentGroup cluster to add your own.
    1              0.000013 syn keyword vimTodo contained	COMBAK	FIXME	TODO	XXX
    1              0.000004 syn cluster vimCommentGroup	contains=vimTodo,@Spell
                            
                            " Special and plugin vim commands {{{2
    1              0.000004 syn match   vimCommand contained	"\<z[-+^.=]\=\>"
    1              0.000004 syn keyword vimOnlyCommand contained	fix[del] op[en] sh[ell] P[rint]
    1              0.000006 syn keyword vimStdPlugin contained Arguments Asm Break Cfilter Clear Continue DiffOrig Evaluate Finish Gdb Lfilter Man Over Program Run S Source Step Stop Termdebug TermdebugCommand TOhtml Until Winbar XMLent XMLns
                            
                            " Vim-specific options {{{2
    1              0.000007 syn keyword vimOnlyOption contained	biosk bioskey cp compatible consk conskey cm cryptmethod edcompatible guipty key macatsui mzq mzquantum osfiletype oft renderoptions rop st shelltype sn shortname tenc termencoding ta textauto tx textmode tf ttyfast ttym ttymouse tbi ttybuiltin wiv weirdinvert
                            
                            " Turn-off setting variants
    1              0.000003 syn keyword vimOnlyOption contained	nobiosk nobioskey noconsk noconskey nocp nocompatible noguipty nomacatsui nosn noshortname nota notextauto notx notextmode notf nottyfast notbi nottybuiltin nowiv noweirdinvert
                            
                            " Invertible setting variants
    1              0.000003 syn keyword vimOnlyOption contained	invbiosk invbioskey invconsk invconskey invcp invcompatible invguipty invmacatsui invsn invshortname invta invtextauto invtx invtextmode invtf invttyfast invtbi invttybuiltin invwiv invweirdinvert
                            " termcap codes (which can also be set) {{{2
                            " GEN_SYN_VIM: vimOption term output code, START_STR='syn keyword vimOption contained', END_STR='skipwhite nextgroup=vimSetEqual,vimSetMod'
    1              0.000016 syn keyword vimOption contained t_AB t_AF t_AU t_AL t_al t_bc t_BE t_BD t_cd t_ce t_Ce t_CF t_cl t_cm t_Co t_CS t_Cs t_cs t_CV t_da t_db t_DL t_dl t_ds t_Ds t_EC t_EI t_fs t_fd t_fe t_GP t_IE t_IS t_ke t_ks t_le t_mb t_md t_me t_mr t_ms t_nd t_op t_RF t_RB t_RC t_RI t_Ri t_RK t_RS t_RT t_RV t_Sb t_SC t_se t_Sf t_SH t_SI t_Si t_so t_SR t_sr t_ST t_Te t_te t_TE t_ti t_TI t_Ts t_ts t_u7 t_ue t_us t_Us t_ut t_vb t_ve t_vi t_VS t_vs t_WP t_WS t_XM t_xn t_xs t_ZH t_ZR t_8f t_8b t_8u t_xo skipwhite nextgroup=vimSetEqual,vimSetMod
                            " term key codes
    1              0.000005 syn keyword vimOption contained	t_F1 t_F2 t_F3 t_F4 t_F5 t_F6 t_F7 t_F8 t_F9 t_k1 t_K1 t_k2 t_k3 t_K3 t_k4 t_K4 t_k5 t_K5 t_k6 t_K6 t_k7 t_K7 t_k8 t_K8 t_k9 t_K9 t_KA t_kb t_kB t_KB t_KC t_kd t_kD t_KD t_KE t_KF t_KG t_kh t_KH t_kI t_KI t_KJ t_KK t_kl t_KL t_kN t_kP t_kr t_ku
    1              0.000002 syn match   vimTermOption contained	"t_%1"
    1              0.000001 syn match   vimTermOption contained	"t_#2"
    1              0.000001 syn match   vimTermOption contained	"t_#4"
    1              0.000001 syn match   vimTermOption contained	"t_@7"
    1              0.000001 syn match   vimTermOption contained	"t_*7"
    1              0.000001 syn match   vimTermOption contained	"t_&8"
    1              0.000001 syn match   vimTermOption contained	"t_%i"
    1              0.000001 syn match   vimTermOption contained	"t_k;"
                            
                            " unsupported settings: these are supported by vi but don't do anything in vim {{{2
                            " GEN_SYN_VIM: Missing vimOption, START_STR='syn keyword vimErrSetting contained', END_STR=''
    1              0.000013 syn keyword vimErrSetting contained akm altkeymap anti antialias ap autoprint bf beautify biosk bioskey consk conskey fk fkmap fl flash gr graphic ht hardtabs macatsui mesg novice open opt optimize oft osfiletype redraw slow slowopen sourceany w1200 w300 w9600
    1              0.000005 syn keyword vimErrSetting contained noakm noaltkeymap noanti noantialias noap noautoprint nobf nobeautify nobiosk nobioskey noconsk noconskey nofk nofkmap nofl noflash nogr nographic nomacatsui nomesg nonovice noopen noopt nooptimize noredraw noslow noslowopen nosourceany
    1              0.000004 syn keyword vimErrSetting contained invakm invaltkeymap invanti invantialias invap invautoprint invbf invbeautify invbiosk invbioskey invconsk invconskey invfk invfkmap invfl invflash invgr invgraphic invmacatsui invmesg invnovice invopen invopt invoptimize invredraw invslow invslowopen invsourceany
                            "}}}2
    1              0.000001 syn case ignore
                            " Highlight commonly used Groupnames {{{2
    1              0.000009 syn keyword vimGroup contained	Comment Constant String Character Number Boolean Float Identifier Function Statement Conditional Repeat Label Operator Keyword Exception PreProc Include Define Macro PreCondit Type StorageClass Structure Typedef Special SpecialChar Tag Delimiter SpecialComment Debug Underlined Ignore Error Todo
                            
                            " Default highlighting groups {{{2
    1              0.000022 syn keyword vimHLGroup contained ErrorMsg IncSearch ModeMsg NonText StatusLine StatusLineNC EndOfBuffer VertSplit DiffText PmenuSbar TabLineSel TabLineFill Cursor lCursor QuickFixLine CursorLineSign CursorLineFold CurSearch PmenuKind PmenuKindSel PmenuMatch PmenuMatchSel PmenuExtra PmenuExtraSel ComplMatchIns Normal Directory LineNr CursorLineNr MoreMsg Question Search SpellBad SpellCap SpellRare SpellLocal PmenuThumb Pmenu PmenuSel SpecialKey Title WarningMsg WildMenu Folded FoldColumn SignColumn Visual DiffAdd DiffChange DiffDelete TabLine CursorColumn CursorLine ColorColumn MatchParen StatusLineTerm StatusLineTermNC CursorIM LineNrAbove LineNrBelow
    1              0.000002 syn match vimHLGroup contained "\<Conceal\>"
    1              0.000002 syn keyword vimOnlyHLGroup contained	Menu Scrollbar ToolbarButton ToolbarLine Tooltip VisualNOS
    1              0.000004 syn keyword nvimHLGroup contained	FloatBorder FloatFooter FloatTitle MsgSeparator NormalFloat NormalNC Substitute TermCursor VisualNC Whitespace WinBar WinBarNC WinSeparator
                            "}}}2
    1              0.000001 syn case match
                            
                            " Special Vim Highlighting (not automatic) {{{1
                            
                            " Set up commands for this syntax highlighting file {{{2
                            
    1              0.000005 com! -nargs=* Vim9 execute <q-args> s:vim9script ? "" : "contained"
    1              0.000003 com! -nargs=* VimL execute <q-args> s:vim9script ? "contained" : ""
                            
    1              0.000003 if exists("g:vimsyn_folding") && g:vimsyn_folding =~# '[acefhiHlmpPrt]'
                             if g:vimsyn_folding =~# 'a'
                              com! -nargs=* VimFolda <args> fold
                             else
                              com! -nargs=* VimFolda <args>
                             endif
                             if g:vimsyn_folding =~# 'c'
                              com! -nargs=* VimFoldc <args> fold
                             else
                              com! -nargs=* VimFoldc <args>
                             endif
                             if g:vimsyn_folding =~# 'e'
                              com! -nargs=* VimFolde <args> fold
                             else
                              com! -nargs=* VimFolde <args>
                             endif
                             if g:vimsyn_folding =~# 'f'
                              com! -nargs=* VimFoldf <args> fold
                             else
                              com! -nargs=* VimFoldf <args>
                             endif
                             if g:vimsyn_folding =~# 'h'
                              com! -nargs=* VimFoldh <args> fold
                             else
                              com! -nargs=* VimFoldh <args>
                             endif
                             if g:vimsyn_folding =~# 'H'
                              com! -nargs=* VimFoldH <args> fold
                             else
                              com! -nargs=* VimFoldH <args>
                             endif
                             if g:vimsyn_folding =~# 'i'
                              com! -nargs=* VimFoldi <args> fold
                             else
                              com! -nargs=* VimFoldi <args>
                             endif
                             if g:vimsyn_folding =~# 'l'
                              com! -nargs=* VimFoldl <args> fold
                             else
                              com! -nargs=* VimFoldl <args>
                             endif
                             if g:vimsyn_folding =~# 'm'
                              com! -nargs=* VimFoldm <args> fold
                             else
                              com! -nargs=* VimFoldm <args>
                             endif
                             if g:vimsyn_folding =~# 'p'
                              com! -nargs=* VimFoldp <args> fold
                             else
                              com! -nargs=* VimFoldp <args>
                             endif
                             if g:vimsyn_folding =~# 'P'
                              com! -nargs=* VimFoldP <args> fold
                             else
                              com! -nargs=* VimFoldP <args>
                             endif
                             if g:vimsyn_folding =~# 'r'
                              com! -nargs=* VimFoldr <args> fold
                             else
                              com! -nargs=* VimFoldr <args>
                             endif
                             if g:vimsyn_folding =~# 't'
                              com! -nargs=* VimFoldt <args> fold
                             else
                              com! -nargs=* VimFoldt <args>
                             endif
    1              0.000000 else
    1              0.000002  com! -nargs=*	VimFolda	<args>
    1              0.000001  com! -nargs=*	VimFoldc	<args>
    1              0.000001  com! -nargs=*	VimFolde	<args>
    1              0.000001  com! -nargs=*	VimFoldf	<args>
    1              0.000001  com! -nargs=*	VimFoldi	<args>
    1              0.000002  com! -nargs=*	VimFoldh	<args>
    1              0.000001  com! -nargs=*	VimFoldH	<args>
    1              0.000001  com! -nargs=*	VimFoldl	<args>
    1              0.000001  com! -nargs=*	VimFoldm	<args>
    1              0.000001  com! -nargs=*	VimFoldp	<args>
    1              0.000001  com! -nargs=*	VimFoldP	<args>
    1              0.000001  com! -nargs=*	VimFoldr	<args>
    1              0.000001  com! -nargs=*	VimFoldt	<args>
    1              0.000000 endif
                            
                            " Deprecated variable options {{{2
    1              0.000004 if exists("g:vim_minlines")
                             let g:vimsyn_minlines= g:vim_minlines
    1              0.000000 endif
    1              0.000001 if exists("g:vim_maxlines")
                             let g:vimsyn_maxlines= g:vim_maxlines
    1              0.000000 endif
    1              0.000001 if exists("g:vimsyntax_noerror")
                             let g:vimsyn_noerror= g:vimsyntax_noerror
    1              0.000000 endif
                            
                            " Variable options {{{2
    1              0.000001 if exists("g:vim_maxlines")
                             let s:vimsyn_maxlines= g:vim_maxlines
    1              0.000000 else
    1              0.000001  let s:vimsyn_maxlines= 60
    1              0.000000 endif
                            
                            " Nulls {{{2
                            " =====
    1              0.000012 Vim9 syn keyword  vim9Null	null null_blob null_channel null_class null_dict null_function null_job null_list null_object null_partial null_string
                            
                            " Booleans {{{2
                            " ========
    1              0.000004 Vim9 syn keyword vim9Boolean	true false
                            
                            " Numbers {{{2
                            " =======
    1              0.000001 syn case ignore
    1              0.000005 syn match	vimNumber	'\<\d\+'			skipwhite nextgroup=vimGlobal,vimSubst1,@vimComment,vimSubscript
    1              0.000005 syn match	vimNumber	'\<\d\+\.\d\+\%(e[+-]\=\d\+\)\='		skipwhite nextgroup=vimGlobal,vimSubst1,@vimComment
    1              0.000003 syn match	vimNumber	'\<0b[01]\+'			skipwhite nextgroup=vimGlobal,vimSubst1,@vimComment,vimSubscript
    1              0.000003 syn match	vimNumber	'\<0o\=\o\+'			skipwhite nextgroup=vimGlobal,vimSubst1,@vimComment,vimSubscript
    1              0.000003 syn match	vimNumber	'\<0x\x\+'			skipwhite nextgroup=vimGlobal,vimSubst1,@vimComment,vimSubscript
    1              0.000002 syn match	vimNumber	'\<0z\>'			skipwhite nextgroup=vimGlobal,vimSubst1,@vimComment
    1              0.000005 syn match	vimNumber	'\<0z\%(\x\x\)\+\%(\.\%(\x\x\)\+\)*'	skipwhite nextgroup=vimGlobal,vimSubst1,@vimComment,vimSubscript
    1              0.000001 syn case match
                            
                            " All vimCommands are contained by vimIsCommand. {{{2
    1              0.000023 syn cluster vimCmdList	contains=vimAbb,vimAddress,vimAutoCmd,vimAugroup,vimBehave,vimCall,vimCatch,vimConst,vimDebuggreedy,vimDef,vimDefFold,vimDelcommand,@vimEcho,vimEnddef,vimEndfunction,vimExecute,vimIsCommand,vimExtCmd,vimFor,vimFunction,vimFuncFold,vimGlobal,vimHighlight,vimLet,vimLoadkeymap,vimLockvar,vimMap,vimMark,vimMatch,vimNotFunc,vimNormal,vimSet,vimSleep,vimSyntax,vimThrow,vimUnlet,vimUnlockvar,vimUnmap,vimUserCmd,vimMenu,vimMenutranslate,@vim9CmdList,@vimExUserCmdList
    1              0.000006 syn cluster vim9CmdList	contains=vim9Abstract,vim9Class,vim9Const,vim9Enum,vim9Export,vim9Final,vim9For,vim9Interface,vim9Type,vim9Var
    1              0.000003 syn match vimCmdSep	"\\\@1<!|"	skipwhite nextgroup=@vimCmdList,vimSubst1,vimFunc
    1              0.000002 syn match vimCmdSep	":\+"	skipwhite nextgroup=@vimCmdList,vimSubst1
    1              0.000001 syn match vimCount	contained	"\d\+"
    1              0.000004 syn match vimIsCommand	"\<\%(\h\w*\|[23]mat\%[ch]\)\>"	 nextgroup=vimBang contains=vimCommand
    1              0.000001 syn match vimBang	      contained	"!"
                            
    1              0.000004 syn region vimSubscript contained	matchgroup=vimSubscriptBracket start="\[" end="]" nextgroup=vimSubscript contains=@vimExprList
                            
    1              0.000004 syn match vimVar	      contained	"\<\h[a-zA-Z0-9#_]*\>"	nextgroup=vimSubscript contains=vim9Super,vim9This
    1              0.000003 syn match vimVar		"\<[bwglstav]:\h[a-zA-Z0-9#_]*\>"	nextgroup=vimSubscript
    1              0.000003 syn match vimVar		"\<a:\%(000\|\d\+\)\>"	nextgroup=vimSubscript
    1              0.000003 syn match vimFBVar      contained   "\<[bwglsta]:\h[a-zA-Z0-9#_]*\>"	nextgroup=vimSubscript
                            
    1              0.000002 syn match vimVimVar	"\<v:\h\w*\>"		nextgroup=vimSubscript
    1              0.000003 syn match vimOptionVar      	"&\%([lg]:\)\=\a\+\>"	nextgroup=vimSubscript
    1              0.000006 syn match vimOptionVar	"&t_\S[a-zA-Z0-9]\>"	nextgroup=vimSubscript
    1              0.000002 syn match vimOptionVar        	"&t_k;"		nextgroup=vimSubscript
    1              0.000003 syn cluster vimSpecialVar	contains=vimEnvvar,vimLetRegister,vimOptionVar,vimVimVar
                            
    1              0.000008 Vim9 syn match vim9LhsVariable	"\s\=\h[a-zA-Z0-9#_]*\ze\s\+[-+/*%]\=="
    1              0.000006 Vim9 syn match vim9LhsVariable	"\s\=\h[a-zA-Z0-9#_]*\ze\s\+\.\.="
    1              0.000005 Vim9 syn match vim9LhsVariable	"\s\=\h[a-zA-Z0-9#_]*\ze\s\+=<<"
    1              0.000007 Vim9 syn match vim9LhsVariable	"\s\=\h[a-zA-Z0-9#_]*\ze\s*->"		contains=vim9Super,vim9This
    1              0.000006 Vim9 syn match vim9LhsVariable	"\s\=\h[a-zA-Z0-9#_]*\ze\["	nextgroup=vimSubscript
    1              0.000036 Vim9 syn match vim9LhsVariable	"\s\=\h[a-zA-Z0-9#_]*\ze\."	nextgroup=vimOper contains=vim9Super,vim9This
                            
    1              0.000008 Vim9 syn match vim9LhsVariableList	"\[\_[^]]\+]\ze\s\+[-+/*%]\=="	contains=vimVar,@vimSpecialVar
    1              0.000006 Vim9 syn match vim9LhsVariableList	"\[\_[^]]\+]\ze\s\+\.\.="	contains=vimVar,@vimSpecialVar
                            
    1              0.000023 Vim9 syn match vim9LhsRegister	"@["0-9\-a-zA-Z#=*+_/]\ze\s\+\%(\.\.\)\=="
                            
    1              0.000004 syn cluster vimExprList	contains=@vimSpecialVar,vimFunc,vimNumber,vimOper,vimOperParen,vimLambda,vimString,vimVar,@vim9ExprList
    1              0.000002 syn cluster vim9ExprList	contains=vim9Boolean,vim9LambdaParams,vim9Null
                            
                            " Insertions And Appends: insert append {{{2
                            "   (buftype != nofile test avoids having append, change, insert show up in the command window)
                            " =======================
    1              0.000002 if &buftype != 'nofile'
                             syn region vimInsert	matchgroup=vimCommand start="^[: \t]*\(\d\+\(,\d\+\)\=\)\=a\%[ppend]$"		matchgroup=vimCommand end="^\.$" extend
                             syn region vimInsert	matchgroup=vimCommand start="^[: \t]*\(\d\+\(,\d\+\)\=\)\=c\%[hange]$"		matchgroup=vimCommand end="^\.$" extend
                             syn region vimInsert	matchgroup=vimCommand start="^[: \t]*\(\d\+\(,\d\+\)\=\)\=i\%[nsert]$"		matchgroup=vimCommand end="^\.$" extend
    1              0.000001 endif
                            
                            " Behave! {{{2
                            " =======
    1              0.000004 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_nobehaveerror")
    1              0.000002  syn match   vimBehaveError contained	"[^ ]\+"
    1              0.000000 endif
    1              0.000004 syn match   vimBehave	"\<be\%[have]\>"	nextgroup=vimBehaveBang,vimBehaveModel,vimBehaveError skipwhite
    1              0.000002 syn match   vimBehaveBang	contained	"\a\@1<=!" nextgroup=vimBehaveModel skipwhite
    1              0.000001 syn keyword vimBehaveModel	contained	mswin	xterm
                            
                            " Call {{{2
                            " ====
    1              0.000002 syn match vimCall	"\<call\=\>"	skipwhite nextgroup=vimFunc
                            
                            " Debuggreedy {{{2
                            " ===========
                            " TODO: special-cased until generalised range/count support is implemented
    1              0.000004 syn match	vimDebuggreedy	"\<0\=debugg\%[reedy]\>" contains=vimCount
                            
                            " Exception Handling {{{2
    1              0.000003 syn keyword	vimThrow	th[row]	skipwhite nextgroup=@vimExprList
    1              0.000002 syn keyword	vimCatch	cat[ch]	skipwhite nextgroup=vimCatchPattern
    1              0.000007 syn region	vimCatchPattern	contained	matchgroup=Delimiter start="\z([!#$%&'()*+,-./:;<=>?@[\]^_`{}~]\)" skip="\\\\\|\\\z1" end="\z1" contains=@vimSubstList oneline
                            
                            " Export {{{2
                            " ======
    1              0.000001 if s:vim9script
                              syn keyword	vim9Export	export	skipwhite nextgroup=vim9Abstract,vim9ClassBody,vim9Const,vim9Def,vim9EnumBody,vim9Final,vim9InterfaceBody,vim9Type,vim9Var
    1              0.000000 endif
                            
                            " Filetypes {{{2
                            " =========
    1              0.000005 syn match   vimFiletype	"\<filet\%[ype]\(\s\+\I\i*\)*"	skipwhite contains=vimFTCmd,vimFTOption,vimFTError
    1              0.000003 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_vimFTError")
    1              0.000002  syn match   vimFTError  contained	"\I\i*"
    1              0.000000 endif
    1              0.000002 syn keyword vimFTCmd    contained	filet[ype]
    1              0.000002 syn keyword vimFTOption contained	detect indent off on plugin
                            
                            " Augroup : vimAugroupError removed because long augroups caused sync'ing problems. {{{2
                            " ======= : Trade-off: Increasing synclines with slower editing vs augroup END error checking.
    1              0.000007 syn cluster vimAugroupList	contains=@vimCmdList,vimFilter,vimFunc,vimLineComment,vimSpecFile,vimOper,vimNumber,vimOperParen,@vimComment,vimString,vimSubst,vimRegister,vimCmplxRepeat,vimNotation,vimCtrlChar,vimContinue
    1              0.000004 syn match   vimAugroup	"\<aug\%[roup]\>" contains=vimAugroupKey,vimAugroupBang skipwhite nextgroup=vimAugroupBang,vimAutoCmdGroup
    1              0.000002 if exists("g:vimsyn_folding") && g:vimsyn_folding =~# 'a'
                              syn region  vimAugroup  fold	start="\<aug\%[roup]\>\ze\s\+\%([eE][nN][dD]\)\@!\S\+" matchgroup=vimAugroupKey end="\<aug\%[roup]\>\ze\s\+[eE][nN][dD]\>" contains=vimAutoCmd,@vimAugroupList,vimAugroupkey skipwhite nextgroup=vimAugroupEnd
    1              0.000001 else
    1              0.000007   syn region  vimAugroup	start="\<aug\%[roup]\>\ze\s\+\%([eE][nN][dD]\)\@!\S\+" matchgroup=vimAugroupKey end="\<aug\%[roup]\>\ze\s\+[eE][nN][dD]\>" contains=vimAutoCmd,@vimAugroupList,vimAugroupkey skipwhite nextgroup=vimAugroupEnd
    1              0.000000 endif
    1              0.000002 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_noaugrouperror")
    1              0.000003   syn match   vimAugroupError	"\<aug\%[roup]\>\s\+[eE][nN][dD]\>"
    1              0.000000 endif
                            
    1              0.000001 syn match   vimAutoCmdGroup	contained "\S\+"
    1              0.000002 syn match   vimAugroupEnd	contained "\c\<END\>"
    1              0.000002 syn match   vimAugroupBang	contained "\a\@1<=!" skipwhite nextgroup=vimAutoCmdGroup
    1              0.000004 syn keyword vimAugroupKey	contained aug[roup]  skipwhite nextgroup=vimAugroupBang,vimAutoCmdGroup,vimAugroupEnd
                            
                            " Operators: {{{2
                            " =========
    1              0.000002 syn cluster	vimOperGroup	contains=@vimContinue,@vimExprList,vim9Comment
    1              0.000003 syn match	vimOper	"\a\@<!!"			skipwhite skipnl nextgroup=@vimOperContinue,@vimExprList,vimSpecFile
    1              0.000003 syn match	vimOper	"||\|&&\|[-+*/%.]"		skipwhite skipnl nextgroup=@vimOperContinue,@vimExprList,vimSpecFile
    1              0.000002 syn match	vimOper	"?"			skipwhite skipnl nextgroup=@vimOperContinue,@vimExprList
                            " distinguish ternary : from ex-colon
    1              0.000004 syn match	vimOper	"\s\@1<=:\ze\s\|\s\@1<=:$"		skipwhite skipnl nextgroup=@vimOperContinue,@vimExprList
    1              0.000002 syn match	vimOper	"??"			skipwhite skipnl nextgroup=@vimOperContinue,@vimExprList
    1              0.000002 syn match	vimOper	"="			skipwhite skipnl nextgroup=@vimOperContinue,@vimExprList,vimSpecFile
    1              0.000005 syn match	vimOper	"\%#=1\%(==\|!=\|>=\|<=\|=\~\|!\~\|>\|<\)[?#]\="	skipwhite skipnl nextgroup=@vimOperContinue,@vimExprList,vimSpecFile
    1              0.000003 syn match	vimOper	"\<is\%(not\)\=\>"		skipwhite skipnl nextgroup=@vimOperContinue,@vimExprList,vimSpecFile
    1              0.000003 syn match	vimOper	"\<is\%(not\)\=[?#]"		skipwhite skipnl nextgroup=@vimOperContinue,@vimExprList,vimSpecFile
    1              0.000007 syn region	vimOperParen 		matchgroup=vimParenSep start="("    end=")" contains=@vimOperGroup nextgroup=vimSubscript
    1              0.000004 syn region	vimOperParen		matchgroup=vimSep	     start="#\={" end="}" contains=@vimOperGroup nextgroup=vimSubscript,vimVar
    1              0.000003 syn region	vimOperParen	contained	matchgroup=vimSep	     start="\["	end="]" contains=@vimOperGroup nextgroup=vimSubscript,vimVar
    1              0.000003 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_noopererror")
    1              0.000001  syn match	vimOperError	")"
    1              0.000000 endif
                            
    1              0.000003 syn match	vimOperContinue		contained	"^\s*\zs\\"	 skipwhite skipnl nextgroup=@vimOperContinue,@vimExprList
    1              0.000003 syn match         vimOperContinueComment	contained	'^\s*\zs["#]\\ .*' skipwhite skipnl nextgroup=@vimOperContinue,@vimExprList
    1              0.000002 syn cluster	vimOperContinue		contains=vimOperContinue,vimOperContinueComment
                            
                            " Lambda Expressions: {{{2
                            " ==================
    1              0.000002 syn match	vimLambdaOperator	contained	"->" skipwhite nextgroup=@vimExprList
    1              0.000009 syn region	vimLambda	contained	matchgroup=Delimiter start="{\ze[[:space:][:alnum:]_.,]*->" end="}" end="$" skip=+\s*\n\s*\\\|\s*\n\s*"\\ + contains=@vimContinue,@vimExprList,vimLambdaParams
    1              0.000004 syn match	vimLambdaParams	contained	"{\@1<=.\{-}\%(->\)\@=" nextgroup=vimLambdaOperator contains=vimFuncParam
                            
    1              0.000003 syn match	vim9LambdaOperator    contained	"=>" skipwhite skipempty nextgroup=@vimExprList,vim9LambdaBlock,vim9LambdaOperatorComment
    1              0.000001 syn match	vim9LambdaParamsParen contained	"[()]"
    1              0.000019 syn region	vim9LambdaParams	    contained
                                  \ matchgroup=vim9LambdaParamsParen
                                  \ start="(\ze\s*\(\.\.\.\)\=\h\w*[,:]\%(\s\|$\)"
                                  \ start="(\ze\s*\n
                                    "\ line continuations
                                    \\%(\s*\%(#\\ .*\|\\\s*\)\n\)*\s*\\\s*
                                    "\ parameter names
                                    \\(\.\.\.\)\=\h\w*[,:]\%(\s\|$\)"
                                  \ end=")\ze\%(:\s\|\s\+=>\)"
                                  \ matchgroup=vimContinue
                                  \ end="^\s*\\\ze\s\+=>"
                                  \ skipwhite nextgroup=vim9LambdaReturnType,vim9LambdaOperator
                                  \ contains=@vim9Continue,vimDefParam,vim9LambdaParamsParen
    1              0.000006 syn match	vim9LambdaParams	    contained     "(\s*)\|(\s*\(\.\.\.\)\=\h\w*\s*)\ze\%(:\s\|\s\+=>\)" skipwhite nextgroup=vim9LambdaReturnType,vim9LambdaOperator contains=vimDefParam,vim9LambdaParamsParen
                            
    1              0.000006 syn region	vim9LambdaReturnType  contained	start=":\s" end="$" end="\ze#" end="\ze=>" skipwhite skipempty nextgroup=vim9LambdaOperator,vim9LamdaOperatorComment contains=vimTypeSep transparent
    1              0.000003 syn region	vim9LambdaBlock	    contained	matchgroup=vimSep start="{" end="^\s*\zs}" contains=@vimDefBodyList
                            
    1              0.000003 syn match	vim9LambdaOperatorComment contained "#.*" skipwhite skipempty nextgroup=@vimExprList,vim9LambdaBlock,vim9LambdaOperatorComment
                            
                            " Functions: Tag is provided for those who wish to highlight tagged functions {{{2
                            " =========
    1              0.000004 syn cluster	vimFuncList	contains=vimFuncBang,vimFunctionError,vimFuncKey,vimFuncScope,vimFuncSID,Tag
    1              0.000003 syn cluster	vimDefList	contains=vimFuncBang,vimFunctionError,vimDefKey,vimFuncScope,vimFuncSID,Tag
                            
    1              0.000008 syn cluster	vimFuncBodyCommon	contains=@vimCmdList,vimCmplxRepeat,vimContinue,vimCtrlChar,vimDef,vimFBVar,vimFunc,vimFunction,vimLetHereDoc,vimNotFunc,vimNumber,vimOper,vimOperParen,vimRegister,vimSpecFile,vimString,vimSubst,vimFuncFold,vimDefFold
    1              0.000004 syn cluster	vimFuncBodyList	contains=@vimFuncBodyCommon,vimComment,vimLineComment,vimInsert,vimConst,vimLet,vimSearch
    1              0.000007 syn cluster	vimDefBodyList	contains=@vimFuncBodyCommon,vim9Comment,vim9LineComment,vim9Block,vim9Const,vim9Final,vim9Var,vim9Null,vim9Boolean,vim9For,vim9LhsVariable,vim9LhsVariableList,vim9LhsRegister,vim9Search,@vimSpecialVar
                            
    1              0.000003 syn region	vimFuncPattern	contained		matchgroup=vimOper start="/" end="$" contains=@vimSubstList
    1              0.000004 syn match	vimFunction	"\<fu\%[nction]\>"	skipwhite nextgroup=vimCmdSep,vimComment,vimFuncPattern contains=vimFuncKey
    1              0.000003 syn match	vimDef	"\<def\>"		skipwhite nextgroup=vimCmdSep,vimComment,vimFuncPattern contains=vimDefKey
                            
    1              0.000010 syn match	vimFunction	"\<fu\%[nction]\>!\=\s*\%(<[sS][iI][dD]>\|[sg]:\)\=\%(\i\|[#.]\|{.\{-1,}}\)\+"	contains=@vimFuncList skipwhite nextgroup=vimFuncParams
    1              0.000006 syn match	vimDef	"\<def\>!\=\s*\%(<[sS][iI][dD]>\|[sg]:\)\=\%(\i\|[#.]\|{.\{-1,}}\)\+"		contains=@vimDefList            nextgroup=vimDefParams
                            
    1              0.000003 syn match	vimFuncComment	contained	+".*+ skipwhite skipempty nextgroup=vimFuncBody,vimEndfunction
    1              0.000002 syn match	vimDefComment	contained	"#.*" skipwhite skipempty nextgroup=vimDefBody,vimEnddef
                            
    1              0.000001 syn match	vimFuncBang	contained	"!"
    1              0.000001 syn match	vimFuncSID	contained	"\c<sid>"
    1              0.000001 syn match	vimFuncScope	contained	"\<[sg]:"
    1              0.000002 syn keyword	vimFuncKey	contained	fu[nction]
    1              0.000001 syn keyword	vimDefKey	contained	def
                            
    1              0.000008 syn region	vimFuncParams	contained	matchgroup=Delimiter start="(" skip=+\n\s*\\\|\n\s*"\\ + end=")" skipwhite skipempty nextgroup=vimFuncBody,vimFuncComment,vimEndfunction,vimFuncMod,vim9CommentError	contains=vimFuncParam,vimOperParen,@vimContinue
    1              0.000006 syn region	vimDefParams	contained	matchgroup=Delimiter start="("		   end=")" skipwhite skipempty nextgroup=vimDefBody,vimDefComment,vimEnddef,vimReturnType,vimCommentError	contains=vimDefParam,vim9Comment,vimFuncParamEquals,vimOperParen
    1              0.000003 syn match	vimFuncParam	contained	"\<\h\w*\>\|\.\.\."	skipwhite nextgroup=vimFuncParamEquals
    1              0.000002 syn match	vimDefParam	contained	"\<\h\w*\>"		skipwhite nextgroup=vimParamType,vimFuncParamEquals
                            
    1              0.000002 syn match	vimFuncParamEquals contained	"="			skipwhite           nextgroup=@vimExprList
    1              0.000005 syn match	vimFuncMod	 contained	"\<\%(abort\|closure\|dict\|range\)\>"	skipwhite skipempty nextgroup=vimFuncBody,vimFuncComment,vimEndfunction,vimFuncMod,vim9CommentError
                            
    1              0.000006 syn region	vimFuncBody	contained	start="^." matchgroup=vimCmdSep start="|" matchgroup=vimCommand end="\<endfu\%[nction]\>"	contains=@vimFuncBodyList skipwhite nextgroup=vimCmdSep,vimComment,vim9CommentError
    1              0.000005 syn region	vimDefBody	contained	start="^." matchgroup=vimCmdSep start="|" matchgroup=vimCommand end="\<enddef\>"	contains=@vimDefBodyList  skipwhite nextgroup=vimCmdSep,vim9Comment,vimCommentError
                            
    1              0.000003 syn match	vimEndfunction	"\<endf\%[unction]\>" skipwhite nextgroup=vimCmdSep,vimComment,vim9CommentError
    1              0.000002 syn match	vimEnddef	"\<enddef\>"	    skipwhite nextgroup=vimCmdSep,vim9Comment,vimCommentError
                            
    1              0.000002 if exists("g:vimsyn_folding") && g:vimsyn_folding =~# 'f'
                             syn region	vimFuncFold	start="\<fu\%[nction]\>!\=\s*\%(<[sS][iI][dD]>\|[sg]:\)\=\%(\i\|[#.]\|{.\{-1,}}\)\+\s*(" end="\<endf\%[unction]\>" contains=vimFunction fold keepend extend transparent
                             syn region	vimDefFold	start="\<def\>!\=\s*\%(<[sS][iI][dD]>\|[sg]:\)\=\%(\i\|[#.]\)\+("	                 end="\<enddef\>"	       contains=vimDef      fold keepend extend transparent
    1              0.000001 endif
                            
    1              0.000001 syn match	vimFuncBlank contained	"\s\+"
                            
                            " Types: {{{2
                            " =====
                            
    1              0.000005 syn region	vimReturnType	contained	start=":\s" end="$" matchgroup=vim9Comment end="\ze[#"]" skipwhite skipempty nextgroup=vimDefBody,vimDefComment,vimEnddef,vimCommentError contains=vimTypeSep transparent
    1              0.000002 syn match	vimParamType	contained	":\s"	skipwhite skipnl nextgroup=@vimType contains=vimTypeSep
                            
    1              0.000002 syn match	vimTypeSep	contained	":\s\@=" skipwhite nextgroup=@vimType
    1              0.000003 syn keyword	vimType	contained	any blob bool channel float job number string void
    1              0.000001 syn match	vimType	contained	"\<func\>"
    1              0.000003 syn region	vimCompoundType	contained	matchgroup=vimType start="\<func("            end=")" nextgroup=vimTypeSep contains=@vimType oneline transparent
    1              0.000004 syn region	vimCompoundType   contained         matchgroup=vimType start="\<\%(list\|dict\)<" end=">"                      contains=@vimType oneline transparent
    1              0.000001 syn match	vimUserType	contained	"\<\u\w*\>"
                            
    1              0.000002 syn cluster vimType contains=vimType,vimCompoundType,vimUserType
                            
                            " Classes, Enums And Interfaces: {{{2
                            " =============================
                            
    1              0.000001 if s:vim9script
                              " Methods {{{3
                              syn match	vim9MethodDef		contained	"\<def\>"	skipwhite nextgroup=vim9MethodDefName,vim9ConstructorDefName
                              syn match	vim9MethodDefName		contained	"\<\h\w*\>"	nextgroup=vim9MethodDefParams contains=@vim9MethodName
                              syn region	vim9MethodDefParams	contained
                                    \ matchgroup=Delimiter start="(" end=")"
                                    \ skipwhite skipnl nextgroup=vim9MethodDefBody,vimDefComment,vimEnddef,vim9MethodDefReturnType,vimCommentError
                                    \ contains=vimDefParam,vim9Comment,vimFuncParamEquals
                            
                              syn match	vim9ConstructorDefName	contained	"\<new\w*\>"
                                    \ nextgroup=vim9ConstructorDefParams
                                    \ contains=@vim9MethodName
                              syn match	vim9ConstructorDefParam	contained	"\<\%(this\.\)\=\h\w*\>"
                                    \ skipwhite nextgroup=vimParamType,vimFuncParamEquals
                                    \ contains=vim9This,vimOper
                              syn region	vim9ConstructorDefParams	contained
                                    \ matchgroup=Delimiter start="(" end=")"
                                    \ skipwhite skipnl nextgroup=vim9MethodDefBody,vimDefComment,vimEnddef,vimCommentError
                                    \ contains=vim9ConstructorDefParam,vim9Comment,vimFuncParamEquals
                            
                              syn region	vim9MethodDefReturnType	contained
                                    \ start=":\s" end="$" matchgroup=vim9Comment end="\ze[#"]"
                                    \ skipwhite skipnl nextgroup=vim9MethodDefBody,vimDefComment,vimCommentError
                                    \ contains=vimTypeSep
                                    \ transparent
                              syn region	vim9MethodDefBody		contained
                                    \ start="^.\=" matchgroup=vimCommand end="\<enddef\>"
                                    \ skipwhite nextgroup=vimCmdSep,vim9Comment,vimCommentError
                                    \ contains=@vim9MethodDefBodyList
                            
                              syn cluster	vim9MethodDefBodyList contains=@vimDefBodyList,vim9This,vim9Super
                            
                              if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimfunctionerror")
                                syn match	vim9MethodNameError contained	"\<[a-z0-9]\i\>"
                              endif
                              syn match	vim9MethodName	contained	"\<new\w*\>"
                              syn keyword	vim9MethodName	contained	empty len string
                            
                              syn cluster	vim9MethodName	contains=vim9MethodName,vim9MethodNameError
                            
                              if exists("g:vimsyn_folding") && g:vimsyn_folding =~# 'f'
                                syn region	vim9MethodDefFold	contained	start="\%(^\s*\%(:\=static\s\+\)\=\)\@16<=:\=def\s\+\h\i*(" end="^\s*:\=enddef\>" contains=vim9MethodDef fold keepend extend transparent
                                syn region	vim9MethodDefFold	contained	start="^\s*:\=def\s\+new\i*("		      end="^\s*:\=enddef\>" contains=vim9MethodDef fold keepend extend transparent
                              endif
                            
                              syn cluster vim9MethodDef contains=vim9MethodDef,vim9MethodDefFold
                            
                              " Classes {{{3
                              syn cluster	vim9ClassBodyList		contains=vim9Abstract,vim9Class,vim9Comment,vim9LineComment,@vim9Continue,@vimExprList,vim9Extends,vim9Implements,@vim9MethodDef,vim9Public,vim9Static,vim9Const,vim9Final,vim9This,vim9Super,vim9Var
                            
                              syn match	vim9Class		contained	"\<class\>"	skipwhite        nextgroup=vim9ClassName
                              syn match	vim9ClassName		contained	"\<\u\w*\>"	skipwhite skipnl nextgroup=vim9Extends,vim9Implements
                              syn match	vim9SuperClass		contained	"\<\u\w*\>"	skipwhite skipnl nextgroup=vim9Implements
                              syn match	vim9ImplementedInterface	contained	"\<\u\w*\>"	skipwhite skipnl nextgroup=vim9InterfaceListComma,vim9Extends
                              syn match	vim9InterfaceListComma	contained	","	skipwhite skipnl nextgroup=vim9ImplementedInterface
                              syn keyword	vim9Abstract			abstract	skipwhite skipnl nextgroup=vim9ClassBody,vim9AbstractDef
                              syn keyword	vim9Extends		contained	extends	skipwhite skipnl nextgroup=vim9SuperClass
                              syn keyword	vim9Implements		contained	implements	skipwhite skipnl nextgroup=vim9ImplementedInterface
                              syn keyword	vim9Public		contained	public
                              syn keyword	vim9Static		contained	static
                              " FIXME: don't match as dictionary keys, remove when operators are not
                              "        shared between Vim9 and legacy script
                              syn match	vim9This		contained	"\.\@1<!\<this\>:\@!"
                              " super must be folowed by '.'
                              syn match	vim9Super		contained	"\.\@1<!\<super\.\@="
                            
                              VimFoldc syn region	vim9ClassBody	start="\<class\>" matchgroup=vimCommand end="\<endclass\>" contains=@vim9ClassBodyList transparent
                            
                              " Enums {{{3
                              syn cluster	vim9EnumBodyList		contains=vim9Comment,vim9LineComment,@vim9Continue,vim9Enum,vim9Implements,@vim9MethodDef,vim9Const,vim9Final,vim9Var
                            
                              syn match	vim9Enum		contained	"\<enum\>"	skipwhite nextgroup=vim9EnumName
                              syn match	vim9EnumName		contained	"\<\u\w*\>"	skipwhite skipnl nextgroup=vim9Implements
                            
                              VimFolde syn region	vim9EnumBody	start="\<enum\>" matchgroup=vimCommand end="\<endenum\>" contains=@vim9EnumBodyList transparent
                            
                              " Interfaces {{{3
                              " TODO: limit to decl only - no init values
                              syn cluster	vim9InterfaceBodyList	contains=vim9Comment,vim9LineComment,@vim9Continue,vim9Extends,vim9Interface,vim9AbstractDef,vim9Var
                            
                              syn match	vim9Interface		contained	"\<interface\>"	skipwhite nextgroup=vim9InterfaceName
                              syn match	vim9InterfaceName		contained	"\<\u\w*\>"	skipwhite skipnl nextgroup=vim9Extends
                            
                              syn keyword	vim9AbstractDef		contained	def	skipwhite nextgroup=vim9AbstractDefName
                              syn match	vim9AbstractDefName	contained	"\<\h\w*\>"	skipwhite nextgroup=vim9AbstractDefParams contains=@vim9MethodName
                              syn region	vim9AbstractDefParams	contained
                                    \ matchgroup=Delimiter start="(" end=")"
                                    \ skipwhite skipnl nextgroup=vimDefComment,vim9AbstractDefReturnType,vimCommentError
                                    \ contains=vimDefParam,vim9Comment,vimFuncParamEquals
                              syn region	vim9AbstractDefReturnType	contained
                                    \ start=":\s" end="$" matchgroup=vim9Comment end="\ze[#"]"
                                    \ skipwhite skipnl nextgroup=vimDefComment,vimCommentError
                                    \ contains=vimTypeSep
                                    \ transparent
                            
                              VimFoldi syn region	vim9InterfaceBody	start="\<interface\>" matchgroup=vimCommand end="\<endinterface\>" contains=@vim9InterfaceBodyList transparent
                            
                              " Type Aliases {{{3
                              syn match	vim9Type		"\<ty\%[pe]\>"	skipwhite nextgroup=vim9TypeAlias,vim9TypeAliasError
                              syn match	vim9TypeAlias	 contained	"\<\u\w*\>"	skipwhite nextgroup=vim9TypeEquals
                              syn match	vim9TypeEquals	 contained	"="	skipwhite nextgroup=@vimType
                              if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_notypealiaserror")
                                syn match	vim9TypeAliasError contained	"\<\l\w*\>"	skipwhite nextgroup=vim9TypeEquals
                              endif
    1              0.000000 endif
                            
                            " Blocks: {{{2
                            " ======
    1              0.000009 Vim9 syn region	vim9Block	matchgroup=vimSep start="{" end="^\s*\zs}" contains=@vimDefBodyList
                            
                            " Keymaps: {{{2
                            " =======
                            
    1              0.000003 syn match  vimKeymapStart	"^"	contained skipwhite nextgroup=vimKeymapLhs,@vimKeymapLineComment
    1              0.000002 syn match  vimKeymapLhs	"\S\+"	contained skipwhite nextgroup=vimKeymapRhs contains=vimNotation
    1              0.000002 syn match  vimKeymapRhs	"\S\+"	contained skipwhite nextgroup=vimKeymapTailComment contains=vimNotation
    1              0.000001 syn match  vimKeymapTailComment	"\S.*"	contained
                            
                            " TODO: remove when :" comment is matched in parts as "ex-colon comment" --djk
    1              0.000001 if s:vim9script
                              syn match  vim9KeymapLineComment	"#.*"	contained contains=@vimCommentGroup,vimCommentString,vim9CommentTitle
    1              0.000001 else
    1              0.000004   syn match  vimKeymapLineComment	+".*+	contained contains=@vimCommentGroup,vimCommentString,vimCommentTitle
    1              0.000000 endif
    1              0.000190 syn cluster vimKeymapLineComment contains=vim9\=KeymapLineComment
                            
    1              0.000005 syn region vimLoadkeymap matchgroup=vimCommand start="\<loadk\%[eymap]\>" end="\%$" contains=vimKeymapStart
                            
                            " Special Filenames, Modifiers, Extension Removal: {{{2
                            " ===============================================
    1              0.000004 syn match	vimSpecFile	"<c\(word\|WORD\)>"	nextgroup=vimSpecFileMod,vimSubst1
    1              0.000003 syn match	vimSpecFile	"<\([acs]file\|amatch\|abuf\)>"	nextgroup=vimSpecFileMod,vimSubst1
    1              0.000003 syn match	vimSpecFile	"\s%[ \t:]"ms=s+1,me=e-1	nextgroup=vimSpecFileMod,vimSubst1
    1              0.000002 syn match	vimSpecFile	"\s%$"ms=s+1		nextgroup=vimSpecFileMod,vimSubst1
    1              0.000002 syn match	vimSpecFile	"\s%<"ms=s+1,me=e-1	nextgroup=vimSpecFileMod,vimSubst1
    1              0.000008 syn match	vimSpecFile	"#\d\+\|[#%]<\>"		nextgroup=vimSpecFileMod,vimSubst1
    1              0.000002 syn match	vimSpecFileMod	"\(:[phtre]\)\+"	contained
                            
                            " User-Specified Commands: {{{2
                            " =======================
    1              0.000008 syn cluster	vimUserCmdList	contains=@vimCmdList,vimCmplxRepeat,@vimComment,vimCtrlChar,vimEscapeBrace,vimFunc,vimNotation,vimNumber,vimOper,vimRegister,vimSpecFile,vimString,vimSubst,vimSubstRep,vimSubstRange
    1              0.000002 syn keyword	vimUserCmdKey	contained	com[mand]
    1              0.000003 syn match	vimUserCmdName	contained	"\<\u[[:alnum:]]*\>"	skipwhite nextgroup=vimUserCmdBlock
    1              0.000010 syn match	vimUserCmd		"\<com\%[mand]\>!\=.*$"	contains=vimUserCmdKey,vimBang,vimUserCmdAttr,vimUserCmdAttrError,vimUserCmdName,@vimUserCmdList,vimComFilter
    1              0.000002 syn match	vimUserCmdAttrError	contained	"-\a\+\ze\%(\s\|=\)"
    1              0.000003 syn match	vimUserCmdAttr	contained	"-addr="		contains=vimUserCmdAttrKey nextgroup=vimUserCmdAttrAddr
    1              0.000002 syn match	vimUserCmdAttr	contained	"-bang\>"		contains=vimUserCmdAttrKey
    1              0.000002 syn match	vimUserCmdAttr	contained	"-bar\>"		contains=vimUserCmdAttrKey
    1              0.000002 syn match	vimUserCmdAttr	contained	"-buffer\>"		contains=vimUserCmdAttrKey
    1              0.000003 syn match	vimUserCmdAttr	contained	"-complete="		contains=vimUserCmdAttrKey nextgroup=vimUserCmdAttrCmplt,vimUserCmdError
    1              0.000002 syn match	vimUserCmdAttr	contained	"-count\>"		contains=vimUserCmdAttrKey
    1              0.000002 syn match	vimUserCmdAttr	contained	"-count="		contains=vimUserCmdAttrKey nextgroup=vimNumber
    1              0.000002 syn match	vimUserCmdAttr	contained	"-keepscript\>"		contains=vimUserCmdAttrKey
    1              0.000002 syn match	vimUserCmdAttr	contained	"-nargs="		contains=vimUserCmdAttrKey nextgroup=vimUserCmdAttrNargs
    1              0.000002 syn match	vimUserCmdAttr	contained	"-range\>"		contains=vimUserCmdAttrKey
    1              0.000003 syn match	vimUserCmdAttr	contained	"-range="		contains=vimUserCmdAttrKey nextgroup=vimNumber,vimUserCmdAttrRange
    1              0.000002 syn match	vimUserCmdAttr	contained	"-register\>"		contains=vimUserCmdAttrKey
                            
    1              0.000001 syn match	vimUserCmdAttrNargs	contained	"[01*?+]"
    1              0.000001 syn match	vimUserCmdAttrRange	contained	"%"
                            
    1              0.000004 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_nousercmderror")
    1              0.000001  syn match	vimUserCmdError	contained	"\S\+\>"
    1              0.000000 endif
                            
    1              0.000001 syn case ignore
    1              0.000009 syn keyword	vimUserCmdAttrKey   contained	a[ddr] ban[g] bar bu[ffer] com[plete] cou[nt] k[eepscript] n[args] ra[nge] re[gister]
                            " GEN_SYN_VIM: vimUserCmdAttrCmplt, START_STR='syn keyword vimUserCmdAttrCmplt contained', END_STR=''
    1              0.000012 syn keyword vimUserCmdAttrCmplt contained arglist augroup behave breakpoint buffer color command compiler cscope diff_buffer dir dir_in_path environment event expression file file_in_path filetype function help highlight history keymap locale mapclear mapping menu messages option packadd runtime scriptnames shellcmd shellcmdline sign syntax syntime tag tag_listfiles user var
    1              0.000003 syn keyword	vimUserCmdAttrCmplt     contained	custom customlist nextgroup=vimUserCmdAttrCmpltFunc,vimUserCmdError
    1              0.000006 syn match	vimUserCmdAttrCmpltFunc contained	",\%([sS]:\|<[sS][iI][dD]>\)\=\%(\h\w*\%([.#]\h\w*\)\+\|\h\w*\)"hs=s+1 nextgroup=vimUserCmdError
                            " GEN_SYN_VIM: vimUserCmdAttrAddr, START_STR='syn keyword vimUserCmdAttrAddr contained', END_STR=''
    1              0.000003 syn keyword vimUserCmdAttrAddr contained arguments arg buffers buf lines line loaded_buffers load other quickfix qf tabs tab windows win
    1              0.000001 syn match	vimUserCmdAttrAddr	contained	"?"
    1              0.000001 syn case match
                            
    1              0.000004 syn region	vimUserCmdBlock	contained	matchgroup=vimSep start="{" end="^\s*\zs}" contains=@vimDefBodyList
                            
    1              0.000003 syn match	vimDelcommand		"\<delc\%[ommand]\>" skipwhite nextgroup=vimDelcommandAttr
    1              0.000001 syn match	vimDelcommandAttr	contained	"-buffer\>"
                            
                            " Lower Priority Comments: after some vim commands... {{{2
                            " =======================
    1              0.000003 if get(g:, "vimsyn_comment_strings", 1)
    1              0.000003   syn region	vimCommentString	contained oneline start='\S\s\+"'ms=e end='"' extend
    1              0.000000 endif
                            
    1              0.000001 if s:vim9script
                              syn cluster vimComment contains=vim9Comment
    1              0.000000 else
    1              0.000001   syn cluster vimComment contains=vimComment
    1              0.000000 endif
                            
    1              0.000009 VimL syn match	vimComment	excludenl +\s"[^\-:.%#=*].*$+lc=1	contains=@vimCommentGroup,vimCommentString extend
    1              0.000034 VimL syn match	vimComment	+\<endif\s\+".*$+lc=5	contains=@vimCommentGroup,vimCommentString extend
    1              0.000007 VimL syn match	vimComment	+\<else\s\+".*$+lc=4	contains=@vimCommentGroup,vimCommentString extend
                            " Vim9 comments - TODO: might be highlighted while they don't work
    1              0.000007 Vim9 syn match	vim9Comment	excludenl +\s#[^{].*$+lc=1	contains=@vimCommentGroup,vimCommentString extend
    1              0.000007 Vim9 syn match	vim9Comment	+\<endif\s\+#[^{].*$+lc=5	contains=@vimCommentGroup,vimCommentString extend
    1              0.000024 Vim9 syn match	vim9Comment	+\<else\s\+#[^{].*$+lc=4	contains=@vimCommentGroup,vimCommentString extend
                            " Vim9 comment inside expression
    1              0.000023 Vim9 syn match	vim9Comment	+\s\zs#[^{].*$+ms=s+1	contains=@vimCommentGroup,vimCommentString contained extend
    1              0.000006 Vim9 syn match	vim9Comment	+^\s*#[^{].*$+		contains=@vimCommentGroup,vimCommentString contained extend
    1              0.000006 Vim9 syn match	vim9Comment	+^\s*#$+		contains=@vimCommentGroup,vimCommentString contained extend
                            
    1              0.000002 syn match	vim9CommentError	contained	"#.*"
    1              0.000001 syn match	vimCommentError	contained	+".*+
                            
                            " Environment Variables: {{{2
                            " =====================
    1              0.000001 syn match	vimEnvvar	"\$\I\i*"
    1              0.000001 syn match	vimEnvvar	"\${\I\i*}"
                            
                            " Strings {{{2
                            " =======
                            
                            " In-String Specials:
                            " Try to catch strings, if nothing else matches (therefore it must precede the others!)
                            "  vimEscapeBrace handles ["]  []"] (ie. "s don't terminate string inside [])
    1              0.000008 syn region	vimEscapeBrace	oneline   contained transparent start="[^\\]\(\\\\\)*\[\zs\^\=\]\=" skip="\\\\\|\\\]" end="]"me=e-1
    1              0.000002 syn match	vimPatSepErr	contained	"\\)"
    1              0.000001 syn match	vimPatSep	contained	"\\|"
    1              0.000013 syn region	vimPatSepZone	oneline   contained   matchgroup=vimPatSepZ start="\\%\=\ze(" skip="\\\\" end="\\)\|[^\\]['"]"	contains=@vimStringGroup
    1              0.000004 syn region	vimPatRegion	contained transparent matchgroup=vimPatSepR start="\\[z%]\=(" end="\\)"	contains=@vimSubstList oneline
    1              0.000001 syn match	vimNotPatSep	contained	"\\\\"
    1              0.000005 syn cluster	vimStringGroup	contains=vimEscape,vimEscapeBrace,vimPatSep,vimNotPatSep,vimPatSepErr,vimPatSepZone,@Spell
    1              0.000006 syn region	vimString	oneline keepend	matchgroup=vimString start=+[^a-zA-Z>\\@]"+lc=1 skip=+\\\\\|\\"+ matchgroup=vimStringEnd end=+"+ nextgroup=vimSubscript contains=@vimStringGroup extend
    1              0.000004 syn region	vimString	oneline	matchgroup=vimString start=+[^a-zA-Z>\\@]'+lc=1 end=+'+		       nextgroup=vimSubscript contains=vimQuoteEscape  extend
                            "syn region	vimString	oneline	start="\s/\s*\A"lc=1 skip="\\\\\|\\+" end="/"	contains=@vimStringGroup  " see tst45.vim
                            
    1              0.000001 syn match	vimEscape	contained	"\\."
                            " syn match	vimEscape	contained	+\\[befnrt\"]+
    1              0.000004 syn match	vimEscape	contained	"\\\o\{1,3}\|\\[xX]\x\{1,2}\|\\u\x\{1,4}\|\\U\x\{1,8}"
    1              0.000002 syn match	vimEscape	contained	"\\<" contains=vimNotation
    1              0.000002 syn match	vimEscape	contained	"\\<\*[^>]*>\=>"
    1              0.000001 syn match	vimQuoteEscape	contained	"''"
                            
    1              0.000004 syn region	vimString	oneline matchgroup=vimString start=+$'+ skip=+''+ end=+'+ nextgroup=vimSubscript contains=vimQuoteEscape,@vimStringInterpolation  extend
    1              0.000003 syn region	vimString	oneline matchgroup=vimString start=+$"+           end=+"+ nextgroup=vimSubscript contains=@vimStringGroup,@vimStringInterpolation extend
    1              0.000003 syn region	vimStringInterpolationExpr  oneline contained matchgroup=vimSep start=+{+ end=+}+ contains=@vimExprList
    1              0.000001 syn match	vimStringInterpolationBrace contained "{{"
    1              0.000001 syn match	vimStringInterpolationBrace contained "}}"
    1              0.000002 syn cluster	vimStringInterpolation contains=vimStringInterpolationExpr,vimStringInterpolationBrace
                            
                            " Substitutions: {{{2
                            " =============
    1              0.000004 syn cluster	vimSubstList	contains=vimPatSep,vimPatRegion,vimPatSepErr,vimSubstTwoBS,vimSubstRange,vimNotation
    1              0.000002 syn cluster	vimSubstRepList	contains=vimSubstSubstr,vimSubstTwoBS,vimNotation
    1              0.000002 syn cluster	vimSubstList	add=vimCollection
    1              0.000006 syn match	vimSubst	"^\s*\%(s\%[ubstitute]\|sm\%[agic]\|sno\%[magic]\)\>"			skipwhite nextgroup=vimSubstPat
    1              0.000005 syn match	vimSubst	"^\s*\%(s\%[ubstitute]\|sm\%[agic]\|sno\%[magic]\)[_#]\@="		skipwhite nextgroup=vimSubstPat
    1              0.000005 syn match	vimSubst1	contained	"\%(s\%[ubstitute]\|sm\%[agic]\>\|sno\%[magic]\)\>"		skipwhite nextgroup=vimSubstPat
    1              0.000004 syn match	vimSubst1	contained	"\%(s\%[ubstitute]\|sm\%[agic]\>\|sno\%[magic]\)[_#]\@="	skipwhite nextgroup=vimSubstPat
                            " TODO: Vim9 illegal separators for abbreviated :s form are [-.:], :su\%[...] required
                            "     : # is allowed but "not recommended" (see :h pattern-delimiter)
    1              0.000027 syn region	vimSubstPat	contained	matchgroup=vimSubstDelim start="\z([!#$%&'()*+,-./:;<=>?@[\]^_`{}~]\)"rs=s+1 skip="\\\\\|\\\z1" end="\z1"re=e-1,me=e-1	contains=@vimSubstList	nextgroup=vimSubstRep4	oneline
    1              0.000006 syn region	vimSubstRep4	contained	matchgroup=vimSubstDelim start="\z(.\)" skip="\\\\\|\\\z1" end="\z1" matchgroup=vimNotation end="<[cC][rR]>"	contains=@vimSubstRepList	nextgroup=vimSubstFlagErr	oneline
    1              0.000004 syn region	vimCollection	contained 	transparent	start="\\\@<!\[" skip="\\\[" end="\]"	contains=vimCollClass
    1              0.000002 syn match	vimCollClassErr	contained	"\[:.\{-\}:\]"
    1              0.000010 syn match	vimCollClass	contained 	transparent	"\%#=1\[:\(alnum\|alpha\|blank\|cntrl\|digit\|graph\|lower\|print\|punct\|space\|upper\|xdigit\|retu\%[rn]\|tab\|escape\|backspace\):\]"
    1              0.000002 syn match	vimSubstSubstr	contained	"\\z\=\d"
    1              0.000001 syn match	vimSubstTwoBS	contained	"\\\\"
    1              0.000002 syn match	vimSubstFlagErr	contained	"[^< \t\r|]\+" contains=vimSubstFlags
    1              0.000002 syn match	vimSubstFlags	contained	"[&cegiIlnpr#]\+"
                            
                            " Vi compatibility
    1              0.000001 syn match	vimSubstDelim	contained	"\\"
    1              0.000002 syn match	vimSubstPat	contained	"\\\ze[/?&]" contains=vimSubstDelim nextgroup=vimSubstRep4
                            
                            " Marks, Registers, Addresses, Filters: {{{2
    1              0.000004 syn match	vimMark	"'[a-zA-Z0-9]\ze[-+,!]"	nextgroup=vimFilter,vimMarkNumber,vimSubst1
    1              0.000029 syn match	vimMark	"'[[\]{}()<>]\ze[-+,!]"	nextgroup=vimFilter,vimMarkNumber,vimSubst1
    1              0.000003 syn match	vimMark	",\zs'[[\]{}()<>]\ze"	nextgroup=vimFilter,vimMarkNumber,vimSubst1
    1              0.000003 syn match	vimMark	"[!,:]\zs'[a-zA-Z0-9]"	nextgroup=vimFilter,vimMarkNumber,vimSubst1
    1              0.000004 syn match	vimMark	"\<norm\%[al]\s\zs'[a-zA-Z0-9]"	nextgroup=vimFilter,vimMarkNumber,vimSubst1
    1              0.000003 syn match	vimMarkNumber	"[-+]\d\+"		contained contains=vimOper nextgroup=vimSubst1
    1              0.000002 syn match	vimPlainMark contained	"'[a-zA-Z0-9]"
    1              0.000004 syn match	vimRange	"[`'][a-zA-Z0-9],[`'][a-zA-Z0-9]"	contains=vimMark	skipwhite nextgroup=vimFilter
                            
    1              0.000004 syn match	vimRegister	'[^,;[{: \t]\zs"[a-zA-Z0-9.%#:_\-/]\ze[^a-zA-Z_":0-9]'
    1              0.000002 syn match	vimRegister	'\<norm\s\+\zs"[a-zA-Z0-9]'
    1              0.000002 syn match	vimRegister	'\<normal\s\+\zs"[a-zA-Z0-9]'
    1              0.000001 syn match	vimRegister	'@"'
    1              0.000002 syn match	vimPlainRegister contained	'"[a-zA-Z0-9\-:.%#*+=]'
    1              0.000019 syn match	vimLetRegister	contained	'@["0-9\-a-zA-Z:.%#=*+~_/]'
                            
    1              0.000002 syn match	vimAddress	",\zs[.$]"	skipwhite nextgroup=vimSubst1
    1              0.000002 syn match	vimAddress	"%\ze\a"	skipwhite nextgroup=vimString,vimSubst1
                            
    1              0.000021 syn match	vimFilter 		"^!!\=[^"]\{-}\(|\|\ze\"\|$\)"	contains=vimOper,vimSpecFile
    1              0.000003 syn match	vimFilter    contained	"!!\=[^"]\{-}\(|\|\ze\"\|$\)"	contains=vimOper,vimSpecFile
    1              0.000003 syn match	vimComFilter contained	"|!!\=[^"]\{-}\(|\|\ze\"\|$\)"      contains=vimOper,vimSpecFile
                            
                            " Complex Repeats: (:h complex-repeat) {{{2
                            " ===============
    1              0.000003 syn match	vimCmplxRepeat	'[^a-zA-Z_/\\()]q[0-9a-zA-Z"]\>'lc=1
    1              0.000003 syn match	vimCmplxRepeat	'@[0-9a-z".=@:]\ze\($\|[^a-zA-Z]\>\)'
                            
                            " Set command and associated set-options (vimOptions) with comment {{{2
    1              0.000006 syn match	vimSet		"\<\%(setl\%[ocal]\|setg\%[lobal]\|se\%[t]\)\>" skipwhite nextgroup=vimSetBang,vimSetArgs
    1              0.000010 syn region	vimSetArgs	contained	start="\S" skip=+\\|\|\n\s*\\\|\n\s*["#]\\ + matchgroup=vimCmdSep end="|" end="$" matchgroup=vimNotation end="<[cC][rR]>" keepend contains=@vimComment,@vimContinue,vimErrSetting,vimOption,vimSetAll,vimSetTermcap
    1              0.000010 syn region	vimSetEqual	contained	matchgroup=vimOper start="[=:]\|[-+^]=" skip=+\\|\|\\\s\|\n\s*\\\|\n\s*["#]\\ \|^\s*\\\|^\s*["#]\\ + matchgroup=vimCmdSep end="|" end="\ze\s" end="$" contains=@vimContinue,vimCtrlChar,vimEnvvar,vimNotation,vimSetSep
    1              0.000003 syn match	vimSetBang	contained	"\a\@1<=!" skipwhite nextgroup=vimSetAll,vimSetTermcap
    1              0.000002 syn keyword	vimSetAll	contained	all nextgroup=vimSetMod
    1              0.000001 syn keyword	vimSetTermcap	contained	termcap
    1              0.000003 syn region	vimSetString	contained	start=+="+hs=s+1	skip=+\\\\\|\\"+  end=+"+	contains=vimCtrlChar
    1              0.000001 syn match	vimSetSep	contained	"[,:]"
    1              0.000003 syn match	vimSetMod	contained	"\a\@1<=\%(&vim\=\|[!&?<]\)"
                            
                            " Variable Declarations: {{{2
                            " =====================
    1              0.000008 VimL syn keyword	vimLet	let		skipwhite nextgroup=@vimSpecialVar,vimVar,vimVarList
    1              0.000006 VimL syn keyword	vimConst	cons[t]		skipwhite nextgroup=@vimSpecialVar,vimVar,vimVarList
    1              0.000004 syn region	vimVarList	contained
                                  \ start="\[" end="]"
                                  \ contains=@vimContinue,@vimSpecialVar,vimVar
                            
    1              0.000006 VimL syn keyword	vimUnlet		unl[et]	skipwhite nextgroup=vimUnletBang,vimUnletVars
    1              0.000002 syn match	vimUnletBang	contained	"\a\@1<=!"	skipwhite nextgroup=vimUnletVars
    1              0.000008 syn region	vimUnletVars	contained
                                  \ start="$\I\|\h" skip=+\n\s*\\\|\n\s*"\\ \|^\s*"\\ + end="$" end="\ze[|"]"
                                  \ nextgroup=vimCmdSep,vimComment
                                  \ contains=@vimContinue,vimEnvvar,vimVar
                            
    1              0.000009 VimFoldh syn region vimLetHereDoc	matchgroup=vimLetHereDocStart start='\%(^\z(\s*\)\S.*\)\@<==<<\s*trim\%(\s\+\)\@>\z(\L\S*\)'	matchgroup=vimLetHereDocStop end='^\z1\=\z2$' extend
    1              0.000007 VimFoldh syn region vimLetHereDoc	matchgroup=vimLetHereDocStart start='=<<\%(\s*\)\@>\z(\L\S*\)'			matchgroup=vimLetHereDocStop end='^\z1$' extend
    1              0.000009 VimFoldh syn region vimLetHereDoc	matchgroup=vimLetHereDocStart start='\%(^\z(\s*\)\S.*\)\@<==<<\s*\%(trim\s\+eval\|eval\s\+trim\)\%(\s\+\)\@>\z(\L\S*\)'	matchgroup=vimLetHereDocStop end='^\z1\=\z2$' contains=@vimStringInterpolation extend
    1              0.000006 VimFoldh syn region vimLetHereDoc	matchgroup=vimLetHereDocStart start='=<<\s*eval\%(\s\+\)\@>\z(\L\S*\)'			matchgroup=vimLetHereDocStop end='^\z1$' contains=@vimStringInterpolation extend
                            
    1              0.000007 Vim9 syn keyword	vim9Const	const	skipwhite nextgroup=vim9Variable,vim9VariableList
    1              0.000005 Vim9 syn keyword	vim9Final	final	skipwhite nextgroup=vim9Variable,vim9VariableList
    1              0.000004 Vim9 syn keyword	vim9Var	var	skipwhite nextgroup=vim9Variable,vim9VariableList
                            
    1              0.000003 syn match	vim9Variable	contained	"\<\h\w*\>"	skipwhite nextgroup=vimTypeSep,vimLetHereDoc,vimOper
    1              0.000004 syn region	vim9VariableList	contained	start="\[" end="]" contains=@vimContinue,@vimSpecialVar,vim9Variable
                            
                            " Lockvar and Unlockvar: {{{2
                            " =====================
    1              0.000003 syn keyword	vimLockvar	lockv[ar]	skipwhite nextgroup=vimLockvarBang,vimLockvarDepth,vimLockvarVars
    1              0.000003 syn keyword	vimUnlockvar	unlo[ckvar]	skipwhite nextgroup=vimLockvarBang,vimLockvarDepth,vimLockvarVars
    1              0.000002 syn match	vimLockvarBang	contained	"\a\@1<=!"	skipwhite nextgroup=vimLockvarVars
    1              0.000002 syn match	vimLockvarDepth	contained	"\<[0-3]\>"	skipwhite nextgroup=vimLockvarVars
    1              0.000007 syn region	vimLockvarVars	contained
                                  \ start="\h" skip=+\n\s*\\\|\n\s*"\\ \|^\s*"\\ + end="$" end="\ze[|"]"
                                  \ nextgroup=vimCmdSep,vimComment
                                  \ contains=@vimContinue,vimVar
                            
    1              0.000002 hi def link vimLockvar vimCommand
    1              0.000030 hi def link vimUnlockvar vimCommand
    1              0.000001 hi def link vimLockvarBang vimBang
    1              0.000001 hi def link vimLockvarDepth vimNumber
                            
                            " For: {{{2
                            " ===
                            " handles Vim9 and legacy for now
    1              0.000008 syn region	vimFor
                                  \ matchgroup=vimCommand
                                  \ start="\<for\>" end="\<in\>"
                                  \ skipwhite skipnl nextgroup=@vimForInContinue,vim9ForInComment,@vimExprList
                                  \ contains=@vimContinue,vimVar,vimVarList,vim9VariableList
                                  \ transparent
                            
    1              0.000003 syn match	vim9ForInComment		contained	"#.*"	skipwhite skipempty nextgroup=vimForInComment,@vimExprList
                            
    1              0.000003 syn match	vimForInContinue		contained	"^\s*\zs\\"	 skipwhite skipnl nextgroup=@vimForInContinue,@vimExprList
    1              0.000004 syn match         vimForInContinueComment	contained	'^\s*\zs["#]\\ .*' skipwhite skipnl nextgroup=@vimForInContinue,@vimExprList
    1              0.000002 syn cluster	vimForInContinue		contains=vimForInContinue,vimForInContinueComment
                            
                            " Abbreviations: {{{2
                            " =============
                            " GEN_SYN_VIM: vimCommand abbrev, START_STR='syn keyword vimAbb', END_STR='skipwhite nextgroup=vimMapMod,vimMapLhs'
    1              0.000010 syn keyword vimAbb ab[breviate] ca[bbrev] cnorea[bbrev] cuna[bbrev] ia[bbrev] inorea[bbrev] iuna[bbrev] norea[bbrev] una[bbreviate] skipwhite nextgroup=vimMapMod,vimMapLhs
                            " GEN_SYN_VIM: vimCommand abclear, START_STR='syn keyword vimAbb', END_STR='skipwhite nextgroup=vimMapMod'
    1              0.000006 syn keyword vimAbb abc[lear] cabc[lear] iabc[lear] skipwhite nextgroup=vimMapMod
                            
                            " Autocmd: {{{2
                            " =======
    1              0.000002 syn match	vimAutoCmdBang	contained	"\a\@1<=!"	skipwhite nextgroup=vimAutoEventList
    1              0.000004 syn match	vimAutoEventList	contained	"\%(\a\+,\)*\a\+"	contains=vimAutoEvent,nvimAutoEvent nextgroup=vimAutoCmdSpace
    1              0.000002 syn match	vimAutoCmdSpace	contained	"\s\+"	nextgroup=vimAutoCmdSfxList
    1              0.000002 syn match	vimAutoCmdSfxList	contained	"\S*"	skipwhite nextgroup=vimAutoCmdMod,vimAutoCmdBlock
    1              0.000002 syn keyword	vimAutoCmd	au[tocmd]		skipwhite nextgroup=vimAutoCmdBang,vimAutoEventList
    1              0.000003 syn keyword	vimAutoCmd	do[autocmd] doautoa[ll]	skipwhite nextgroup=vimAutoEventList
    1              0.000003 syn match	vimAutoCmdMod	"\(++\)\=\(once\|nested\)"	skipwhite nextgroup=vimAutoCmdBlock
    1              0.000003 syn region	vimAutoCmdBlock	contained	matchgroup=vimSep start="{" end="^\s*\zs}" contains=@vimDefBodyList
                            
                            " Echo And Execute: -- prefer strings! {{{2
                            " ================
                            " NOTE: No trailing comments
                            
    1              0.000014 syn region	vimEcho
                                  \ matchgroup=vimCommand
                                  \ start="\<ec\%[ho]\>"
                                  \ start="\<echoe\%[rr]\>"
                                  \ start="\<echom\%[sg]\>"
                                  \ start="\<echoc\%[onsole]\>"
                                  \ start="\<echon\>"
                                  \ start="\<echow\%[indow]\>"
                                  \ skip=+\\|\|\n\s*\\\|\n\s*"\\ +
                                  \ matchgroup=vimCmdSep end="|" excludenl end="$" contains=@vimContinue,@vimExprList transparent
                            
    1              0.000004 syn match	vimEchohl	"\<echohl\=\>"	skipwhite nextgroup=vimGroup,vimHLGroup,vimEchohlNone,vimOnlyHLGroup,nvimHLGroup
    1              0.000001 syn case ignore
    1              0.000001 syn keyword	vimEchohlNone	contained none
    1              0.000001 syn case match
                            
    1              0.000002 syn cluster	vimEcho	contains=vimEcho,vimEchohl
                            
    1              0.000006 syn region	vimExecute	matchgroup=vimCommand start="\<exe\%[cute]\>" skip=+\\|\|\n\s*\\\|\n\s*"\\ + matchgroup=vimCmdSep end="|" excludenl end="$" contains=@vimContinue,@vimExprList transparent
                            
                            " Maps: {{{2
                            " ====
                            " GEN_SYN_VIM: vimCommand map, START_STR='syn keyword vimMap', END_STR='skipwhite nextgroup=vimMapMod,vimMapLhs'
    1              0.000011 syn keyword vimMap cm[ap] cno[remap] im[ap] ino[remap] lm[ap] ln[oremap] nm[ap] nn[oremap] om[ap] ono[remap] smap snor[emap] tma[p] tno[remap] vm[ap] vn[oremap] xm[ap] xn[oremap] skipwhite nextgroup=vimMapMod,vimMapLhs
    1              0.000003 syn match	vimMap	"\<map\>"	skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs
    1              0.000003 syn keyword	vimMap	no[remap]	skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs
                            " GEN_SYN_VIM: vimCommand mapclear, START_STR='syn keyword vimMap', END_STR='skipwhite nextgroup=vimMapMod'
    1              0.000006 syn keyword vimMap cmapc[lear] imapc[lear] lmapc[lear] nmapc[lear] omapc[lear] smapc[lear] tmapc[lear] vmapc[lear] xmapc[lear] skipwhite nextgroup=vimMapMod
    1              0.000002 syn keyword	vimMap	mapc[lear]	skipwhite nextgroup=vimMapBang,vimMapMod
                            " GEN_SYN_VIM: vimCommand unmap, START_STR='syn keyword vimUnmap', END_STR='skipwhite nextgroup=vimMapMod,vimMapLhs'
    1              0.000007 syn keyword vimUnmap cu[nmap] iu[nmap] lu[nmap] nun[map] ou[nmap] sunm[ap] tunma[p] vu[nmap] xu[nmap] skipwhite nextgroup=vimMapMod,vimMapLhs
    1              0.000031 syn keyword	vimUnmap	unm[ap]	skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs
                            
    1              0.000005 syn match	vimMapLhs	contained	"\%(.\|\S\)\+"		contains=vimCtrlChar,vimNotation,vimMapLeader skipwhite        nextgroup=vimMapRhs
    1              0.000004 syn match	vimMapLhs	contained	"\%(.\|\S\)\+\ze\s*$"	contains=vimCtrlChar,vimNotation,vimMapLeader skipwhite skipnl nextgroup=vimMapRhsContinue
    1              0.000002 syn match	vimMapBang	contained	"\a\@1<=!"		skipwhite nextgroup=vimMapMod,vimMapLhs
    1              0.000007 syn match	vimMapMod	contained	"\%#=1<\%(buffer\|expr\|nowait\|script\|silent\|special\|unique\)\+>" contains=vimMapModKey,vimMapModErr skipwhite nextgroup=vimMapMod,vimMapLhs
    1              0.000455 syn region	vimMapRhs	contained	start="\S" 	        skip=+\\|\|\@1<=|\|\n\s*\\\|\n\s*"\\ + end="|" end="$" contains=@vimContinue,vimCtrlChar,vimNotation,vimMapLeader skipnl nextgroup=vimMapRhsContinue
                            " assume a continuation comment introduces the RHS
    1              0.000008 syn region	vimMapRhsContinue	contained	start=+^\s*\%(\\\|"\\ \)+ skip=+\\|\|\@1<=|\|\n\s*\\\|\n\s*"\\ + end="|" end="$" contains=@vimContinue,vimCtrlChar,vimNotation,vimMapLeader
    1              0.000003 syn match	vimMapLeader	contained	"\%#=1\c<\%(local\)\=leader>"	contains=vimMapLeaderKey
    1              0.000002 syn keyword	vimMapModKey	contained	buffer expr nowait script silent special unique
    1              0.000001 syn case ignore
    1              0.000001 syn keyword	vimMapLeaderKey	contained	leader localleader
    1              0.000001 syn case match
                            
                            " Menus: {{{2
                            " =====
                            " NOTE: tail comments disallowed
                            " GEN_SYN_VIM: vimCommand menu, START_STR='syn keyword vimMenu', END_STR='skipwhite nextgroup=vimMenuBang,vimMenuMod,vimMenuName,vimMenuPriority,vimMenuStatus'
    1              0.000018 syn keyword vimMenu am[enu] an[oremenu] aun[menu] cme[nu] cnoreme[nu] cunme[nu] ime[nu] inoreme[nu] iunme[nu] me[nu] nme[nu] nnoreme[nu] noreme[nu] nunme[nu] ome[nu] onoreme[nu] ounme[nu] sme[nu] snoreme[nu] sunme[nu] tlm[enu] tln[oremenu] tlu[nmenu] tm[enu] tu[nmenu] unme[nu] vme[nu] vnoreme[nu] vunme[nu] xme[nu] xnoreme[nu] xunme[nu] skipwhite nextgroup=vimMenuBang,vimMenuMod,vimMenuName,vimMenuPriority,vimMenuStatus
    1              0.000002 syn keyword vimMenu popu[p] skipwhite nextgroup=vimMenuBang,vimMenuName
    1              0.000006 syn region	vimMenuRhs	 contained contains=@vimContinue,vimNotation start="|\@!\S"            skip=+\\\\\|\\|\|\n\s*\\\|\n\s*"\\ + end="$" matchgroup=vimSep end="|"
    1              0.000006 syn region	vimMenuRhsContinue contained contains=@vimContinue,vimNotation start=+^\s*\%(\\\|"\\ \)+ skip=+\\\\\|\\|\|\n\s*\\\|\n\s*"\\ + end="$" matchgroup=vimSep end="|"
    1              0.000008 syn match	vimMenuName	"\.\@!\%(\\\s\|\S\)\+"        contained contains=vimMenuNotation,vimNotation skipwhite        nextgroup=vimCmdSep,vimMenuRhs
    1              0.000004 syn match	vimMenuName	"\.\@!\%(\\\s\|\S\)\+\ze\s*$" contained contains=vimMenuNotation,vimNotation skipwhite skipnl nextgroup=vimCmdSep,vimMenuRhsContinue
    1              0.000002 syn match	vimMenuNotation	"&\a\|&&\|\\\s\|\\\." contained
    1              0.000003 syn match	vimMenuPriority	"\<\d\+\%(\.\d\+\)*\>" contained skipwhite nextgroup=vimMenuName
    1              0.000005 syn match	vimMenuMod	"\c<\%(script\|silent\|special\)>" contained skipwhite nextgroup=vimMenuName,vimMenuPriority,vimMenuMod contains=vimMapModKey,vimMapModErr
    1              0.000002 syn keyword	vimMenuStatus	enable disable nextgroup=vimMenuName skipwhite
    1              0.000002 syn match	vimMenuBang	"\a\@1<=!" contained skipwhite nextgroup=vimMenuName,vimMenuMod
                            
    1              0.000011 syn region	vimMenutranslate
                                  \ matchgroup=vimCommand start="\<menut\%[ranslate]\>"
                                  \ skip=+\\\\\|\\|\|\n\s*\\\|\n\s*"\\ +
                                  \ end="$" matchgroup=vimCmdSep end="|" matchgroup=vimMenuClear end="\<clear\ze\s*\%(["#|]\|$\)"
                                  \ contains=@vimContinue,vimMenutranslateName keepend transparent
                            " oneline is sufficient to match the current formatting in runtime/lang/*.vim
    1              0.000003 syn match	vimMenutranslateName "\%(\\\s\|\S\)\+" contained contains=vimMenuNotation,vimNotation
    1              0.000002 syn match	vimMenutranslateComment +".*+ contained containedin=vimMenutranslate
                            
                            " Angle-Bracket Notation: (tnx to Michael Geddes) {{{2
                            " ======================
    1              0.000001 syn case ignore
    1              0.000024 syn match	vimNotation	contained	"\%#=1\%(\\\|<lt>\)\=<\%([scamd]-\)\{0,4}x\=\%(f\d\{1,2}\|[^ \t:]\|space\|bar\|bslash\|nl\|newline\|lf\|linefeed\|cr\|retu\%[rn]\|enter\|k\=del\%[ete]\|bs\|backspace\|tab\|esc\|csi\|right\|paste\%(start\|end\)\|left\|help\|undo\|k\=insert\|ins\|mouse\|[kz]\=home\|[kz]\=end\|kplus\|kminus\|kdivide\|kmultiply\|kenter\|kpoint\|space\|k\=\%(page\)\=\%(\|down\|up\|k\d\>\)\)>" contains=vimBracket
                            
    1              0.000006 syn match	vimNotation	contained	"\%#=1\%(\\\|<lt>\)\=<\%([scamd2-4]-\)\{0,4}\%(net\|dec\|jsb\|pterm\|urxvt\|sgr\)mouse>"		contains=vimBracket
    1              0.000005 syn match	vimNotation	contained	"\%#=1\%(\\\|<lt>\)\=<\%([scamd2-4]-\)\{0,4}\%(left\|middle\|right\)\%(mouse\|drag\|release\)>"	contains=vimBracket
    1              0.000004 syn match	vimNotation	contained	"\%#=1\%(\\\|<lt>\)\=<\%([scamd2-4]-\)\{0,4}left\%(mouse\|release\)nm>"			contains=vimBracket
    1              0.000004 syn match	vimNotation	contained	"\%#=1\%(\\\|<lt>\)\=<\%([scamd2-4]-\)\{0,4}x[12]\%(mouse\|drag\|release\)>"		contains=vimBracket
    1              0.000003 syn match	vimNotation	contained	"\%#=1\%(\\\|<lt>\)\=<\%([scamd2-4]-\)\{0,4}sgrmouserelease>"			contains=vimBracket
    1              0.000004 syn match	vimNotation	contained	"\%#=1\%(\\\|<lt>\)\=<\%([scamd2-4]-\)\{0,4}mouse\%(up\|down\|move\)>"			contains=vimBracket
    1              0.000007 syn match	vimNotation	contained	"\%#=1\%(\\\|<lt>\)\=<\%([scamd2-4]-\)\{0,4}scrollwheel\%(up\|down\|right\|left\)>"		contains=vimBracket
                            
    1              0.000003 syn match	vimNotation	contained	"\%#=1\%(\\\|<lt>\)\=<\%(sid\|nop\|nul\|lt\|drop\)>"				contains=vimBracket
    1              0.000005 syn match	vimNotation	contained	"\%#=1\%(\\\|<lt>\)\=<\%(snr\|plug\|cursorhold\|ignore\|cmd\|scriptcmd\|focus\%(gained\|lost\)\)>"	contains=vimBracket
    1              0.000003 syn match	vimNotation	contained	'\%(\\\|<lt>\)\=<C-R>[0-9a-z"%#:.\-=]'he=e-1				contains=vimBracket
    1              0.000006 syn match	vimNotation	contained	'\%#=1\%(\\\|<lt>\)\=<\%(q-\)\=\%(line[12]\|count\|bang\|reg\|args\|mods\|f-args\|f-mods\|lt\)>'	contains=vimBracket
    1              0.000006 syn match	vimNotation	contained	"\%#=1\%(\\\|<lt>\)\=<\%([cas]file\|abuf\|amatch\|cexpr\|cword\|cWORD\|client\|stack\|script\|sf\=lnum\)>"	contains=vimBracket
    1              0.000005 syn match	vimNotation	contained	"\%#=1\%(\\\|<lt>\)\=<\%([scamd]-\)\{0,4}char-\%(\d\+\|0\o\+\|0x\x\+\)>"		contains=vimBracket
                            
    1              0.000001 syn match	vimBracket contained	"[\\<>]"
    1              0.000001 syn case match
                            
                            " User Function Highlighting: {{{2
                            " (following Gautam Iyer's suggestion)
                            " ==========================
    1              0.000008 syn match	vimFunc              	"\%(\%([sSgGbBwWtTlL]:\|<[sS][iI][dD]>\)\=\%(\w\+\.\)*\I[a-zA-Z0-9_.]*\)\ze\s*("                	skipwhite nextgroup=vimOperParen contains=vimFuncEcho,vimFuncName,vimUserFunc,vimExecute
    1              0.000008 syn match	vimUserFunc	contained        	"\%(\%([sSgGbBwWtTlL]:\|<[sS][iI][dD]>\)\=\%(\w\+\.\)*\I[a-zA-Z0-9_.]*\)\|\<\u[a-zA-Z0-9.]*\>\|\<if\>"	contains=vimNotation,vim9MethodName,vim9Super,vim9This
    1              0.000001 syn keyword	vimFuncEcho	contained      	ec ech echo
                            
    1              0.000003 syn match	vimMap	"\<map\%(\s\+(\)\@="	skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs
                            
                            " User Command Highlighting: {{{2
    1              0.000005 syn match vimUsrCmd	'^\s*\zs\u\%(\w*\)\@>\%([(#[]\|\s\+\%([-+*/%]\=\|\.\.\)=\)\@!'
                            
                            " Vim user commands
                            
                            " Compiler plugins
    1              0.000002 syn match	vimCompilerSet	"\<CompilerSet\>"	skipwhite nextgroup=vimSetArgs
                            
                            " runtime/makemenu.vim
    1              0.000002 syn match	vimSynMenu		"\<SynMenu\>"	skipwhite nextgroup=vimSynMenuPath
    1              0.000003 syn match	vimSynMenuPath	contained	".*\ze:"	nextgroup=vimSynMenuColon contains=vimMenuNotation
    1              0.000002 syn match	vimSynMenuColon	contained	":"	nextgroup=vimSynMenuName
    1              0.000001 syn match	vimSynMenuName	contained	"\w\+"
                            
    1              0.000002 syn cluster vimExUserCmdList contains=vimCompilerSet,vimSynMenu
                            
                            " Errors And Warnings: {{{2
                            " ====================
    1              0.000005 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimfunctionerror")
    1              0.000004  syn match	vimFunctionError	"\s\zs[a-z0-9]\i\{-}\ze\s*("			contained contains=vimFuncKey,vimFuncBlank
    1              0.000005  syn match	vimFunctionError	"\s\zs\%(<[sS][iI][dD]>\|[sSgGbBwWtTlL]:\)\d\i\{-}\ze\s*("	contained contains=vimFuncKey,vimFuncBlank
    1              0.000002  syn match	vimElseIfErr	"\<else\s\+if\>"
    1              0.000003  syn match	vimBufnrWarn	/\<bufnr\s*(\s*["']\.['"]\s*)/
    1              0.000001 endif
                            
    1              0.000005 syn match	vimNotFunc	"\%#=1\<\%(if\|el\%[seif]\|retu\%[rn]\|while\)\>"	skipwhite nextgroup=@vimExprList,vimNotation
                            
                            " Match: {{{2
                            " =====
    1              0.000004 syn match	vimMatch		"\<[23]\=mat\%[ch]\>" skipwhite nextgroup=vimMatchGroup,vimMatchNone
    1              0.000003 syn match	vimMatchGroup	contained	"[[:alnum:]._-]\+"    skipwhite nextgroup=vimMatchPattern
    1              0.000001 syn case ignore
    1              0.000001 syn keyword	vimMatchNone	contained	none
    1              0.000001 syn case match
    1              0.000006 syn region	vimMatchPattern	contained	matchgroup=Delimiter start="\z([!#$%&'()*+,-./:;<=>?@[\]^_`{}~]\)" skip="\\\\\|\\\z1" end="\z1" contains=@vimSubstList oneline
                            
                            " Normal: {{{2
                            " ======
    1              0.000003 syn match	vimNormal		"\<norm\%[al]\>!\=" skipwhite nextgroup=vimNormalArg contains=vimBang
    1              0.000004 syn region	vimNormalArg	contained	start="\S" skip=+\n\s*\\\|\n\s*["#]\\ + end="$" contains=@vimContinue
                            
                            " Sleep: {{{2
                            " =====
    1              0.000003 syn keyword	vimSleep		sl[eep]		skipwhite nextgroup=vimSleepBang,vimSleepArg
    1              0.000002 syn match	vimSleepBang	contained	"\a\@1<=!"		skipwhite nextgroup=vimSleepArg
    1              0.000002 syn match	vimSleepArg	contained	"\<\%(\d\+\)\=m\=\>"
                            
                            " Syntax: {{{2
                            "=======
    1              0.000005 syn match	vimGroupList	contained	"[^[:space:],]\+\%(\s*,\s*[^[:space:],]\+\)*" contains=vimGroupSpecial
    1              0.000009 syn region	vimGroupList	contained	start=/^\s*["#]\\ \|^\s*\\\|[^[:space:],]\+\s*,/ skip=/\s*\n\s*\\\|\s*\n\s*["#]\\ \|^\s*\\\|^\s*["#]\\ / end=/[^[:space:],]\s*$\|[^[:space:],]\ze\s\+\w/ contains=@vimContinue,vimGroupSpecial
    1              0.000001 syn keyword	vimGroupSpecial	contained	ALL	ALLBUT	CONTAINED	TOP
                            
    1              0.000003 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimsynerror")
    1              0.000001  syn match	vimSynError	contained	"\i\+"
    1              0.000002  syn match	vimSynError	contained	"\i\+="	nextgroup=vimGroupList
    1              0.000001 endif
    1              0.000003 syn match	vimSynContains	contained	"\<contain\%(s\|edin\)="	skipwhite skipnl nextgroup=vimGroupList
    1              0.000002 syn match	vimSynKeyContainedin	contained	"\<containedin="	skipwhite skipnl nextgroup=vimGroupList
    1              0.000002 syn match	vimSynNextgroup	contained	"\<nextgroup="		skipwhite skipnl nextgroup=vimGroupList
    1              0.000002 if has("conceal")
                             " no whitespace allowed after '='
    1              0.000002  syn match	vimSynCchar	contained	"\<cchar="	nextgroup=vimSynCcharValue
    1              0.000001  syn match	vimSynCcharValue	contained	"\S"
    1              0.000000 endif
                            
    1              0.000004 syn match	vimSyntax	"\<sy\%[ntax]\>"	contains=vimCommand skipwhite nextgroup=vimSynType,@vimComment
    1              0.000002 syn cluster vimFuncBodyList add=vimSyntax
                            
                            " Syntax: case {{{2
    1              0.000002 syn keyword	vimSynType	contained	case	skipwhite nextgroup=vimSynCase,vimSynCaseError
    1              0.000002 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimsyncaseerror")
    1              0.000001  syn match	vimSynCaseError	contained	"\i\+"
    1              0.000000 endif
    1              0.000001 syn keyword	vimSynCase	contained	ignore	match
                            
                            " Syntax: clear {{{2
    1              0.000002 syn keyword	vimSynType	contained	clear	skipwhite nextgroup=vimGroupList
                            
                            " Syntax: cluster {{{2
    1              0.000002 syn keyword	vimSynType	contained	cluster	skipwhite nextgroup=vimClusterName
    1              0.000008 syn region	vimClusterName	contained keepend	matchgroup=vimGroupName start="\h\w*\>" skip=+\\\\\|\\\|\n\s*\\\|\n\s*"\\ + matchgroup=vimCmdSep end="$\||" contains=@vimContinue,vimGroupAdd,vimGroupRem,vimSynContains,vimSynError
    1              0.000002 syn match	vimGroupAdd	contained keepend	"\<add="	skipwhite skipnl nextgroup=vimGroupList
    1              0.000002 syn match	vimGroupRem	contained keepend	"\<remove="	skipwhite skipnl nextgroup=vimGroupList
                            
                            " Syntax: foldlevel {{{2
    1              0.000004 syn keyword	vimSynType	contained	foldlevel	skipwhite nextgroup=vimSynFoldMethod,vimSynFoldMethodError
    1              0.000003 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimsynfoldmethoderror")
    1              0.000001  syn match	vimSynFoldMethodError	contained	"\i\+"
    1              0.000000 endif
    1              0.000001 syn keyword	vimSynFoldMethod	contained	start	minimum
                            
                            " Syntax: iskeyword {{{2
    1              0.000001 syn keyword	vimSynType	contained	iskeyword	skipwhite nextgroup=vimIskList
    1              0.000002 syn match	vimIskList	contained	'\S\+'	contains=vimIskSep
    1              0.000001 syn match	vimIskSep	contained	','
                            
                            " Syntax: include {{{2
    1              0.000001 syn keyword	vimSynType	contained	include	skipwhite nextgroup=vimGroupList
                            
                            " Syntax: keyword {{{2
    1              0.000004 syn cluster	vimSynKeyGroup	contains=@vimContinue,vimSynCchar,vimSynNextgroup,vimSynKeyOpt,vimSynKeyContainedin
    1              0.000020 syn keyword	vimSynType	contained	keyword	skipwhite nextgroup=vimSynKeyRegion
    1              0.000006 syn region	vimSynKeyRegion	contained         keepend	matchgroup=vimGroupName start="\h\w*\>" skip=+\\\\\|\\|\|\n\s*\\\|\n\s*"\\ + matchgroup=vimCmdSep end="|\|$" contains=@vimSynKeyGroup
    1              0.000005 syn match	vimSynKeyOpt	contained	"\%#=1\<\(conceal\|contained\|transparent\|skipempty\|skipwhite\|skipnl\)\>"
                            
                            " Syntax: match {{{2
    1              0.000005 syn cluster	vimSynMtchGroup	contains=@vimContinue,vimSynCchar,vimSynContains,vimSynError,vimSynMtchOpt,vimSynNextgroup,vimSynRegPat,vimNotation,vimMtchComment
    1              0.000002 syn keyword	vimSynType	contained	match	skipwhite nextgroup=vimSynMatchRegion
    1              0.000005 syn region	vimSynMatchRegion	contained keepend	matchgroup=vimGroupName start="\h\w*\>" skip=+\\\\\|\\|\|\n\s*\\\|\n\s*"\\ + matchgroup=vimCmdSep end="|\|$" contains=@vimSynMtchGroup
    1              0.000006 syn match	vimSynMtchOpt	contained	"\%#=1\<\(conceal\|transparent\|contained\|excludenl\|keepend\|skipempty\|skipwhite\|display\|extend\|skipnl\|fold\)\>"
                            
                            " Syntax: off and on {{{2
    1              0.000002 syn keyword	vimSynType	contained	enable	list	manual	off	on	reset
                            
                            " Syntax: region {{{2
    1              0.000006 syn cluster	vimSynRegPatGroup	contains=@vimContinue,vimPatSep,vimNotPatSep,vimSynPatRange,vimSynNotPatRange,vimSubstSubstr,vimPatRegion,vimPatSepErr,vimNotation
    1              0.000004 syn cluster	vimSynRegGroup	contains=@vimContinue,vimSynCchar,vimSynContains,vimSynNextgroup,vimSynRegOpt,vimSynReg,vimSynMtchGrp
    1              0.000001 syn keyword	vimSynType	contained	region	skipwhite nextgroup=vimSynRegion
    1              0.000005 syn region	vimSynRegion	contained keepend	matchgroup=vimGroupName start="\h\w*" skip=+\\\\\|\\\|\n\s*\\\|\n\s*"\\ + end="|\|$" contains=@vimSynRegGroup
    1              0.000007 syn match	vimSynRegOpt	contained	"\%#=1\<\(conceal\(ends\)\=\|transparent\|contained\|excludenl\|skipempty\|skipwhite\|display\|keepend\|oneline\|extend\|skipnl\|fold\)\>"
    1              0.000003 syn match	vimSynReg	contained	"\<\%(start\|skip\|end\)="	nextgroup=vimSynRegPat
    1              0.000003 syn match	vimSynMtchGrp	contained	"matchgroup="	nextgroup=vimGroup,vimHLGroup,vimOnlyHLGroup,nvimHLGroup
    1              0.000007 syn region	vimSynRegPat	contained extend	start="\z([-`~!@#$%^&*_=+;:'",./?]\)"  skip=/\\\\\|\\\z1\|\n\s*\\\|\n\s*"\\ /  end="\z1"  contains=@vimSynRegPatGroup skipwhite nextgroup=vimSynPatMod,vimSynReg
    1              0.000004 syn match	vimSynPatMod	contained	"\%#=1\(hs\|ms\|me\|hs\|he\|rs\|re\)=[se]\([-+]\d\+\)\="
    1              0.000004 syn match	vimSynPatMod	contained	"\%#=1\(hs\|ms\|me\|hs\|he\|rs\|re\)=[se]\([-+]\d\+\)\=," nextgroup=vimSynPatMod
    1              0.000001 syn match	vimSynPatMod	contained	"lc=\d\+"
    1              0.000002 syn match	vimSynPatMod	contained	"lc=\d\+," nextgroup=vimSynPatMod
    1              0.000003 syn region	vimSynPatRange	contained	start="\["	skip="\\\\\|\\]"   end="]"
    1              0.000001 syn match	vimSynNotPatRange	contained	"\\\\\|\\\["
    1              0.000002 syn match	vimMtchComment	contained	'"[^"]\+$'
                            
                            " Syntax: sync {{{2
                            " ============
    1              0.000004 syn keyword vimSynType	contained	sync	skipwhite	nextgroup=vimSyncC,vimSyncLines,vimSyncMatch,vimSyncError,vimSyncLinebreak,vimSyncLinecont,vimSyncRegion
    1              0.000003 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimsyncerror")
    1              0.000001  syn match	vimSyncError	contained	"\i\+"
    1              0.000000 endif
    1              0.000001 syn keyword	vimSyncC	contained	ccomment	clear	fromstart
    1              0.000002 syn keyword	vimSyncMatch	contained	match	skipwhite	nextgroup=vimSyncGroupName
    1              0.000033 syn keyword	vimSyncRegion	contained	region	skipwhite	nextgroup=vimSynReg
    1              0.000002 syn match	vimSyncLinebreak	contained	"\<linebreaks="	skipwhite	nextgroup=vimNumber
    1              0.000004 syn keyword	vimSyncLinecont	contained	linecont	skipwhite	nextgroup=vimSynRegPat
    1              0.000020 syn match	vimSyncLines	contained	"\(min\|max\)\=lines="	nextgroup=vimNumber
    1              0.000002 syn match	vimSyncGroupName	contained	"\h\w*"	skipwhite	nextgroup=vimSyncKey
    1              0.000003 syn match	vimSyncKey	contained	"\<groupthere\|grouphere\>"	skipwhite nextgroup=vimSyncGroup
    1              0.000019 syn match	vimSyncGroup	contained	"\h\w*"	skipwhite	nextgroup=vimSynRegPat,vimSyncNone
    1              0.000001 syn keyword	vimSyncNone	contained	NONE
                            
                            " Additional IsCommand: here by reasons of precedence {{{2
                            " ====================
    1              0.000002 syn match	vimIsCommand	"<Bar>\s*\a\+"	transparent contains=vimCommand,vimNotation
                            
                            " Highlighting: {{{2
                            " ============
    1              0.000003 syn cluster	vimHighlightCluster		contains=vimHiLink,vimHiClear,vimHiKeyList,@vimComment
    1              0.000003 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimhictermerror")
    1              0.000001  syn match	vimHiCtermError	contained	"\D\i*"
    1              0.000000 endif
    1              0.000004 syn match	vimHighlight	"\<hi\%[ghlight]\>"	skipwhite nextgroup=vimHiBang,@vimHighlightCluster
    1              0.000002 syn match	vimHiBang	contained	"\a\@1<=!"	skipwhite nextgroup=@vimHighlightCluster
                            
    1              0.000001 syn match	vimHiGroup	contained	"\i\+"
    1              0.000001 syn case ignore
    1              0.000005 syn keyword	vimHiAttrib	contained	none bold inverse italic nocombine reverse standout strikethrough underline undercurl underdashed underdotted underdouble
    1              0.000002 syn keyword	vimFgBgAttrib	contained	none bg background fg foreground
    1              0.000000 syn case match
    1              0.000002 syn match	vimHiAttribList	contained	"\i\+"	contains=vimHiAttrib
    1              0.000002 syn match	vimHiAttribList	contained	"\i\+,"he=e-1	contains=vimHiAttrib nextgroup=vimHiAttribList
    1              0.000001 syn case ignore
    1              0.000009 syn keyword	vimHiCtermColor	contained	black blue brown cyan darkblue darkcyan darkgray darkgreen darkgrey darkmagenta darkred darkyellow gray green grey grey40 grey50 grey90 lightblue lightcyan lightgray lightgreen lightgrey lightmagenta lightred lightyellow magenta red seagreen white yellow
    1              0.000002 syn match	vimHiCtermColor	contained	"\<color\d\{1,3}\>"
                            
    1              0.000000 syn case match
    1              0.000002 syn match	vimHiFontname	contained	"[a-zA-Z\-*]\+"
    1              0.000002 syn match	vimHiGuiFontname	contained	"'[a-zA-Z\-* ]\+'"
    1              0.000001 syn match	vimHiGuiRgb	contained	"#\x\{6}"
                            
                            " Highlighting: hi group key=arg ... {{{2
    1              0.000007 syn cluster	vimHiCluster contains=vimGroup,vimHiBlend,vimHiGroup,vimHiTerm,vimHiCTerm,vimHiStartStop,vimHiCtermFgBg,vimHiCtermul,vimHiCtermfont,vimHiGui,vimHiGuiFont,vimHiGuiFgBg,vimHiKeyError,vimNotation,vimComment,vim9comment
    1              0.000006 syn region	vimHiKeyList	contained 	start="\i\+" skip=+\\\\\|\\|\|\n\s*\\\|\n\s*"\\ + matchgroup=vimCmdSep end="|" excludenl end="$" contains=@vimContinue,@vimHiCluster
    1              0.000002 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_vimhikeyerror")
    1              0.000001  syn match	vimHiKeyError	contained	"\i\+="he=e-1
    1              0.000000 endif
    1              0.000002 syn match	vimHiTerm	contained	"\cterm="he=e-1		nextgroup=vimHiAttribList
    1              0.000003 syn match	vimHiStartStop	contained	"\c\%(start\|stop\)="he=e-1	nextgroup=vimHiTermcap,vimOption
    1              0.000002 syn match	vimHiCTerm	contained	"\ccterm="he=e-1		nextgroup=vimHiAttribList
    1              0.000003 syn match	vimHiCtermFgBg	contained	"\ccterm[fb]g="he=e-1	nextgroup=vimHiNmbr,vimHiCtermColor,vimFgBgAttrib,vimHiCtermError
    1              0.000003 syn match	vimHiCtermul	contained	"\cctermul="he=e-1	nextgroup=vimHiNmbr,vimHiCtermColor,vimFgBgAttrib,vimHiCtermError
    1              0.000003 syn match	vimHiCtermfont	contained	"\cctermfont="he=e-1	nextgroup=vimHiNmbr,vimHiCtermColor,vimFgBgAttrib,vimHiCtermError
    1              0.000002 syn match	vimHiGui	contained	"\cgui="he=e-1		nextgroup=vimHiAttribList
    1              0.000002 syn match	vimHiGuiFont	contained	"\cfont="he=e-1		nextgroup=vimHiFontname
    1              0.000004 syn match	vimHiGuiFgBg	contained	"\cgui\%([fb]g\|sp\)="he=e-1	nextgroup=vimHiGroup,vimHiGuiFontname,vimHiGuiRgb,vimFgBgAttrib
    1              0.000002 syn match	vimHiTermcap	contained	"\S\+"		contains=vimNotation
    1              0.000002 syn match	vimHiBlend	contained	"\cblend="he=e-1		nextgroup=vimHiNmbr
    1              0.000001 syn match	vimHiNmbr	contained	'\d\+'
                            
                            " Highlight: clear {{{2
    1              0.000002 syn keyword	vimHiClear	contained	clear	skipwhite nextgroup=vimGroup,vimHiGroup
                            
                            " Highlight: link {{{2
                            " see tst24 (hi def vs hi) (Jul 06, 2018)
                            "syn region	vimHiLink	contained oneline matchgroup=vimCommand start="\(\<hi\%[ghlight]\s\+\)\@<=\(\(def\%[ault]\s\+\)\=link\>\|\<def\>\)" end="$"	contains=vimHiGroup,vimGroup,vimHLGroup,vimNotation
                            " TODO: simplify and allow line continuations --djk
    1              0.000012 syn region	vimHiLink	contained matchgroup=Type start="\%(\<hi\%[ghlight]!\=\s\+\)\@<=\%(\%(def\%[ault]\s\+\)\=link\>\|\<def\%[ault]\>\)" skip=+\\\\\|\\|\|\n\s*\\\|\n\s*"\\ + matchgroup=vimCmdSep end="|" excludenl end="$" contains=@vimContinue,@vimHiCluster
                            
                            " Control Characters: {{{2
                            " ==================
    1              0.000001 syn match	vimCtrlChar	"[--]"
                            
                            " Beginners - Patterns that involve ^ {{{2
                            " =========
    1              0.000015 Vim9 syn region	vim9LineComment	start=+^[ \t:]*\zs#.*$+ skip=+\n\s*\\\|\n\s*#\\ + end="$" contains=@vimCommentGroup,vimCommentString,vim9CommentTitle extend
    1              0.000011 VimL syn region	vimLineComment	start=+^[ \t:]*\zs".*$+ skip=+\n\s*\\\|\n\s*"\\ + end="$" contains=@vimCommentGroup,vimCommentString,vimCommentTitle extend
                            
    1              0.000006 syn match	vimCommentTitle	'"\s*\%([sS]:\|\h\w*#\)\=\u\w*\(\s\+\u\w*\)*:'hs=s+1	contained contains=vimCommentTitleLeader,vimTodo,@vimCommentGroup
    1              0.000005 syn match	vim9CommentTitle	'#\s*\%([sS]:\|\h\w*#\)\=\u\w*\(\s\+\u\w*\)*:'hs=s+1	contained contains=vim9CommentTitleLeader,vimTodo,@vimCommentGroup
                            
                            " allowed anywhere in the file
    1              0.000001 if !s:vim9script
    1              0.000002   syn match	vimShebangError	"^\s*\zs#!.*" display
    1              0.000000 endif
    1              0.000001 syn match	vimShebang	"\%^#!.*" display
                            
    1              0.000001 syn match	vimContinue		"^\s*\zs\\"
    1              0.000002 syn match	vimContinueComment	'^\s*\zs["#]\\ .*' extend
    1              0.000016 syn match	vim9ContinueComment	"^\s*\zs#\\ .*"	 extend
    1              0.000002 syn cluster	vimContinue	contains=vimContinue,vimContinueComment
    1              0.000002 syn cluster	vim9Continue	contains=vimContinue,vim9ContinueComment
                            
    1              0.000037 syn region	vimString	start="^\s*\\\z(['"]\)" skip='\\\\\|\\\z1' end="\z1" oneline keepend contains=@vimStringGroup,vimContinue
    1              0.000002 syn match	vimCommentTitleLeader	'"\s\+'ms=s+1	contained
    1              0.000001 syn match	vim9CommentTitleLeader	'#\s\+'ms=s+1	contained
                            
                            " Searches And Globals: {{{2
                            " ====================
    1              0.000023 VimL syn match	vimSearch	'^\s*[/?].*'		contains=vimSearchDelim
    1              0.000002 syn match	vimSearchDelim	'^\s*\zs[/?]\|[/?]$'	contained
    1              0.000022 Vim9 syn match	vim9Search	'^\s*:[/?].*'		contains=vim9SearchDelim
    1              0.000002 syn match	vim9SearchDelim	'^\s*\zs:[/?]\|[/?]$'	contained contains=vimCmdSep
    1              0.000007 syn region	vimGlobal	matchgroup=Statement start='\<g\%[lobal]!\=/'  skip='\\.' end='/'	skipwhite nextgroup=vimSubst1
    1              0.000004 syn region	vimGlobal	matchgroup=Statement start='\<v\%[global]!\=/' skip='\\.' end='/'	skipwhite nextgroup=vimSubst1
                            
                            " Vim9 Script Regions: {{{2
                            " ==================
                            
    1              0.000001 if s:vim9script
                              syn cluster vimLegacyTop	contains=TOP,vim9LegacyHeader,vim9Comment,vim9LineComment
                              VimFoldH syn region vim9LegacyHeader start="\%^" end="^\ze\s*vim9s\%[cript]\>" contains=@vimLegacyTop,vimComment,vimLineComment
                            
                              syn keyword vim9Vim9ScriptArg	noclear contained
                              syn keyword vim9Vim9Script	vim9s[cript] nextgroup=vim9Vim9ScriptArg skipwhite
    1              0.000001 endif
                            
                            " Embedded Scripts:  {{{2
                            " ================
                            "   perl,ruby     : Benoit Cerrina
                            "   python,tcl    : Johannes Zellner
                            "   mzscheme, lua : Charles Campbell
                            
                            " Allows users to specify the type of embedded script highlighting
                            " they want:  (perl/python/ruby/tcl support)
                            "   g:vimsyn_embed == 0   : don't embed any scripts
                            "   g:vimsyn_embed =~# 'l' : embed Lua
                            "   g:vimsyn_embed =~# 'm' : embed MzScheme
                            "   g:vimsyn_embed =~# 'p' : embed Perl
                            "   g:vimsyn_embed =~# 'P' : embed Python
                            "   g:vimsyn_embed =~# 'r' : embed Ruby
                            "   g:vimsyn_embed =~# 't' : embed Tcl
    1              0.000002 if !exists("g:vimsyn_embed")
    1              0.000002  let g:vimsyn_embed = 'l'
    1              0.000000 endif
                            
                            " [-- lua --] {{{3
    1              0.000021 let s:luapath= fnameescape(expand("<sfile>:p:h")."/lua.vim")
    1              0.000038 if !filereadable(s:luapath)
                             for s:luapath in split(globpath(&rtp,"syntax/lua.vim"),"\n")
                              if filereadable(fnameescape(s:luapath))
                               let s:luapath= fnameescape(s:luapath)
                               break
                              endif
                             endfor
    1              0.000000 endif
    1              0.000018 if g:vimsyn_embed =~# 'l' && filereadable(s:luapath)
    1              0.000002  unlet! b:current_syntax
    1              0.000003  syn cluster vimFuncBodyList	add=vimLuaRegion
    1   0.000972   0.000291  exe "syn include @vimLuaScript ".s:luapath
    1              0.000010  VimFoldl syn region vimLuaRegion matchgroup=vimScriptDelim start=+^\z(\s*\)lua\s*<<\s*trim\s\+\z(\S\+\)+ end=+^\z1\z2$+	contains=@vimLuaScript
    1              0.000005  VimFoldl syn region vimLuaRegion matchgroup=vimScriptDelim start=+lua\s*<<\s*\z(\S*\)+ end=+^\z1$+		contains=@vimLuaScript
    1              0.000005  VimFoldl syn region vimLuaRegion matchgroup=vimScriptDelim start=+^\z(\s*\)lua\s*<<\s*trim\s*$+ end=+^\z1\.$+	contains=@vimLuaScript
    1              0.000004  VimFoldl syn region vimLuaRegion matchgroup=vimScriptDelim start=+lua\s*<<\s*$+ end=+^\.$+		contains=@vimLuaScript
    1              0.000002  syn cluster vimFuncBodyList	add=vimLuaRegion
                            else
                             syn region vimEmbedError start=+^\z(\s*\)lua\s*<<\s*trim\s\+\z(\S\+\)+ end=+^\z1\z2$+
                             syn region vimEmbedError start=+lua\s*<<\s*\z(\S*\)+ end=+^\z1$+
                             syn region vimEmbedError start=+^\z(\s*\)lua\s*<<\s*trim\s\*$+ end=+^\z1\.$+
                             syn region vimEmbedError start=+lua\s*<<\s*$+ end=+^\.$+
    1              0.000000 endif
    1              0.000001 unlet s:luapath
                            
                            " [-- perl --] {{{3
    1              0.000014 let s:perlpath= fnameescape(expand("<sfile>:p:h")."/perl.vim")
    1              0.000031 if !filereadable(s:perlpath)
                             for s:perlpath in split(globpath(&rtp,"syntax/perl.vim"),"\n")
                              if filereadable(fnameescape(s:perlpath))
                               let s:perlpath= fnameescape(s:perlpath)
                               break
                              endif
                             endfor
    1              0.000000 endif
    1              0.000003 if g:vimsyn_embed =~# 'p' && filereadable(s:perlpath)
                             unlet! b:current_syntax
                             syn cluster vimFuncBodyList	add=vimPerlRegion
                             let s:foldmethod = &l:foldmethod
                             exe "syn include @vimPerlScript ".s:perlpath
                             let &l:foldmethod = s:foldmethod
                             VimFoldp syn region vimPerlRegion	matchgroup=vimScriptDelim start=+^\z(\s*\)pe\%[rl]\s*<<\s*trim\s\+\z(\S\+\)+ end=+^\z1\z2$+	contains=@vimPerlScript
                             VimFoldp syn region vimPerlRegion	matchgroup=vimScriptDelim start=+pe\%[rl]\s*<<\s*\z(\S*\)+ end=+^\z1$+		contains=@vimPerlScript
                             VimFoldp syn region vimPerlRegion	matchgroup=vimScriptDelim start=+^\z(\s*\)pe\%[rl]\s*<<\s*trim\s*$+ end=+^\z1\.$+	contains=@vimPerlScript
                             VimFoldp syn region vimPerlRegion	matchgroup=vimScriptDelim start=+pe\%[rl]\s*<<\s*$+ end=+\.$+		contains=@vimPerlScript
                             syn cluster vimFuncBodyList	add=vimPerlRegion
    1              0.000000 else
    1              0.000005  syn region vimEmbedError start=+^\z(\s*\)pe\%[rl]\s*<<\s*trim\s\+\z(\S\+\)+ end=+^\z1\z2$+
    1              0.000003  syn region vimEmbedError start=+pe\%[rl]\s*<<\s*\z(\S*\)+ end=+^\z1$+
    1              0.000003  syn region vimEmbedError start=+^\z(\s*\)pe\%[rl]\s*<<\s*trim\s\*$+ end=+^\z1\.$+
    1              0.000003  syn region vimEmbedError start=+pe\%[rl]\s*<<\s*$+ end=+^\.$+
    1              0.000000 endif
    1              0.000001 unlet s:perlpath
                            
                            " [-- ruby --] {{{3
    1              0.000009 let s:rubypath= fnameescape(expand("<sfile>:p:h")."/ruby.vim")
    1              0.000026 if !filereadable(s:rubypath)
                             for s:rubypath in split(globpath(&rtp,"syntax/ruby.vim"),"\n")
                              if filereadable(fnameescape(s:rubypath))
                               let s:rubypath= fnameescape(s:rubypath)
                               break
                              endif
                             endfor
    1              0.000000 endif
    1              0.000002 if g:vimsyn_embed =~# 'r' && filereadable(s:rubypath)
                             syn cluster vimFuncBodyList	add=vimRubyRegion
                             unlet! b:current_syntax
                             let s:foldmethod = &l:foldmethod
                             exe "syn include @vimRubyScript ".s:rubypath
                             let &l:foldmethod = s:foldmethod
                             VimFoldr syn region vimRubyRegion	matchgroup=vimScriptDelim start=+^\z(\s*\)rub\%[y]\s*<<\s*trim\s\+\z(\S\+\)+ end=+^\z1\z2$+	contains=@vimRubyScript
                             VimFoldr syn region vimRubyRegion	matchgroup=vimScriptDelim start=+rub\%[y]\s*<<\s*\z(\S*\)+ end=+^\z1$+		contains=@vimRubyScript
                             VimFoldr syn region vimRubyRegion	matchgroup=vimScriptDelim start=+^\z(\s*\)rub\%[y]\s*<<\s*trim\s*$+ end=+^\z1\.$+	contains=@vimRubyScript
                             VimFoldr syn region vimRubyRegion	matchgroup=vimScriptDelim start=+rub\%[y]\s*<<\s*$+ end=+\.$+		contains=@vimRubyScript
                             syn cluster vimFuncBodyList	add=vimRubyRegion
    1              0.000000 else
    1              0.000004  syn region vimEmbedError start=+^\z(\s*\)rub\%[y]\s*<<\s*trim\s\+\z(\S\+\)+ end=+^\z1\z2$+
    1              0.000003  syn region vimEmbedError start=+rub\%[y]\s*<<\s*\z(\S.*\)+ end=+^\z1$+
    1              0.000006  syn region vimEmbedError start=+^\z(\s*\)rub\%[y]\s*<<\s*trim\s\*$+ end=+^\z1\.$+
    1              0.000002  syn region vimEmbedError start=+rub\%[y]\s*<<\s*$+ end=+^\.$+
    1              0.000000 endif
    1              0.000001 unlet s:rubypath
                            
                            " [-- python --] {{{3
    1              0.000009 let s:pythonpath= fnameescape(expand("<sfile>:p:h")."/python.vim")
    1              0.000025 if !filereadable(s:pythonpath)
                             for s:pythonpath in split(globpath(&rtp,"syntax/python.vim"),"\n")
                              if filereadable(fnameescape(s:pythonpath))
                               let s:pythonpath= fnameescape(s:pythonpath)
                               break
                              endif
                             endfor
    1              0.000000 endif
    1              0.000002 if g:vimsyn_embed =~# 'P' && filereadable(s:pythonpath)
                             unlet! b:current_syntax
                             syn cluster vimFuncBodyList	add=vimPythonRegion
                             exe "syn include @vimPythonScript ".s:pythonpath
                             VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+^\z(\s*\)py\%[thon][3x]\=\s*<<\s*trim\s\+\z(\S\+\)+ end=+^\z1\z2$+	contains=@vimPythonScript
                             VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+py\%[thon][3x]\=\s*<<\s*\z(\S\+\)+ end=+^\z1$+		contains=@vimPythonScript
                             VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+^\z(\s*\)py\%[thon][3x]\=\s*<<\s*trim\s*$+ end=+^\z1\.$+	contains=@vimPythonScript
                             VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+py\%[thon][3x]\=\s*<<\s*$+ end=+^\.$+			contains=@vimPythonScript
                             VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+Py\%[thon]2or3\s*<<\s*\%(trim\s*\)\=\z(\S\+\)+ end=+^\z1$+	contains=@vimPythonScript
                             VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+Py\%[thon]2or3\s*<<\s*\%(trim\s*\)\=$+ end=+^\.$+		contains=@vimPythonScript
                             syn cluster vimFuncBodyList	add=vimPythonRegion
    1              0.000000 else
    1              0.000005  syn region vimEmbedError start=+^\z(\s*\)py\%[thon][3x]\=\s*<<\s*trim\s\+\z(\S\+\)+ end=+^\z1\z2$+
    1              0.000003  syn region vimEmbedError start=+py\%[thon][3x]\=\s*<<\s*\z(\S\+\)+ end=+^\z1$+
    1              0.000004  syn region vimEmbedError start=+^\z(\s*\)py\%[thon][3x]\=\s*<<\s*trim\s*$+ end=+^\z1\.$+
    1              0.000003  syn region vimEmbedError start=+py\%[thon][3x]\=\s*<<\s*$+ end=+^\.$+
    1              0.000000 endif
    1              0.000001 unlet s:pythonpath
                            
                            " [-- tcl --] {{{3
    1              0.000006 if has("win32") || has("win95") || has("win64") || has("win16")
                             " apparently has("tcl") has been hanging vim on some windows systems with cygwin
                             let s:trytcl= (&shell !~ '\<\%(bash\>\|4[nN][tT]\|\<zsh\)\>\%(\.exe\)\=$')
    1              0.000000 else
    1              0.000001  let s:trytcl= 1
    1              0.000000 endif
    1              0.000001 if s:trytcl
    1              0.000008  let s:tclpath= fnameescape(expand("<sfile>:p:h")."/tcl.vim")
    1              0.000057  if !filereadable(s:tclpath)
                              for s:tclpath in split(globpath(&rtp,"syntax/tcl.vim"),"\n")
                               if filereadable(fnameescape(s:tclpath))
                                let s:tclpath= fnameescape(s:tclpath)
                                break
                               endif
                              endfor
    1              0.000001  endif
    1              0.000002  if g:vimsyn_embed =~# 't' && filereadable(s:tclpath)
                              unlet! b:current_syntax
                              syn cluster vimFuncBodyList	add=vimTclRegion
                              exe "syn include @vimTclScript ".s:tclpath
                              VimFoldt syn region vimTclRegion matchgroup=vimScriptDelim start=+^\z(\s*\)tc\%[l]\s*<<\s*trim\s\+\z(\S\+\)+ end=+^\z1\z2$+	contains=@vimTclScript
                              VimFoldt syn region vimTclRegion matchgroup=vimScriptDelim start=+tc\%[l]\=\s*<<\s*\z(\S*\)+ end=+^\z1$+		contains=@vimTclScript
                              VimFoldt syn region vimTclRegion matchgroup=vimScriptDelim start=+^\z(\s*\)tc\%[l]\s*<<\s*trim\s*$+ end=+^\z1\.$+	contains=@vimTclScript
                              VimFoldt syn region vimTclRegion matchgroup=vimScriptDelim start=+tc\%[l]\=\s*<<\s*$+ end=+^\.$+		contains=@vimTclScript
                              syn cluster vimFuncBodyList	add=vimTclScript
    1              0.000001  else
    1              0.000004   syn region vimEmbedError start=+^\z(\s*\)tc\%[l]\s*<<\s*trim\s\+\z(\S\+\)+ end=+^\z1\z2$+
    1              0.000003   syn region vimEmbedError start=+tc\%[l]\=\s*<<\s*\z(\S*\)+ end=+^\z1$+
    1              0.000020   syn region vimEmbedError start=+^\z(\s*\)tc\%[l]\s*<<\s*trim\s\*$+ end=+^\z1\.$+
    1              0.000003   syn region vimEmbedError start=+tc\%[l]\=\s*<<\s*$+ end=+^\.$+
    1              0.000000  endif
    1              0.000001  unlet s:tclpath
                            else
                             syn region vimEmbedError start=+^\z(\s*\)tc\%[l]\s*<<\s*trim\s\+\z(\S\+\)+ end=+^\z1\z2$+
                             syn region vimEmbedError start=+tc\%[l]\=\s*<<\s*\z(\S*\)+ end=+^\z1$+
                             syn region vimEmbedError start=+^\z(\s*\)tc\%[l]\s*<<\s*trim\s\*$+ end=+^\z1\.$+
                             syn region vimEmbedError start=+tc\%[l]\=\s*<<\s*$+ end=+^\.$+
    1              0.000000 endif
    1              0.000001 unlet s:trytcl
                            
                            " [-- mzscheme --] {{{3
    1              0.000009 let s:mzschemepath= fnameescape(expand("<sfile>:p:h")."/scheme.vim")
    1              0.000025 if !filereadable(s:mzschemepath)
                             for s:mzschemepath in split(globpath(&rtp,"syntax/mzscheme.vim"),"\n")
                              if filereadable(fnameescape(s:mzschemepath))
                               let s:mzschemepath= fnameescape(s:mzschemepath)
                               break
                              endif
                             endfor
    1              0.000000 endif
    1              0.000002 if g:vimsyn_embed =~# 'm' && filereadable(s:mzschemepath)
                             unlet! b:current_syntax
                             let s:iskKeep= &isk
                             syn cluster vimFuncBodyList	add=vimMzSchemeRegion
                             exe "syn include @vimMzSchemeScript ".s:mzschemepath
                             let &isk= s:iskKeep
                             unlet s:iskKeep
                             VimFoldm syn region vimMzSchemeRegion matchgroup=vimScriptDelim start=+^\z(\s*\)mz\%[scheme]\s*<<\s*trim\s\+\z(\S\+\)+ end=+^\z1\z2$+	contains=@vimMzSchemeScript
                             VimFoldm syn region vimMzSchemeRegion matchgroup=vimScriptDelim start=+mz\%[scheme]\s*<<\s*\z(\S*\)+ end=+^\z1$+	contains=@vimMzSchemeScript
                             VimFoldm syn region vimMzSchemeRegion matchgroup=vimScriptDelim start=+^\z(\s*\)mz\%[scheme]\s*<<\s*trim\s*$+ end=+^\z1\.$+	contains=@vimMzSchemeScript
                             VimFoldm syn region vimMzSchemeRegion matchgroup=vimScriptDelim start=+mz\%[scheme]\s*<<\s*$+ end=+^\.$+		contains=@vimMzSchemeScript
                             syn cluster vimFuncBodyList	add=vimMzSchemeRegion
    1              0.000000 else
    1              0.000005  syn region vimEmbedError start=+^\z(\s*\)mz\%[scheme]\s*<<\s*trim\s\+\z(\S\+\)+ end=+^\z1\z2$+
    1              0.000003  syn region vimEmbedError start=+mz\%[scheme]\s*<<\s*\z(\S*\)+ end=+^\z1$+
    1              0.000003  syn region vimEmbedError start=+^\z(\s*\)mz\%[scheme]\s*<<\s*trim\s\*$+ end=+^\z1\.$+
    1              0.000003  syn region vimEmbedError start=+mz\%[scheme]\s*<<\s*$+ end=+^\.$+
    1              0.000000 endif
    1              0.000001 unlet s:mzschemepath
                            
                            " Synchronize (speed) {{{2
                            "============
    1              0.000002 if exists("g:vimsyn_minlines")
                             exe "syn sync minlines=".g:vimsyn_minlines
    1              0.000000 endif
    1              0.000004 exe "syn sync maxlines=".s:vimsyn_maxlines
    1              0.000002 syn sync linecont	"^\s\+\\"
    1              0.000001 syn sync linebreaks=1
    1              0.000004 syn sync match vimAugroupSyncA	groupthere NONE	"\<aug\%[roup]\>\s\+[eE][nN][dD]"
                            
                            " ====================
                            " Highlighting Settings {{{2
                            " ====================
                            
    1              0.000002 if !exists("skip_vim_syntax_inits")
    1              0.000001  if !exists("g:vimsyn_noerror")
    1              0.000001   hi def link vimBehaveError	vimError
    1              0.000001   hi def link vimCollClassErr	vimError
    1              0.000001   hi def link vimErrSetting	vimError
    1              0.000001   hi def link vimEmbedError	Normal
    1              0.000001   hi def link vimFTError	vimError
    1              0.000001   hi def link vimFunctionError	vimError
    1              0.000001   hi def link vimFunc         	vimError
    1              0.000001   hi def link vimHiAttribList	vimError
    1              0.000001   hi def link vimHiCtermError	vimError
    1              0.000001   hi def link vimHiKeyError	vimError
    1              0.000001   hi def link vimMapModErr	vimError
    1              0.000001   hi def link vimShebangError	vimError
    1              0.000001   hi def link vimSubstFlagErr	vimError
    1              0.000001   hi def link vimSynCaseError	vimError
    1              0.000001   hi def link vimSynFoldMethodError	vimError
    1              0.000001   hi def link vimBufnrWarn	vimWarn
                            
    1              0.000001   hi def link vim9TypeAliasError	vimError
    1              0.000000  endif
                            
    1              0.000001  hi def link vimAbb	vimCommand
    1              0.000001  hi def link vimAddress	vimMark
    1              0.000001  hi def link vimAugroupBang	vimBang
    1              0.000001  hi def link vimAugroupError	vimError
    1              0.000001  hi def link vimAugroupKey	vimCommand
    1              0.000001  hi def link vimAutoCmd	vimCommand
    1              0.000001  hi def link vimAutoCmdBang	vimBang
    1              0.000001  hi def link vimAutoEvent	Type
    1              0.000001  hi def link vimAutoCmdMod	Special
    1              0.000001  hi def link vimBang	vimOper
    1              0.000001  hi def link vimBehaveBang	vimBang
    1              0.000001  hi def link vimBehaveModel	vimBehave
    1              0.000001  hi def link vimBehave	vimCommand
    1              0.000001  hi def link vimBracket	Delimiter
    1              0.000001  hi def link vimCall	vimCommand
    1              0.000001  hi def link vimCatch	vimCommand
    1              0.000001  hi def link vimCmplxRepeat	SpecialChar
    1              0.000001  hi def link vimCommand	Statement
    1              0.000001  hi def link vimComment	Comment
    1              0.000001  hi def link vimCommentError	vimError
    1              0.000001  hi def link vimCommentString	vimString
    1              0.000001  hi def link vimCommentTitle	PreProc
    1              0.000001  hi def link vimCondHL	vimCommand
    1              0.000001  hi def link vimConst	vimCommand
    1              0.000001  hi def link vimContinue	Special
    1              0.000001  hi def link vimContinueComment	vimComment
    1              0.000001  hi def link vimCount	Number
    1              0.000001  hi def link vimCtrlChar	SpecialChar
    1              0.000001  hi def link vimDebuggreedy	vimCommand
    1              0.000001  hi def link vimDefComment	vim9Comment
    1              0.000001  hi def link vimDefKey	vimCommand
    1              0.000001  hi def link vimDefParam	vimVar
    1              0.000001  hi def link vimDelcommand	vimCommand
    1              0.000001  hi def link vimDelcommandAttr	vimUserCmdAttr
    1              0.000001  hi def link vimEcho	vimCommand
    1              0.000001  hi def link vimEchohlNone	vimGroup
    1              0.000001  hi def link vimEchohl	vimCommand
    1              0.000001  hi def link vimElseIfErr	Error
    1              0.000001  hi def link vimEndfunction	vimCommand
    1              0.000001  hi def link vimEnddef	vimCommand
    1              0.000001  hi def link vimEnvvar	PreProc
    1              0.000001  hi def link vimError	Error
    1              0.000001  hi def link vimEscape	Special
    1              0.000001  hi def link vimFBVar	vimVar
    1              0.000001  hi def link vimFgBgAttrib	vimHiAttrib
    1              0.000001  hi def link vimFuncEcho	vimCommand
    1              0.000001  hi def link vimFor	vimCommand
    1              0.000001  hi def link vimForInContinue	vimContinue
    1              0.000001  hi def link vimForInContinueComment	vimContinueComment
    1              0.000001  hi def link vimFTCmd	vimCommand
    1              0.000001  hi def link vimFTOption	vimSynType
    1              0.000001  hi def link vimFuncBang	vimBang
    1              0.000001  hi def link vimFuncComment	vimComment
    1              0.000001  hi def link vimFuncKey	vimCommand
    1              0.000001  hi def link vimFuncName	Function
    1              0.000001  hi def link vimFuncMod	Special
    1              0.000001  hi def link vimFuncParam	vimVar
    1              0.000001  hi def link vimFuncParamEquals	vimOper
    1              0.000001  hi def link vimFuncScope	vimVar
    1              0.000001  hi def link vimFuncSID	vimNotation
    1              0.000001  hi def link vimGroupAdd	vimSynOption
    1              0.000001  hi def link vimGroupName	vimGroup
    1              0.000001  hi def link vimGroupRem	vimSynOption
    1              0.000001  hi def link vimGroupSpecial	Special
    1              0.000001  hi def link vimGroup	Type
    1              0.000001  hi def link vimHiAttrib	PreProc
    1              0.000001  hi def link vimHiBang	vimBang
    1              0.000001  hi def link vimHiBlend	vimHiTerm
    1              0.000001  hi def link vimHiClear	Type
    1              0.000001  hi def link vimHiCtermColor	Constant
    1              0.000001  hi def link vimHiCtermFgBg	vimHiTerm
    1              0.000001  hi def link vimHiCtermfont	vimHiTerm
    1              0.000003  hi def link vimHiCtermul	vimHiTerm
    1              0.000001  hi def link vimHiCTerm	vimHiTerm
    1              0.000001  hi def link vimHighlight	vimCommand
    1              0.000001  hi def link vimHiGroup	vimGroupName
    1              0.000001  hi def link vimHiGuiFgBg	vimHiTerm
    1              0.000001  hi def link vimHiGuiFont	vimHiTerm
    1              0.000001  hi def link vimHiGuiRgb	vimNumber
    1              0.000001  hi def link vimHiGui	vimHiTerm
    1              0.000001  hi def link vimHiNmbr	Number
    1              0.000001  hi def link vimHiStartStop	vimHiTerm
    1              0.000001  hi def link vimHiTerm	Type
    1              0.000001  hi def link vimHLGroup	vimGroup
    1              0.000001  hi def link vimInsert	vimString
    1              0.000001  hi def link vimIskSep	Delimiter
    1              0.000001  hi def link vim9KeymapLineComment	vimKeymapLineComment
    1              0.000001  hi def link vimKeymapLineComment	vimComment
    1              0.000033  hi def link vimKeymapTailComment	vimComment
    1              0.000001  hi def link vimLambdaOperator	vimOper
    1              0.000001  hi def link vimLet	vimCommand
    1              0.000001  hi def link vimLetHereDoc	vimString
    1              0.000001  hi def link vimLetHereDocStart	Special
    1              0.000001  hi def link vimLetHereDocStop	Special
    1              0.000001  hi def link vimLetRegister	Special
    1              0.000001  hi def link vimLineComment	vimComment
    1              0.000001  hi def link vimMapBang	vimBang
    1              0.000001  hi def link vimMapLeader	vimBracket
    1              0.000001  hi def link vimMapLeaderKey	vimNotation
    1              0.000001  hi def link vimMapModKey	vimFuncSID
    1              0.000001  hi def link vimMapMod	vimBracket
    1              0.000001  hi def link vimMap	vimCommand
    1              0.000001  hi def link vimMark	Number
    1              0.000001  hi def link vimMarkNumber	vimNumber
    1              0.000001  hi def link vimMatch	vimCommand
    1              0.000001  hi def link vimMatchGroup	vimGroup
    1              0.000001  hi def link vimMatchNone	vimGroup
    1              0.000001  hi def link vimMenuBang	vimBang
    1              0.000001  hi def link vimMenuClear	Special
    1              0.000001  hi def link vimMenuMod	vimMapMod
    1              0.000001  hi def link vimMenuName	PreProc
    1              0.000001  hi def link vimMenu	vimCommand
    1              0.000001  hi def link vimMenuNotation	vimNotation
    1              0.000001  hi def link vimMenuPriority	Number
    1              0.000001  hi def link vimMenuStatus	Special
    1              0.000001  hi def link vimMenutranslateComment	vimComment
    1              0.000001  hi def link vim9MethodName	vimFuncName
    1              0.000001  hi def link vimMtchComment	vimComment
    1              0.000017  hi def link vimNormal	vimCommand
    1              0.000001  hi def link vimNotation	Special
    1              0.000001  hi def link vimNotFunc	vimCommand
    1              0.000001  hi def link vimNotPatSep	vimString
    1              0.000001  hi def link vimNumber	Number
    1              0.000001  hi def link vimOperError	Error
    1              0.000001  hi def link vimOper	Operator
    1              0.000001  hi def link vimOperContinue	vimContinue
    1              0.000001  hi def link vimOperContinueComment	vimContinueComment
    1              0.000001  hi def link vimOption	PreProc
    1              0.000001  hi def link vimOptionVar	Identifier
    1              0.000001  hi def link vimVimVar	Identifier
    1              0.000001  hi def link vimParenSep	Delimiter
    1              0.000001  hi def link vimPatSepErr	vimError
    1              0.000001  hi def link vimPatSepR	vimPatSep
    1              0.000001  hi def link vimPatSep	SpecialChar
    1              0.000001  hi def link vimPatSepZone	vimString
    1              0.000001  hi def link vimPatSepZ	vimPatSep
    1              0.000001  hi def link vimPattern	Type
    1              0.000001  hi def link vimPlainMark	vimMark
    1              0.000001  hi def link vimPlainRegister	vimRegister
    1              0.000001  hi def link vimQuoteEscape	vimEscape
    1              0.000001  hi def link vimRegister	SpecialChar
    1              0.000001  hi def link vimScriptDelim	Comment
    1              0.000001  hi def link vimSearch	vimString
    1              0.000001  hi def link vimSearchDelim	Delimiter
    1              0.000001  hi def link vimSep	Delimiter
    1              0.000001  hi def link vimSet	vimCommand
    1              0.000001  hi def link vimSetAll	vimOption
    1              0.000001  hi def link vimSetBang	vimBang
    1              0.000001  hi def link vimSetMod	vimOption
    1              0.000001  hi def link vimSetSep	vimSep
    1              0.000001  hi def link vimSetString	vimString
    1              0.000001  hi def link vimSetTermcap	vimOption
    1              0.000001  hi def link vimShebang	PreProc
    1              0.000001  hi def link vimSleep	vimCommand
    1              0.000001  hi def link vimSleepArg	Constant
    1              0.000001  hi def link vimSleepBang	vimBang
    1              0.000001  hi def link vimSpecFile	Identifier
    1              0.000001  hi def link vimSpecFileMod	vimSpecFile
    1              0.000001  hi def link vimSpecial	Type
    1              0.000001  hi def link vimStringCont	vimString
    1              0.000001  hi def link vimString	String
    1              0.000001  hi def link vimStringEnd	vimString
    1              0.000001  hi def link vimStringInterpolationBrace	vimEscape
    1              0.000001  hi def link vimSubst1	vimSubst
    1              0.000001  hi def link vimSubstDelim	Delimiter
    1              0.000001  hi def link vimSubstFlags	Special
    1              0.000001  hi def link vimSubstSubstr	SpecialChar
    1              0.000001  hi def link vimSubstTwoBS	vimString
    1              0.000001  hi def link vimSubst	vimCommand
    1              0.000001  hi def link vimSynCaseError	Error
    1              0.000001  hi def link vimSynCase	Type
    1              0.000001  hi def link vimSyncC	Type
    1              0.000001  hi def link vimSyncError	Error
    1              0.000001  hi def link vimSyncGroupName	vimGroupName
    1              0.000001  hi def link vimSyncGroup	vimGroupName
    1              0.000001  hi def link vimSyncKey	Type
    1              0.000001  hi def link vimSyncNone	Type
    1              0.000001  hi def link vimSynContains	vimSynOption
    1              0.000001  hi def link vimSynError	Error
    1              0.000001  hi def link vimSynFoldMethodError	Error
    1              0.000001  hi def link vimSynFoldMethod	Type
    1              0.000001  hi def link vimSynKeyContainedin	vimSynContains
    1              0.000001  hi def link vimSynKeyOpt	vimSynOption
    1              0.000001  hi def link vimSynCchar	vimSynOption
    1              0.000001  hi def link vimSynCcharValue	Character
    1              0.000001  hi def link vimSynMtchGrp	vimSynOption
    1              0.000003  hi def link vimSynMtchOpt	vimSynOption
    1              0.000001  hi def link vimSynNextgroup	vimSynOption
    1              0.000001  hi def link vimSynNotPatRange	vimSynRegPat
    1              0.000001  hi def link vimSynOption	Special
    1              0.000001  hi def link vimSynPatRange	vimString
    1              0.000001  hi def link vimSynRegOpt	vimSynOption
    1              0.000001  hi def link vimSynRegPat	vimString
    1              0.000001  hi def link vimSynReg	Type
    1              0.000001  hi def link vimSyntax	vimCommand
    1              0.000001  hi def link vimSynType	vimSpecial
    1              0.000001  hi def link vimThrow	vimCommand
    1              0.000001  hi def link vimTodo	Todo
    1              0.000001  hi def link vimType	Type
    1              0.000001  hi def link vimUnlet	vimCommand
    1              0.000001  hi def link vimUnletBang	vimBang
    1              0.000001  hi def link vimUnmap	vimMap
    1              0.000001  hi def link vimUserCmdAttrAddr	vimSpecial
    1              0.000001  hi def link vimUserCmdAttrCmplt	vimSpecial
    1              0.000001  hi def link vimUserCmdAttrNargs	vimSpecial
    1              0.000001  hi def link vimUserCmdAttrRange	vimSpecial
    1              0.000001  hi def link vimUserCmdAttrKey	vimUserCmdAttr
    1              0.000001  hi def link vimUserCmdAttr	Special
    1              0.000001  hi def link vimUserCmdAttrError	Error
    1              0.000001  hi def link vimUserCmdError	Error
    1              0.000001  hi def link vimUserCmdKey	vimCommand
    1              0.000001  hi def link vimUserFunc	Normal
    1              0.000001  hi def link vimVar	Normal
    1              0.000001  hi def link vimWarn	WarningMsg
                            
    1              0.000001  hi def link vim9Abstract	vimCommand
    1              0.000001  hi def link vim9Boolean	Boolean
    1              0.000001  hi def link vim9Class	vimCommand
    1              0.000001  hi def link vim9Comment	Comment
    1              0.000001  hi def link vim9CommentError	vimError
    1              0.000001  hi def link vim9CommentTitle	PreProc
    1              0.000001  hi def link vim9ConstructorDefParam	vimVar
    1              0.000001  hi def link vim9Const	vimCommand
    1              0.000001  hi def link vim9ContinueComment	vimContinueComment
    1              0.000001  hi def link vim9Enum	vimCommand
    1              0.000001  hi def link vim9Export	vimCommand
    1              0.000001  hi def link vim9Extends	Keyword
    1              0.000001  hi def link vim9Final	vimCommand
    1              0.000001  hi def link vim9For	vimCommand
    1              0.000001  hi def link vim9ForInComment	vim9Comment
    1              0.000001  hi def link vim9Implements	Keyword
    1              0.000001  hi def link vim9AbstractDef	vimCommand
    1              0.000001  hi def link vim9Interface	vimCommand
    1              0.000001  hi def link vim9LambdaOperator	vimOper
    1              0.000001  hi def link vim9LambdaOperatorComment	vim9Comment
    1              0.000001  hi def link vim9LambdaParamsParen	vimParenSep
    1              0.000001  hi def link vim9LhsRegister	vimLetRegister
    1              0.000001  hi def link vim9LhsVariable	vimVar
    1              0.000001  hi def link vim9LineComment	vimComment
    1              0.000001  hi def link vim9MethodDef	vimCommand
    1              0.000001  hi def link vim9MethodNameError	vimFunctionError
    1              0.000001  hi def link vim9Null	Constant
    1              0.000001  hi def link vim9Public	vimCommand
    1              0.000001  hi def link vim9Search	vimString
    1              0.000001  hi def link vim9SearchDelim	Delimiter
    1              0.000001  hi def link vim9Static	vimCommand
    1              0.000001  hi def link vim9Super	Identifier
    1              0.000001  hi def link vim9This	Identifier
    1              0.000001  hi def link vim9Type	vimCommand
    1              0.000001  hi def link vim9TypeEquals	vimOper
    1              0.000001  hi def link vim9Variable	vimVar
    1              0.000001  hi def link vim9Var	vimCommand
    1              0.000001  hi def link vim9Vim9ScriptArg	Special
    1              0.000001  hi def link vim9Vim9Script	vimCommand
                            
    1              0.000001  hi def link vimCompilerSet	vimCommand
    1              0.000001  hi def link vimSynMenu	vimCommand
    1              0.000001  hi def link vimSynMenuPath	vimMenuName
                            
    1              0.000001  hi def link nvimAutoEvent	vimAutoEvent
    1              0.000001  hi def link nvimHLGroup	vimHLGroup
    1              0.000000 endif
                            
                            " Current Syntax Variable: {{{2
    1              0.000002 let b:current_syntax = "vim"
                            
                            " ---------------------------------------------------------------------
                            " Cleanup: {{{1
    1              0.000002 delc Vim9
    1              0.000001 delc VimL
    1              0.000001 delc VimFolda
    1              0.000001 delc VimFoldc
    1              0.000001 delc VimFolde
    1              0.000001 delc VimFoldf
    1              0.000001 delc VimFoldh
    1              0.000001 delc VimFoldH
    1              0.000001 delc VimFoldi
    1              0.000001 delc VimFoldl
    1              0.000001 delc VimFoldm
    1              0.000001 delc VimFoldp
    1              0.000001 delc VimFoldP
    1              0.000001 delc VimFoldr
    1              0.000001 delc VimFoldt
    1              0.000004 let &cpo = s:keepcpo
    1              0.000001 unlet s:keepcpo s:vim9script
                            " vim:ts=18 fdm=marker ft=vim

SCRIPT  /usr/local/Cellar/neovim/0.11.2/share/nvim/runtime/syntax/lua.vim
Sourced 1 time
Total time:   0.000670
 Self time:   0.000670

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:     Lua 4.0, Lua 5.0, Lua 5.1, Lua 5.2 and Lua 5.3
                            " Maintainer:   Marcus Aurelius Farias <masserahguard-lua 'at' yahoo com>
                            " First Author: Carlos Augusto Teixeira Mendes <cmendes 'at' inf puc-rio br>
                            " Last Change:  2025 Feb 25
                            " Options:      lua_version = 4 or 5
                            "               lua_subversion = 0 (for 4.0 or 5.0)
                            "                               or 1, 2, 3 (for 5.1, 5.2 or 5.3)
                            "               the default is 5.3
                            
                            " quit when a syntax file was already loaded
    1              0.000021 if exists("b:current_syntax")
                              finish
    1              0.000001 endif
                            
    1              0.000003 let s:cpo_save = &cpo
    1              0.000006 set cpo&vim
                            
                            " keep in sync with ftplugin/lua.vim
    1              0.000002 if !exists("lua_version")
                              " Default is lua 5.3
                              let lua_version = 5
                              let lua_subversion = 3
    1              0.000002 elseif !exists("lua_subversion")
                              " lua_version exists, but lua_subversion doesn't. In this case set it to 0
                              let lua_subversion = 0
    1              0.000000 endif
                            
    1              0.000001 syn case match
                            
                            " syncing method
    1              0.000001 syn sync minlines=1000
                            
    1              0.000001 if lua_version >= 5
    1              0.000003   syn keyword luaMetaMethod __add __sub __mul __div __pow __unm __concat
    1              0.000001   syn keyword luaMetaMethod __eq __lt __le
    1              0.000001   syn keyword luaMetaMethod __index __newindex __call
    1              0.000001   syn keyword luaMetaMethod __metatable __mode __gc __tostring
    1              0.000000 endif
                            
    1              0.000002 if lua_version > 5 || (lua_version == 5 && lua_subversion >= 1)
    1              0.000001   syn keyword luaMetaMethod __mod __len
    1              0.000000 endif
                            
    1              0.000001 if lua_version > 5 || (lua_version == 5 && lua_subversion >= 2)
    1              0.000001   syn keyword luaMetaMethod __pairs
    1              0.000000 endif
                            
    1              0.000001 if lua_version > 5 || (lua_version == 5 && lua_subversion >= 3)
    1              0.000001   syn keyword luaMetaMethod __idiv __name
    1              0.000001   syn keyword luaMetaMethod __band __bor __bxor __bnot __shl __shr
    1              0.000000 endif
                            
    1              0.000001 if lua_version > 5 || (lua_version == 5 && lua_subversion >= 4)
                              syn keyword luaMetaMethod __close
    1              0.000000 endif
                            
                            " catch errors caused by wrong parenthesis and wrong curly brackets or
                            " keywords placed outside their respective blocks
                            
    1              0.000005 syn region luaParen transparent start='(' end=')' contains=TOP,luaParenError
    1              0.000002 syn match  luaParenError ")"
    1              0.000001 syn match  luaError "}"
    1              0.000004 syn match  luaError "\<\%(end\|else\|elseif\|then\|until\|in\)\>"
                            
                            " Function declaration
    1              0.000004 syn region luaFunctionBlock transparent matchgroup=luaFunction start="\<function\>" end="\<end\>" contains=TOP
                            
                            " else
    1              0.000002 syn keyword luaCondElse matchgroup=luaCond contained containedin=luaCondEnd else
                            
                            " then ... end
    1              0.000003 syn region luaCondEnd contained transparent matchgroup=luaCond start="\<then\>" end="\<end\>" contains=TOP
                            
                            " elseif ... then
    1              0.000003 syn region luaCondElseif contained containedin=luaCondEnd transparent matchgroup=luaCond start="\<elseif\>" end="\<then\>" contains=TOP
                            
                            " if ... then
    1              0.000004 syn region luaCondStart transparent matchgroup=luaCond start="\<if\>" end="\<then\>"me=e-4 contains=TOP nextgroup=luaCondEnd skipwhite skipempty
                            
                            " do ... end
    1              0.000003 syn region luaBlock transparent matchgroup=luaStatement start="\<do\>" end="\<end\>" contains=TOP
                            " repeat ... until
    1              0.000003 syn region luaRepeatBlock transparent matchgroup=luaRepeat start="\<repeat\>" end="\<until\>" contains=TOP
                            
                            " while ... do
    1              0.000003 syn region luaWhile transparent matchgroup=luaRepeat start="\<while\>" end="\<do\>"me=e-2 contains=TOP nextgroup=luaBlock skipwhite skipempty
                            
                            " for ... do and for ... in ... do
    1              0.000003 syn region luaFor transparent matchgroup=luaRepeat start="\<for\>" end="\<do\>"me=e-2 contains=TOP nextgroup=luaBlock skipwhite skipempty
                            
    1              0.000001 syn keyword luaFor contained containedin=luaFor in
                            
                            " other keywords
    1              0.000001 syn keyword luaStatement return local break
    1              0.000001 if lua_version > 5 || (lua_version == 5 && lua_subversion >= 2)
    1              0.000001   syn keyword luaStatement goto
    1              0.000002   syn match luaLabel "::\I\i*::"
    1              0.000000 endif
                            
                            " operators
    1              0.000002 syn keyword luaOperator and or not
                            
    1              0.000002 if (lua_version == 5 && lua_subversion >= 3) || lua_version > 5
    1              0.000003   syn match luaSymbolOperator "[#<>=~^&|*/%+-]\|\.\{2,3}"
                            elseif lua_version == 5 && (lua_subversion == 1 || lua_subversion == 2)
                              syn match luaSymbolOperator "[#<>=~^*/%+-]\|\.\{2,3}"
                            else
                              syn match luaSymbolOperator "[<>=~^*/+-]\|\.\{2,3}"
    1              0.000000 endif
                            
                            " comments
    1              0.000002 syn keyword luaTodo            contained TODO FIXME XXX
    1              0.000004 syn match   luaComment         "--.*$" contains=luaTodo,@Spell
    1              0.000005 if lua_version == 5 && lua_subversion == 0
                              syn region luaComment        matchgroup=luaCommentDelimiter start="--\[\[" end="\]\]" contains=luaTodo,luaInnerComment,@Spell
                              syn region luaInnerComment   contained transparent start="\[\[" end="\]\]"
    1              0.000001 elseif lua_version > 5 || (lua_version == 5 && lua_subversion >= 1)
                              " Comments in Lua 5.1: --[[ ... ]], [=[ ... ]=], [===[ ... ]===], etc.
    1              0.000005   syn region luaComment        matchgroup=luaCommentDelimiter start="--\[\z(=*\)\[" end="\]\z1\]" contains=luaTodo,@Spell
    1              0.000000 endif
                            
                            " first line may start with #!
    1              0.000002 syn match luaComment "\%^#!.*"
                            
    1              0.000001 syn keyword luaConstant nil
    1              0.000001 if lua_version > 4
    1              0.000002   syn keyword luaConstant true false
    1              0.000000 endif
                            
                            " strings
    1              0.000004 syn match  luaSpecial contained #\\[\\abfnrtv'"[\]]\|\\[[:digit:]]\{,3}#
    1              0.000001 if lua_version == 5
    1              0.000001   if lua_subversion == 0
                                syn region luaString2 matchgroup=luaStringDelimiter start=+\[\[+ end=+\]\]+ contains=luaString2,@Spell
    1              0.000001   else
    1              0.000001     if lua_subversion >= 2
    1              0.000003       syn match  luaSpecial contained #\\z\|\\x[[:xdigit:]]\{2}#
    1              0.000000     endif
    1              0.000001     if lua_subversion >= 3
    1              0.000002       syn match  luaSpecial contained #\\u{[[:xdigit:]]\+}#
    1              0.000000     endif
    1              0.000004     syn region luaString2 matchgroup=luaStringDelimiter start="\[\z(=*\)\[" end="\]\z1\]" contains=@Spell
    1              0.000036   endif
    1              0.000001 endif
    1              0.000006 syn region luaString matchgroup=luaStringDelimiter start=+'+ end=+'+ skip=+\\\\\|\\'+ contains=luaSpecial,@Spell
    1              0.000004 syn region luaString matchgroup=luaStringDelimiter start=+"+ end=+"+ skip=+\\\\\|\\"+ contains=luaSpecial,@Spell
                            
                            " integer number
    1              0.000002 syn match luaNumber "\<\d\+\>"
                            " floating point number, with dot, optional exponent
    1              0.000004 syn match luaNumber  "\<\d\+\.\d*\%([eE][-+]\=\d\+\)\="
                            " floating point number, starting with a dot, optional exponent
    1              0.000003 syn match luaNumber  "\.\d\+\%([eE][-+]\=\d\+\)\=\>"
                            " floating point number, without dot, with exponent
    1              0.000002 syn match luaNumber  "\<\d\+[eE][-+]\=\d\+\>"
                            
                            " hex numbers
    1              0.000001 if lua_version >= 5
    1              0.000001   if lua_subversion == 1
                                syn match luaNumber "\<0[xX]\x\+\>"
    1              0.000001   elseif lua_subversion >= 2
    1              0.000004     syn match luaNumber "\<0[xX][[:xdigit:].]\+\%([pP][-+]\=\d\+\)\=\>"
    1              0.000000   endif
    1              0.000000 endif
                            
                            " tables
    1              0.000003 syn region luaTableBlock transparent matchgroup=luaTable start="{" end="}" contains=TOP,luaStatement
                            
                            " methods
    1              0.000002 syntax match luaFunc ":\@<=\k\+"
                            
                            " built-in functions
    1              0.000002 syn keyword luaFunc assert collectgarbage dofile error next
    1              0.000002 syn keyword luaFunc print rawget rawset self tonumber tostring type _VERSION
                            
    1              0.000001 if lua_version == 4
                              syn keyword luaFunc _ALERT _ERRORMESSAGE gcinfo
                              syn keyword luaFunc call copytagmethods dostring
                              syn keyword luaFunc foreach foreachi getglobal getn
                              syn keyword luaFunc gettagmethod globals newtag
                              syn keyword luaFunc setglobal settag settagmethod sort
                              syn keyword luaFunc tag tinsert tremove
                              syn keyword luaFunc _INPUT _OUTPUT _STDIN _STDOUT _STDERR
                              syn keyword luaFunc openfile closefile flush seek
                              syn keyword luaFunc setlocale execute remove rename tmpname
                              syn keyword luaFunc getenv date clock exit
                              syn keyword luaFunc readfrom writeto appendto read write
                              syn keyword luaFunc PI abs sin cos tan asin
                              syn keyword luaFunc acos atan atan2 ceil floor
                              syn keyword luaFunc mod frexp ldexp sqrt min max log
                              syn keyword luaFunc log10 exp deg rad random
                              syn keyword luaFunc randomseed strlen strsub strlower strupper
                              syn keyword luaFunc strchar strrep ascii strbyte
                              syn keyword luaFunc format strfind gsub
                              syn keyword luaFunc getinfo getlocal setlocal setcallhook setlinehook
    1              0.000001 elseif lua_version == 5
    1              0.000001   syn keyword luaFunc getmetatable setmetatable
    1              0.000001   syn keyword luaFunc ipairs pairs
    1              0.000001   syn keyword luaFunc pcall xpcall
    1              0.000001   syn keyword luaFunc _G loadfile rawequal require
    1              0.000001   if lua_subversion == 0
                                syn keyword luaFunc getfenv setfenv
                                syn keyword luaFunc loadstring unpack
                                syn keyword luaFunc gcinfo loadlib LUA_PATH _LOADED _REQUIREDNAME
    1              0.000000   else
    1              0.000001     syn keyword luaFunc load select
    1              0.000002     syn match   luaFunc /\<package\.cpath\>/
    1              0.000002     syn match   luaFunc /\<package\.loaded\>/
    1              0.000002     syn match   luaFunc /\<package\.loadlib\>/
    1              0.000002     syn match   luaFunc /\<package\.path\>/
    1              0.000002     syn match   luaFunc /\<package\.preload\>/
    1              0.000001     if lua_subversion == 1
                                  syn keyword luaFunc getfenv setfenv
                                  syn keyword luaFunc loadstring module unpack
                                  syn match   luaFunc /\<package\.loaders\>/
                                  syn match   luaFunc /\<package\.seeall\>/
    1              0.000001     elseif lua_subversion >= 2
    1              0.000001       syn keyword luaFunc _ENV rawlen
    1              0.000002       syn match   luaFunc /\<package\.config\>/
    1              0.000002       syn match   luaFunc /\<package\.preload\>/
    1              0.000002       syn match   luaFunc /\<package\.searchers\>/
    1              0.000002       syn match   luaFunc /\<package\.searchpath\>/
    1              0.000000     endif
                            
    1              0.000001     if lua_subversion >= 3
    1              0.000002       syn match luaFunc /\<coroutine\.isyieldable\>/
    1              0.000000     endif
    1              0.000001     if lua_subversion >= 4
                                  syn keyword luaFunc warn
                                  syn match luaFunc /\<coroutine\.close\>/
    1              0.000000     endif
    1              0.000002     syn match luaFunc /\<coroutine\.running\>/
    1              0.000000   endif
    1              0.000002   syn match   luaFunc /\<coroutine\.create\>/
    1              0.000002   syn match   luaFunc /\<coroutine\.resume\>/
    1              0.000002   syn match   luaFunc /\<coroutine\.status\>/
    1              0.000002   syn match   luaFunc /\<coroutine\.wrap\>/
    1              0.000002   syn match   luaFunc /\<coroutine\.yield\>/
                            
    1              0.000002   syn match   luaFunc /\<string\.byte\>/
    1              0.000002   syn match   luaFunc /\<string\.char\>/
    1              0.000002   syn match   luaFunc /\<string\.dump\>/
    1              0.000002   syn match   luaFunc /\<string\.find\>/
    1              0.000002   syn match   luaFunc /\<string\.format\>/
    1              0.000002   syn match   luaFunc /\<string\.gsub\>/
    1              0.000002   syn match   luaFunc /\<string\.len\>/
    1              0.000002   syn match   luaFunc /\<string\.lower\>/
    1              0.000002   syn match   luaFunc /\<string\.rep\>/
    1              0.000001   syn match   luaFunc /\<string\.sub\>/
    1              0.000002   syn match   luaFunc /\<string\.upper\>/
    1              0.000001   if lua_subversion == 0
                                syn match luaFunc /\<string\.gfind\>/
    1              0.000000   else
    1              0.000002     syn match luaFunc /\<string\.gmatch\>/
    1              0.000002     syn match luaFunc /\<string\.match\>/
    1              0.000002     syn match luaFunc /\<string\.reverse\>/
    1              0.000000   endif
    1              0.000001   if lua_subversion >= 3
    1              0.000005     syn match luaFunc /\<string\.pack\>/
    1              0.000002     syn match luaFunc /\<string\.packsize\>/
    1              0.000002     syn match luaFunc /\<string\.unpack\>/
    1              0.000002     syn match luaFunc /\<utf8\.char\>/
    1              0.000002     syn match luaFunc /\<utf8\.charpattern\>/
    1              0.000002     syn match luaFunc /\<utf8\.codes\>/
    1              0.000002     syn match luaFunc /\<utf8\.codepoint\>/
    1              0.000002     syn match luaFunc /\<utf8\.len\>/
    1              0.000002     syn match luaFunc /\<utf8\.offset\>/
    1              0.000000   endif
                            
    1              0.000001   if lua_subversion == 0
                                syn match luaFunc /\<table\.getn\>/
                                syn match luaFunc /\<table\.setn\>/
                                syn match luaFunc /\<table\.foreach\>/
                                syn match luaFunc /\<table\.foreachi\>/
    1              0.000001   elseif lua_subversion == 1
                                syn match luaFunc /\<table\.maxn\>/
    1              0.000001   elseif lua_subversion >= 2
    1              0.000002     syn match luaFunc /\<table\.pack\>/
    1              0.000002     syn match luaFunc /\<table\.unpack\>/
    1              0.000001     if lua_subversion >= 3
    1              0.000002       syn match luaFunc /\<table\.move\>/
    1              0.000000     endif
    1              0.000000   endif
    1              0.000002   syn match   luaFunc /\<table\.concat\>/
    1              0.000002   syn match   luaFunc /\<table\.insert\>/
    1              0.000002   syn match   luaFunc /\<table\.sort\>/
    1              0.000002   syn match   luaFunc /\<table\.remove\>/
                            
    1              0.000001   if lua_subversion == 2
                                syn match   luaFunc /\<bit32\.arshift\>/
                                syn match   luaFunc /\<bit32\.band\>/
                                syn match   luaFunc /\<bit32\.bnot\>/
                                syn match   luaFunc /\<bit32\.bor\>/
                                syn match   luaFunc /\<bit32\.btest\>/
                                syn match   luaFunc /\<bit32\.bxor\>/
                                syn match   luaFunc /\<bit32\.extract\>/
                                syn match   luaFunc /\<bit32\.lrotate\>/
                                syn match   luaFunc /\<bit32\.lshift\>/
                                syn match   luaFunc /\<bit32\.replace\>/
                                syn match   luaFunc /\<bit32\.rrotate\>/
                                syn match   luaFunc /\<bit32\.rshift\>/
    1              0.000000   endif
                            
    1              0.000002   syn match   luaFunc /\<math\.abs\>/
    1              0.000002   syn match   luaFunc /\<math\.acos\>/
    1              0.000002   syn match   luaFunc /\<math\.asin\>/
    1              0.000002   syn match   luaFunc /\<math\.atan\>/
    1              0.000001   if lua_subversion < 3
                                syn match   luaFunc /\<math\.atan2\>/
    1              0.000000   endif
    1              0.000002   syn match   luaFunc /\<math\.ceil\>/
    1              0.000001   syn match   luaFunc /\<math\.sin\>/
    1              0.000001   syn match   luaFunc /\<math\.cos\>/
    1              0.000001   syn match   luaFunc /\<math\.tan\>/
    1              0.000001   syn match   luaFunc /\<math\.deg\>/
    1              0.000001   syn match   luaFunc /\<math\.exp\>/
    1              0.000002   syn match   luaFunc /\<math\.floor\>/
    1              0.000001   syn match   luaFunc /\<math\.log\>/
    1              0.000001   syn match   luaFunc /\<math\.max\>/
    1              0.000001   syn match   luaFunc /\<math\.min\>/
    1              0.000001   if lua_subversion == 0
                                syn match luaFunc /\<math\.mod\>/
                                syn match luaFunc /\<math\.log10\>/
    1              0.000001   elseif lua_subversion == 1
                                syn match luaFunc /\<math\.log10\>/
    1              0.000000   endif
    1              0.000001   if lua_subversion >= 1
    1              0.000002     syn match luaFunc /\<math\.huge\>/
    1              0.000002     syn match luaFunc /\<math\.fmod\>/
    1              0.000002     syn match luaFunc /\<math\.modf\>/
    1              0.000001     if lua_subversion == 1 || lua_subversion == 2
                                  syn match luaFunc /\<math\.cosh\>/
                                  syn match luaFunc /\<math\.sinh\>/
                                  syn match luaFunc /\<math\.tanh\>/
    1              0.000000     endif
    1              0.000000   endif
    1              0.000002   syn match   luaFunc /\<math\.rad\>/
    1              0.000002   syn match   luaFunc /\<math\.sqrt\>/
    1              0.000001   if lua_subversion < 3
                                syn match   luaFunc /\<math\.pow\>/
                                syn match   luaFunc /\<math\.frexp\>/
                                syn match   luaFunc /\<math\.ldexp\>/
    1              0.000000   else
    1              0.000002     syn match   luaFunc /\<math\.maxinteger\>/
    1              0.000002     syn match   luaFunc /\<math\.mininteger\>/
    1              0.000002     syn match   luaFunc /\<math\.tointeger\>/
    1              0.000002     syn match   luaFunc /\<math\.type\>/
    1              0.000002     syn match   luaFunc /\<math\.ult\>/
    1              0.000000   endif
    1              0.000002   syn match   luaFunc /\<math\.random\>/
    1              0.000002   syn match   luaFunc /\<math\.randomseed\>/
    1              0.000002   syn match   luaFunc /\<math\.pi\>/
                            
    1              0.000002   syn match   luaFunc /\<io\.close\>/
    1              0.000001   syn match   luaFunc /\<io\.flush\>/
    1              0.000001   syn match   luaFunc /\<io\.input\>/
    1              0.000001   syn match   luaFunc /\<io\.lines\>/
    1              0.000001   syn match   luaFunc /\<io\.open\>/
    1              0.000001   syn match   luaFunc /\<io\.output\>/
    1              0.000001   syn match   luaFunc /\<io\.popen\>/
    1              0.000001   syn match   luaFunc /\<io\.read\>/
    1              0.000003   syn match   luaFunc /\<io\.stderr\>/
    1              0.000002   syn match   luaFunc /\<io\.stdin\>/
    1              0.000001   syn match   luaFunc /\<io\.stdout\>/
    1              0.000002   syn match   luaFunc /\<io\.tmpfile\>/
    1              0.000001   syn match   luaFunc /\<io\.type\>/
    1              0.000001   syn match   luaFunc /\<io\.write\>/
                            
    1              0.000001   syn match   luaFunc /\<os\.clock\>/
    1              0.000001   syn match   luaFunc /\<os\.date\>/
    1              0.000002   syn match   luaFunc /\<os\.difftime\>/
    1              0.000002   syn match   luaFunc /\<os\.execute\>/
    1              0.000001   syn match   luaFunc /\<os\.exit\>/
    1              0.000001   syn match   luaFunc /\<os\.getenv\>/
    1              0.000001   syn match   luaFunc /\<os\.remove\>/
    1              0.000001   syn match   luaFunc /\<os\.rename\>/
    1              0.000002   syn match   luaFunc /\<os\.setlocale\>/
    1              0.000001   syn match   luaFunc /\<os\.time\>/
    1              0.000001   syn match   luaFunc /\<os\.tmpname\>/
                            
    1              0.000002   syn match   luaFunc /\<debug\.debug\>/
    1              0.000002   syn match   luaFunc /\<debug\.gethook\>/
    1              0.000002   syn match   luaFunc /\<debug\.getinfo\>/
    1              0.000002   syn match   luaFunc /\<debug\.getlocal\>/
    1              0.000002   syn match   luaFunc /\<debug\.getupvalue\>/
    1              0.000002   syn match   luaFunc /\<debug\.setlocal\>/
    1              0.000002   syn match   luaFunc /\<debug\.setupvalue\>/
    1              0.000002   syn match   luaFunc /\<debug\.sethook\>/
    1              0.000002   syn match   luaFunc /\<debug\.traceback\>/
    1              0.000001   if lua_subversion == 1
                                syn match luaFunc /\<debug\.getfenv\>/
                                syn match luaFunc /\<debug\.setfenv\>/
    1              0.000000   endif
    1              0.000001   if lua_subversion >= 1
    1              0.000002     syn match luaFunc /\<debug\.getmetatable\>/
    1              0.000002     syn match luaFunc /\<debug\.setmetatable\>/
    1              0.000002     syn match luaFunc /\<debug\.getregistry\>/
    1              0.000001     if lua_subversion >= 2
    1              0.000002       syn match luaFunc /\<debug\.getuservalue\>/
    1              0.000002       syn match luaFunc /\<debug\.setuservalue\>/
    1              0.000002       syn match luaFunc /\<debug\.upvalueid\>/
    1              0.000002       syn match luaFunc /\<debug\.upvaluejoin\>/
    1              0.000000     endif
    1              0.000001     if lua_subversion >= 4
                                  syn match luaFunc /\<debug.setcstacklimit\>/
    1              0.000000     endif
    1              0.000000   endif
    1              0.000000 endif
                            
                            " Define the default highlighting.
                            " Only when an item doesn't have highlighting yet
                            
    1              0.000002 hi def link luaStatement        Statement
    1              0.000001 hi def link luaRepeat           Repeat
    1              0.000001 hi def link luaFor              Repeat
    1              0.000001 hi def link luaString           String
    1              0.000001 hi def link luaString2          String
    1              0.000001 hi def link luaStringDelimiter  luaString
    1              0.000001 hi def link luaNumber           Number
    1              0.000001 hi def link luaOperator         Operator
    1              0.000001 hi def link luaSymbolOperator   luaOperator
    1              0.000001 hi def link luaConstant         Constant
    1              0.000001 hi def link luaCond             Conditional
    1              0.000001 hi def link luaCondElse         Conditional
    1              0.000001 hi def link luaFunction         Function
    1              0.000001 hi def link luaMetaMethod       Function
    1              0.000001 hi def link luaComment          Comment
    1              0.000001 hi def link luaCommentDelimiter luaComment
    1              0.000001 hi def link luaTodo             Todo
    1              0.000001 hi def link luaTable            Structure
    1              0.000001 hi def link luaError            Error
    1              0.000001 hi def link luaParenError       Error
    1              0.000001 hi def link luaSpecial          SpecialChar
    1              0.000001 hi def link luaFunc             Identifier
    1              0.000001 hi def link luaLabel            Label
                            
                            
    1              0.000002 let b:current_syntax = "lua"
                            
    1              0.000004 let &cpo = s:cpo_save
    1              0.000001 unlet s:cpo_save
                            " vim: et ts=8 sw=2

SCRIPT  /usr/local/Cellar/neovim/0.11.2/share/nvim/runtime/syntax/vim/generated.vim
Sourced 1 time
Total time:   0.001290
 Self time:   0.001290

count  total (s)   self (s)
    1              0.000058 syn keyword vimCommand contained  a[ppend] ab[breviate] abc[lear] abo[veleft] al[l] am[enu] an[oremenu] ar[gs] arga[dd] argd[elete] argdo argde[dupe] arge[dit] argg[lobal] argl[ocal] argu[ment] as[cii] aun[menu] b[uffer] bN[ext] ba[ll] bad[d] bal[t] bd[elete] be[lowright] bf[irst] bl[ast] bm[odified] bn[ext] bo[tright] bp[revious] br[ewind] brea[k] breaka[dd] breakd[el] breakl[ist] bro[wse] bu[ffers] bufd[o] bun[load] bw[ipeout] c[hange] cN[ext] cNf[ile] ca[bbrev] cabc[lear] cabo[ve] cad[dbuffer] cadde[xpr] caddf[ile] caf[ter] cal[l] cat[ch] cb[uffer] cbe[fore] cbel[ow] cbo[ttom] cc ccl[ose] cd cdo ce[nter] cex[pr] cf[ile] cfd[o] cfi[rst] cg[etfile] cgetb[uffer] cgete[xpr] ch[dir] cha[nges] che[ckhealth] checkp[ath] checkt[ime] chi[story] cl[ist] cla[st] clo[se] cle[arjumps] cm[ap] cmapc[lear] cme[nu] cn[ext] cnew[er] cnf[ile] cno[remap] cnorea[bbrev] nextgroup=vimBang
    1              0.000040 syn keyword vimCommand contained  cnorem[enu] co[py] col[der] colo[rscheme] com[mand] comc[lear] comp[iler] con[tinue] conf[irm] cons[t] cop[en] cp[revious] cpf[ile] cq[uit] cr[ewind] cu[nmap] cuna[bbrev] cunm[enu] cw[indow] d[elete] dl dell delel deletl deletel dp dep delp delep deletp deletep delm[arks] deb[ug] debugg[reedy] defe[r] del[command] delf[unction] det[ach] di[splay] dif[fupdate] diffg[et] diffo[ff] diffp[atch] diffpu[t] diffs[plit] difft[his] dig[raphs] dj[ump] dl[ist] dr[op] ds[earch] dsp[lit] e[dit] ea[rlier] ec[ho] echoe[rr] echoh[l] echom[sg] echon el[se] elsei[f] em[enu] en[dif] endf[unction] endfo[r] endt[ry] endw[hile] ene[w] ev[al] ex exe[cute] exi[t] exu[sage] f[ile] files filet[ype] filt[er] fin[d] fina[lly] fini[sh] fir[st] fo[ld] foldc[lose] foldd[oopen] folddoc[losed] foldo[pen] for fu[nction] fc[lose] go[to] gr[ep] nextgroup=vimBang
    1              0.000039 syn keyword vimCommand contained  grepa[dd] gu[i] gv[im] h[elp] helpc[lose] helpg[rep] helpt[ags] hi[ghlight] hid[e] his[tory] ho[rizontal] i[nsert] ia[bbrev] iabc[lear] if ij[ump] il[ist] im[ap] imapc[lear] ime[nu] in[oremap] inorea[bbrev] inorem[enu] int[ro] is[earch] isp[lit] iu[nmap] iuna[bbrev] iunm[enu] j[oin] ju[mps] k ke[epmarks] keepj[umps] keepp[atterns] keepa[lt] l[ist] lN[ext] lNf[ile] la[st] lab[ove] lan[guage] lad[dexpr] laddb[uffer] laddf[ile] laf[ter] lat[er] lb[uffer] lbe[fore] lbel[ow] lbo[ttom] lc[d] lch[dir] lcl[ose] ld[o] le[ft] lefta[bove] let lex[pr] lf[ile] lfd[o] lfi[rst] lg[etfile] lgetb[uffer] lgete[xpr] lgr[ep] lgrepa[dd] lh[elpgrep] lhi[story] ll lla[st] lli[st] lm[ap] lmapc[lear] lmak[e] ln[oremap] lne[xt] lnew[er] lnf[ile] lo[adview] loadk[eymap] loc[kmarks] lockv[ar] lol[der] lop[en] lp[revious] lpf[ile] lr[ewind] nextgroup=vimBang
    1              0.000344 syn keyword vimCommand contained  lt[ag] lu[nmap] lua luad[o] luaf[ile] lv[imgrep] lvimgrepa[dd] lw[indow] ls m[ove] ma[rk] mak[e] map mapc[lear] mar[ks] mat[ch] me[nu] menut[ranslate] mes[sages] mk[exrc] mks[ession] mksp[ell] mkv[imrc] mkvie[w] mo[de] mz[scheme] mzf[ile] n[ext] new nm[ap] nmapc[lear] nme[nu] nn[oremap] nnoreme[nu] no[remap] noa[utocmd] noh[lsearch] nor[eabbrev] norem[enu] nos[wapfile] nor[mal] nu[mber] nun[map] nunme[nu] o[ldfiles] om[ap] omapc[lear] ome[nu] on[ly] ono[remap] onoreme[nu] op[tions] ou[nmap] ounme[nu] ow[nsyntax] p[rint] pa[ckadd] packl[oadall] pb[uffer] pc[lose] pe[rl] perld[o] perlf[ile] ped[it] po[p] popu[p] pp[op] pr[eserve] prev[ious] pro[file] profd[el] ps[earch] pt[ag] ptN[ext] ptf[irst] ptj[ump] ptl[ast] ptn[ext] ptp[revious] ptr[ewind] pts[elect] pu[t] pw[d] py[thon] pyd[o] pyf[ile] py3 py3d[o] pyt[hon3] nextgroup=vimBang
    1              0.000042 syn keyword vimCommand contained  py3[file] pyx pyxd[o] pyt[honx] pyx[file] q[uit] quita[ll] qa[ll] r[ead] rec[over] red[o] redi[r] redr[aw] redraws[tatus] redrawt[abline] reg[isters] res[ize] ret[ab] retu[rn] rew[ind] ri[ght] rightb[elow] rs[hada] ru[ntime] rund[o] rub[y] rubyd[o] rubyf[ile] rv[iminfo] sN[ext] sa[rgument] sal[l] san[dbox] sav[eas] sb[uffer] sbN[ext] sba[ll] sbf[irst] sbl[ast] sbm[odified] sbn[ext] sbp[revious] sbr[ewind] sc[riptnames] scripte[ncoding] se[t] setf[iletype] setg[lobal] setl[ocal] sf[ind] sfir[st] si[malt] sig[n] sil[ent] sl[eep] sla[st] sm[agic] smap smapc[lear] sme[nu] sn[ext] sno[magic] snor[emap] snoreme[nu] so[urce] sor[t] sp[lit] spe[llgood] spelld[ump] spelli[nfo] spellr[epall] spellra[re] spellu[ndo] spellw[rong] spr[evious] sr[ewind] st[op] sta[g] star[tinsert] startg[replace] startr[eplace] sto[pinsert] nextgroup=vimBang
    1              0.000078 syn keyword vimCommand contained  stj[ump] sts[elect] su[nhide] sunm[ap] sunme[nu] sus[pend] sv[iew] sw[apname] sy[ntax] synti[me] sync[bind] t tc[d] tch[dir] tN[ext] ta[g] tags tab tabc[lose] tabd[o] tabe[dit] tabf[ind] tabfir[st] tabm[ove] tabl[ast] tabn[ext] tabnew tabo[nly] tabp[revious] tabN[ext] tabr[ewind] tabs tc[l] tcld[o] tclf[ile] te[rminal] tf[irst] th[row] tj[ump] tl[ast] tlm[enu] tln[oremenu] tlu[nmenu] tm[enu] tma[p] tmapc[lear] tn[ext] tno[remap] to[pleft] tp[revious] tr[ewind] tru[st] try ts[elect] tu[nmenu] tunma[p] u[ndo] undoj[oin] undol[ist] una[bbreviate] unh[ide] unl[et] unlo[ckvar] unm[ap] unme[nu] uns[ilent] up[date] v[global] ve[rsion] verb[ose] vert[ical] vi[sual] vie[w] vim[grep] vimgrepa[dd] viu[sage] vm[ap] vmapc[lear] vme[nu] vn[oremap] vne[w] vno[remenu] vs[plit] vu[nmap] vunme[nu] w[rite] wN[ext] wa[ll] wh[ile] nextgroup=vimBang
    1              0.000079 syn keyword vimCommand contained  wi[nsize] winc[md] wind[o] winp[os] wn[ext] wp[revious] wq wqa[ll] ws[hada] wu[ndo] wv[iminfo] x[it] xa[ll] xm[ap] xmapc[lear] xme[nu] xn[oremap] xnoreme[nu] xu[nmap] xunme[nu] y[ank] N[ext] nextgroup=vimBang
                            
    1              0.000017 syn keyword vimOption contained  allowrevins ari invallowrevins noallowrevins invari noari ambiwidth ambw arabic arab invarabic noarabic invarab noarab arabicshape arshape invarabicshape noarabicshape invarshape noarshape autochdir acd invautochdir noautochdir invacd noacd autoindent ai invautoindent noautoindent invai noai autoread ar invautoread noautoread invar noar autowrite aw invautowrite noautowrite invaw noaw autowriteall awa invautowriteall noautowriteall invawa noawa background bg backspace bs backup bk invbackup nobackup invbk nobk backupcopy bkc backupdir bdir backupext bex backupskip bsk belloff bo binary bin invbinary nobinary invbin nobin bomb invbomb nobomb breakat brk breakindent bri invbreakindent nobreakindent invbri nobri breakindentopt briopt bufhidden bh buflisted bl invbuflisted nobuflisted invbl nobl buftype bt casemap cmp skipwhite nextgroup=vimSetEqual,vimSetMod
    1              0.000039 syn keyword vimOption contained  cdhome cdh invcdhome nocdhome invcdh nocdh cdpath cd cedit channel charconvert ccv cindent cin invcindent nocindent invcin nocin cinkeys cink cinoptions cino cinscopedecls cinsd cinwords cinw clipboard cb cmdheight ch cmdwinheight cwh colorcolumn cc columns co comments com commentstring cms complete cpt completefunc cfu completeitemalign cia completeopt cot completeslash csl concealcursor cocu conceallevel cole confirm cf invconfirm noconfirm invcf nocf copyindent ci invcopyindent nocopyindent invci noci cpoptions cpo cursorbind crb invcursorbind nocursorbind invcrb nocrb cursorcolumn cuc invcursorcolumn nocursorcolumn invcuc nocuc cursorline cul invcursorline nocursorline invcul nocul cursorlineopt culopt debug define def delcombine deco invdelcombine nodelcombine invdeco nodeco dictionary dict diff invdiff nodiff skipwhite nextgroup=vimSetEqual,vimSetMod
    1              0.000019 syn keyword vimOption contained  diffexpr dex diffopt dip digraph dg invdigraph nodigraph invdg nodg directory dir display dy eadirection ead emoji emo invemoji noemoji invemo noemo encoding enc endoffile eof invendoffile noendoffile inveof noeof endofline eol invendofline noendofline inveol noeol equalalways ea invequalalways noequalalways invea noea equalprg ep errorbells eb inverrorbells noerrorbells inveb noeb errorfile ef errorformat efm eventignore ei eventignorewin eiw expandtab et invexpandtab noexpandtab invet noet exrc ex invexrc noexrc invex noex fileencoding fenc fileencodings fencs fileformat ff fileformats ffs fileignorecase fic invfileignorecase nofileignorecase invfic nofic filetype ft fillchars fcs findfunc ffu fixendofline fixeol invfixendofline nofixendofline invfixeol nofixeol foldclose fcl foldcolumn fdc foldenable fen invfoldenable nofoldenable invfen nofen skipwhite nextgroup=vimSetEqual,vimSetMod
    1              0.000019 syn keyword vimOption contained  foldexpr fde foldignore fdi foldlevel fdl foldlevelstart fdls foldmarker fmr foldmethod fdm foldminlines fml foldnestmax fdn foldopen fdo foldtext fdt formatexpr fex formatlistpat flp formatoptions fo formatprg fp fsync fs invfsync nofsync invfs nofs gdefault gd invgdefault nogdefault invgd nogd grepformat gfm grepprg gp guicursor gcr guifont gfn guifontwide gfw helpfile hf helpheight hh helplang hlg hidden hid invhidden nohidden invhid nohid highlight hl history hi hlsearch hls invhlsearch nohlsearch invhls nohls icon invicon noicon iconstring ignorecase ic invignorecase noignorecase invic noic iminsert imi imsearch ims inccommand icm include inc includeexpr inex incsearch is invincsearch noincsearch invis nois indentexpr inde indentkeys indk infercase inf invinfercase noinfercase invinf noinf isfname isf isident isi skipwhite nextgroup=vimSetEqual,vimSetMod
    1              0.000017 syn keyword vimOption contained  iskeyword isk isprint isp joinspaces js invjoinspaces nojoinspaces invjs nojs jumpoptions jop keymap kmp keymodel km keywordprg kp langmap lmap langmenu lm langnoremap lnr invlangnoremap nolangnoremap invlnr nolnr langremap lrm invlangremap nolangremap invlrm nolrm laststatus ls lazyredraw lz invlazyredraw nolazyredraw invlz nolz linebreak lbr invlinebreak nolinebreak invlbr nolbr lines linespace lsp lisp invlisp nolisp lispoptions lop lispwords lw list invlist nolist listchars lcs loadplugins lpl invloadplugins noloadplugins invlpl nolpl magic invmagic nomagic makeef mef makeencoding menc makeprg mp matchpairs mps matchtime mat maxcombine mco maxfuncdepth mfd maxmapdepth mmd maxmempattern mmp menuitems mis messagesopt mopt mkspellmem msm modeline ml invmodeline nomodeline invml noml modelineexpr mle invmodelineexpr nomodelineexpr invmle nomle skipwhite nextgroup=vimSetEqual,vimSetMod
    1              0.000016 syn keyword vimOption contained  modelines mls modifiable ma invmodifiable nomodifiable invma noma modified mod invmodified nomodified invmod nomod more invmore nomore mouse mousefocus mousef invmousefocus nomousefocus invmousef nomousef mousehide mh invmousehide nomousehide invmh nomh mousemodel mousem mousemoveevent mousemev invmousemoveevent nomousemoveevent invmousemev nomousemev mousescroll mousetime mouset nrformats nf number nu invnumber nonumber invnu nonu numberwidth nuw omnifunc ofu operatorfunc opfunc packpath pp paragraphs para paste invpaste nopaste patchexpr pex patchmode pm path pa preserveindent pi invpreserveindent nopreserveindent invpi nopi previewheight pvh previewwindow pvw invpreviewwindow nopreviewwindow invpvw nopvw pumblend pb pumheight ph pumwidth pw pyxversion pyx quickfixtextfunc qftf quoteescape qe readonly ro invreadonly noreadonly invro noro skipwhite nextgroup=vimSetEqual,vimSetMod
    1              0.000234 syn keyword vimOption contained  redrawdebug rdb redrawtime rdt regexpengine re relativenumber rnu invrelativenumber norelativenumber invrnu nornu report revins ri invrevins norevins invri nori rightleft rl invrightleft norightleft invrl norl rightleftcmd rlc ruler ru invruler noruler invru noru rulerformat ruf runtimepath rtp scroll scr scrollback scbk scrollbind scb invscrollbind noscrollbind invscb noscb scrolljump sj scrolloff so scrollopt sbo sections sect secure invsecure nosecure selection sel selectmode slm sessionoptions ssop shada sd shadafile sdf shell sh shellcmdflag shcf shellpipe sp shellquote shq shellredir srr shellslash ssl invshellslash noshellslash invssl nossl shelltemp stmp invshelltemp noshelltemp invstmp nostmp shellxescape sxe shellxquote sxq shiftround sr invshiftround noshiftround invsr nosr shiftwidth sw shortmess shm skipwhite nextgroup=vimSetEqual,vimSetMod
    1              0.000017 syn keyword vimOption contained  showbreak sbr showcmd sc invshowcmd noshowcmd invsc nosc showcmdloc sloc showfulltag sft invshowfulltag noshowfulltag invsft nosft showmatch sm invshowmatch noshowmatch invsm nosm showmode smd invshowmode noshowmode invsmd nosmd showtabline stal sidescroll ss sidescrolloff siso signcolumn scl smartcase scs invsmartcase nosmartcase invscs noscs smartindent si invsmartindent nosmartindent invsi nosi smarttab sta invsmarttab nosmarttab invsta nosta smoothscroll sms invsmoothscroll nosmoothscroll invsms nosms softtabstop sts spell invspell nospell spellcapcheck spc spellfile spf spelllang spl spelloptions spo spellsuggest sps splitbelow sb invsplitbelow nosplitbelow invsb nosb splitkeep spk splitright spr invsplitright nosplitright invspr nospr startofline sol invstartofline nostartofline invsol nosol statuscolumn stc skipwhite nextgroup=vimSetEqual,vimSetMod
    1              0.000018 syn keyword vimOption contained  statusline stl suffixes su suffixesadd sua swapfile swf invswapfile noswapfile invswf noswf switchbuf swb synmaxcol smc syntax syn tabclose tcl tabline tal tabpagemax tpm tabstop ts tagbsearch tbs invtagbsearch notagbsearch invtbs notbs tagcase tc tagfunc tfu taglength tl tagrelative tr invtagrelative notagrelative invtr notr tags tag tagstack tgst invtagstack notagstack invtgst notgst termbidi tbidi invtermbidi notermbidi invtbidi notbidi termguicolors tgc invtermguicolors notermguicolors invtgc notgc termpastefilter tpf termsync invtermsync notermsync textwidth tw thesaurus tsr thesaurusfunc tsrfu tildeop top invtildeop notildeop invtop notop timeout to invtimeout notimeout invto noto timeoutlen tm title invtitle notitle titlelen titleold titlestring ttimeout invttimeout nottimeout ttimeoutlen ttm undodir udir skipwhite nextgroup=vimSetEqual,vimSetMod
    1              0.000016 syn keyword vimOption contained  undofile udf invundofile noundofile invudf noudf undolevels ul undoreload ur updatecount uc updatetime ut varsofttabstop vsts vartabstop vts verbose vbs verbosefile vfile viewdir vdir viewoptions vop virtualedit ve visualbell vb invvisualbell novisualbell invvb novb warn invwarn nowarn whichwrap ww wildchar wc wildcharm wcm wildignore wig wildignorecase wic invwildignorecase nowildignorecase invwic nowic wildmenu wmnu invwildmenu nowildmenu invwmnu nowmnu wildmode wim wildoptions wop winaltkeys wak winbar wbr winblend winbl winborder window wi winfixbuf wfb invwinfixbuf nowinfixbuf invwfb nowfb winfixheight wfh invwinfixheight nowinfixheight invwfh nowfh winfixwidth wfw invwinfixwidth nowinfixwidth invwfw nowfw winheight wh winhighlight winhl winminheight wmh winminwidth wmw winwidth wiw wrap invwrap nowrap skipwhite nextgroup=vimSetEqual,vimSetMod
    1              0.000005 syn keyword vimOption contained  wrapmargin wm wrapscan ws invwrapscan nowrapscan invws nows write invwrite nowrite writeany wa invwriteany nowriteany invwa nowa writebackup wb invwritebackup nowritebackup invwb nowb writedelay wd skipwhite nextgroup=vimSetEqual,vimSetMod
                            
    1              0.000001 syn case ignore
                            
    1              0.000021 syn keyword vimAutoEvent contained  BufAdd BufCreate BufDelete BufEnter BufFilePost BufFilePre BufHidden BufLeave BufNew BufNewFile BufRead BufReadCmd BufReadPost BufReadPre BufUnload BufWinEnter BufWinLeave BufWipeout BufWrite BufWriteCmd BufWritePost BufWritePre ChanInfo ChanOpen CmdUndefined CmdlineChanged CmdlineEnter CmdlineLeave CmdwinEnter CmdwinLeave ColorScheme ColorSchemePre CompleteChanged CompleteDone CompleteDonePre CursorHold CursorHoldI CursorMoved CursorMovedC CursorMovedI DiffUpdated DirChanged DirChangedPre EncodingChanged ExitPre FileAppendCmd FileAppendPost FileAppendPre FileChangedRO FileChangedShell FileChangedShellPost FileEncoding FileReadCmd FileReadPost FileReadPre FileType FileWriteCmd FileWritePost FileWritePre FilterReadPost FilterReadPre FilterWritePost FilterWritePre FocusGained FocusLost FuncUndefined GUIEnter
    1              0.000013 syn keyword vimAutoEvent contained  GUIFailed InsertChange InsertCharPre InsertEnter InsertLeave InsertLeavePre MenuPopup ModeChanged OptionSet QuickFixCmdPost QuickFixCmdPre QuitPre RemoteReply SafeState SearchWrapped SessionLoadPost SessionWritePost ShellCmdPost ShellFilterPost SourceCmd SourcePost SourcePre SpellFileMissing StdinReadPost StdinReadPre SwapExists Syntax TabClosed TabEnter TabLeave TabNew TermChanged TermEnter TermLeave TermResponse TextChanged TextChangedI TextChangedP TextChangedT TextYankPost User VimEnter VimLeave VimLeavePre VimResized VimResume VimSuspend WinClosed WinEnter WinLeave WinNew WinResized WinScrolled
                            
    1              0.000005 syn keyword nvimAutoEvent contained  BufModifiedSet DiagnosticChanged LspAttach LspDetach LspNotify LspProgress LspRequest LspTokenUpdate RecordingEnter RecordingLeave Signal TabNewEntered TermClose TermOpen TermRequest UIEnter UILeave
                            
    1              0.000001 syn case match
                            
    1              0.000013 syn keyword vimFuncName contained  abs acos add and api_info append appendbufline argc argidx arglistid argv asin assert_beeps assert_equal assert_equalfile assert_exception assert_fails assert_false assert_inrange assert_match assert_nobeep assert_notequal assert_notmatch assert_report assert_true atan atan2 blob2list browse browsedir bufadd bufexists buffer_exists buffer_name buffer_number buflisted bufload bufloaded bufname bufnr bufwinid bufwinnr byte2line byteidx byteidxcomp call ceil chanclose changenr chansend char2nr charclass charcol charidx chdir cindent clearmatches col complete complete_add complete_check complete_info confirm copy cos cosh count ctxget ctxpop ctxpush ctxset ctxsize cursor debugbreak deepcopy delete deletebufline dictwatcheradd dictwatcherdel did_filetype diff_filler diff_hlID digraph_get digraph_getlist digraph_set
    1              0.000012 syn keyword vimFuncName contained  digraph_setlist empty environ escape eval eventhandler executable execute exepath exists exp expand expandcmd extend extendnew feedkeys file_readable filecopy filereadable filewritable filter finddir findfile flatten flattennew float2nr floor fmod fnameescape fnamemodify foldclosed foldclosedend foldlevel foldtext foldtextresult foreach foreground fullcommand funcref function garbagecollect get getbufinfo getbufline getbufoneline getbufvar getcellwidths getchangelist getchar getcharmod getcharpos getcharsearch getcharstr getcmdcomplpat getcmdcompltype getcmdline getcmdpos getcmdprompt getcmdscreenpos getcmdtype getcmdwintype getcompletion getcurpos getcursorcharpos getcwd getenv getfontname getfperm getfsize getftime getftype getjumplist getline getloclist getmarklist getmatches getmousepos getpid getpos getqflist
    1              0.000015 syn keyword vimFuncName contained  getreg getreginfo getregion getregionpos getregtype getscriptinfo getstacktrace gettabinfo gettabvar gettabwinvar gettagstack gettext getwininfo getwinpos getwinposx getwinposy getwinvar glob glob2regpat globpath has has_key haslocaldir hasmapto highlightID highlight_exists histadd histdel histget histnr hlID hlexists hostname iconv id indent index indexof input inputdialog inputlist inputrestore inputsave inputsecret insert interrupt invert isabsolutepath isdirectory isinf islocked isnan items jobclose jobpid jobresize jobsend jobstart jobstop jobwait join json_decode json_encode keys keytrans last_buffer_nr len libcall libcallnr line line2byte lispindent list2blob list2str localtime log log10 luaeval map maparg mapcheck maplist mapnew mapset match matchadd matchaddpos matcharg matchbufline matchdelete matchend
    1              0.000023 syn keyword vimFuncName contained  matchfuzzy matchfuzzypos matchlist matchstr matchstrlist matchstrpos max menu_get menu_info min mkdir mode msgpackdump msgpackparse nextnonblank nr2char nvim__buf_debug_extmarks nvim__buf_stats nvim__complete_set nvim__get_lib_dir nvim__get_runtime nvim__id nvim__id_array nvim__id_dict nvim__id_float nvim__inspect_cell nvim__invalidate_glyph_cache nvim__ns_get nvim__ns_set nvim__redraw nvim__runtime_inspect nvim__screenshot nvim__stats nvim__unpack nvim_buf_add_highlight nvim_buf_attach nvim_buf_clear_highlight nvim_buf_clear_namespace nvim_buf_create_user_command nvim_buf_del_extmark nvim_buf_del_keymap nvim_buf_del_mark nvim_buf_del_user_command nvim_buf_del_var nvim_buf_delete nvim_buf_get_changedtick nvim_buf_get_commands nvim_buf_get_extmark_by_id nvim_buf_get_extmarks nvim_buf_get_keymap nvim_buf_get_lines
    1              0.000008 syn keyword vimFuncName contained  nvim_buf_get_mark nvim_buf_get_name nvim_buf_get_number nvim_buf_get_offset nvim_buf_get_option nvim_buf_get_text nvim_buf_get_var nvim_buf_is_loaded nvim_buf_is_valid nvim_buf_line_count nvim_buf_set_extmark nvim_buf_set_keymap nvim_buf_set_lines nvim_buf_set_mark nvim_buf_set_name nvim_buf_set_option nvim_buf_set_text nvim_buf_set_var nvim_buf_set_virtual_text nvim_call_dict_function nvim_call_function nvim_clear_autocmds nvim_cmd nvim_command nvim_command_output nvim_create_augroup nvim_create_autocmd nvim_create_buf nvim_create_namespace nvim_create_user_command nvim_del_augroup_by_id nvim_del_augroup_by_name nvim_del_autocmd nvim_del_current_line nvim_del_keymap nvim_del_mark nvim_del_user_command nvim_del_var nvim_echo nvim_err_write nvim_err_writeln nvim_eval nvim_eval_statusline nvim_exec nvim_exec2
    1              0.000007 syn keyword vimFuncName contained  nvim_exec_autocmds nvim_feedkeys nvim_get_all_options_info nvim_get_autocmds nvim_get_chan_info nvim_get_color_by_name nvim_get_color_map nvim_get_commands nvim_get_context nvim_get_current_buf nvim_get_current_line nvim_get_current_tabpage nvim_get_current_win nvim_get_hl nvim_get_hl_by_id nvim_get_hl_by_name nvim_get_hl_id_by_name nvim_get_hl_ns nvim_get_keymap nvim_get_mark nvim_get_mode nvim_get_namespaces nvim_get_option nvim_get_option_info nvim_get_option_info2 nvim_get_option_value nvim_get_proc nvim_get_proc_children nvim_get_runtime_file nvim_get_var nvim_get_vvar nvim_input nvim_input_mouse nvim_list_bufs nvim_list_chans nvim_list_runtime_paths nvim_list_tabpages nvim_list_uis nvim_list_wins nvim_load_context nvim_notify nvim_open_term nvim_open_win nvim_out_write nvim_parse_cmd nvim_parse_expression
    1              0.000008 syn keyword vimFuncName contained  nvim_paste nvim_put nvim_replace_termcodes nvim_select_popupmenu_item nvim_set_current_buf nvim_set_current_dir nvim_set_current_line nvim_set_current_tabpage nvim_set_current_win nvim_set_hl nvim_set_hl_ns nvim_set_hl_ns_fast nvim_set_keymap nvim_set_option nvim_set_option_value nvim_set_var nvim_set_vvar nvim_strwidth nvim_tabpage_del_var nvim_tabpage_get_number nvim_tabpage_get_var nvim_tabpage_get_win nvim_tabpage_is_valid nvim_tabpage_list_wins nvim_tabpage_set_var nvim_tabpage_set_win nvim_win_close nvim_win_del_var nvim_win_get_buf nvim_win_get_config nvim_win_get_cursor nvim_win_get_height nvim_win_get_number nvim_win_get_option nvim_win_get_position nvim_win_get_tabpage nvim_win_get_var nvim_win_get_width nvim_win_hide nvim_win_is_valid nvim_win_set_buf nvim_win_set_config nvim_win_set_cursor nvim_win_set_height
    1              0.000010 syn keyword vimFuncName contained  nvim_win_set_hl_ns nvim_win_set_option nvim_win_set_var nvim_win_set_width nvim_win_text_height or pathshorten perleval pow prevnonblank printf prompt_getprompt prompt_setcallback prompt_setinterrupt prompt_setprompt pum_getpos pumvisible py3eval pyeval pyxeval rand range readblob readdir readfile reduce reg_executing reg_recorded reg_recording reltime reltimefloat reltimestr remove rename repeat resolve reverse round rpcnotify rpcrequest rpcstart rpcstop rubyeval screenattr screenchar screenchars screencol screenpos screenrow screenstring search searchcount searchdecl searchpair searchpairpos searchpos serverlist serverstart serverstop setbufline setbufvar setcellwidths setcharpos setcharsearch setcmdline setcmdpos setcursorcharpos setenv setfperm setline setloclist setmatches setpos setqflist setreg settabvar
    1              0.000014 syn keyword vimFuncName contained  settabwinvar settagstack setwinvar sha256 shellescape shiftwidth sign_define sign_getdefined sign_getplaced sign_jump sign_place sign_placelist sign_undefine sign_unplace sign_unplacelist simplify sin sinh slice sockconnect sort soundfold spellbadword spellsuggest split sqrt srand state stdioopen stdpath str2float str2list str2nr strcharlen strcharpart strchars strdisplaywidth strftime strgetchar stridx string strlen strpart strptime strridx strtrans strutf16len strwidth submatch substitute swapfilelist swapinfo swapname synID synIDattr synIDtrans synconcealed synstack system systemlist tabpagebuflist tabpagenr tabpagewinnr tagfiles taglist tan tanh tempname termopen test_garbagecollect_now test_write_list_log timer_info timer_pause timer_start timer_stop timer_stopall tolower toupper tr trim trunc type undofile
    1              0.000006 syn keyword vimFuncName contained  undotree uniq utf16idx values virtcol virtcol2col visualmode wait wildmenumode win_execute win_findbuf win_getid win_gettype win_gotoid win_id2tabwin win_id2win win_move_separator win_move_statusline win_screenpos win_splitmove winbufnr wincol windowsversion winheight winlayout winline winnr winrestcmd winrestview winsaveview winwidth wordcount writefile xor

FUNCTION  <SNR>13_Highlight_Matching_Pair()
    Defined: /usr/local/Cellar/neovim/0.11.2/share/nvim/runtime/plugin/matchparen.vim:45
Called 458 times
Total time:   0.047093
 Self time:   0.039754

count  total (s)   self (s)
  458              0.003322   if !exists("w:matchparen_ids")
    6              0.000016     let w:matchparen_ids = []
  458              0.000457   endif
                              " Remove any previous match.
  458   0.013166   0.005828   call s:Remove_Matches()
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
  458              0.002170   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
  458              0.000231   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
  458              0.001559   let c_lnum = line('.')
  458              0.001080   let c_col = col('.')
  458              0.000562   let before = 0
                            
  458              0.001461   let text = getline(c_lnum)
  458              0.002624   let c_before = text->strpart(0, c_col - 1)->slice(-1)
  458              0.001978   let c = text->strpart(c_col - 1)->slice(0, 1)
  458              0.004580   let plist = split(&matchpairs, '.\zs[:,]')
  458              0.001507   let i = index(plist, c)
  458              0.000531   if i < 0
                                " not found, in Insert mode try character before the cursor
  448              0.001259     if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = strlen(c_before)
                                  let c = c_before
                                  let i = index(plist, c)
  448              0.000280     endif
  448              0.000443     if i < 0
                                  " not found, nothing to do
  448              0.000432       return
                                endif
   10              0.000005   endif
                            
                              " Figure out the arguments for searchpairpos().
   10              0.000011   if i % 2 == 0
   10              0.000013     let s_flags = 'nW'
   10              0.000021     let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
   10              0.000004   endif
   10              0.000013   if c == '['
   10              0.000010     let c = '\['
   10              0.000009     let c2 = '\]'
   10              0.000005   endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
   10              0.000010   if before > 0
                                let save_cursor = getcurpos()
                                call cursor(c_lnum, c_col - before)
                                defer setpos('.', save_cursor)
   10              0.000004   endif
                            
   10              0.000048   if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
   10              0.000028   elseif exists("b:ts_highlight") && &syntax != 'on'
                                let s_skip = "match(v:lua.vim.treesitter.get_captures_at_cursor(), '" .. 'string\|character\|singlequote\|escape\|symbol\|comment' .. "') != -1"
   10              0.000005   else
                                " do not attempt to match when the syntax item where the cursor is
                                " indicates there does not exist a matching parenthesis, e.g. for shells
                                " case statement: "case $var in foobar)"
                                "
                                " add the check behind a filetype check, so it only needs to be
                                " evaluated for certain filetypes
   10              0.000073     if ['sh']->index(&filetype) >= 0 && synstack(".", col("."))->indexof({_, id -> synIDattr(id, "name") =~? "shSnglCase"}) >= 0
                                  return
   10              0.000005     endif
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial, and
                                " match "symbol" for lispBarSymbol.
   10              0.000046     let s_skip = 'synstack(".", col("."))' . '->indexof({_, id -> synIDattr(id, "name") =~? ' . '"string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
   10              0.000008     try
   10              0.000207       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
   10              0.000008     endtry
   10              0.000005   endif
                            
                              " Limit the search to lines visible in the window.
   10              0.000026   let stoplinebottom = line('w$')
   10              0.000018   let stoplinetop = line('w0')
   10              0.000010   if i % 2 == 0
   10              0.000016     let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
   10              0.000004   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
   10              0.000026   if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
   10              0.000005   else
   10              0.000046     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
   10              0.000005   endif
   10              0.000006   try
   10              0.000269     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
   10              0.000007   endtry
                            
                              " If a match is found setup match highlighting.
   10              0.000027   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom
   10              0.000014     if !g:matchparen_disable_cursor_hl
   10              0.000090       call add(w:matchparen_ids, matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10))
                                else
                                  call add(w:matchparen_ids, matchaddpos('MatchParen', [[m_lnum, m_col]], 10))
   10              0.000005     endif
   10              0.000014     let w:paren_hl_on = 1
   10              0.000005   endif

FUNCTION  <SNR>1_LoadFTPlugin()
    Defined: /usr/local/Cellar/neovim/0.11.2/share/nvim/runtime/ftplugin.vim:15
Called 7 times
Total time:   0.027809
 Self time:   0.018354

count  total (s)   self (s)
    7              0.000042     if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
    7              0.000007     endif
                            
    7              0.000047     let s = expand("<amatch>")
    7              0.000013     if s != ""
    7              0.000057       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
    7              0.000004       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
   14              0.000054       for name in split(s, '\.')
                                    " Load Lua ftplugins after Vim ftplugins _per directory_
                                    " TODO(clason): use nvim__get_runtime when supports globs and modeline
                                    " XXX: "[.]" in the first pattern makes it a wildcard on Windows
    7   0.027406   0.017952         exe $'runtime! ftplugin/{name}[.]{{vim,lua}} ftplugin/{name}_*.{{vim,lua}} ftplugin/{name}/*.{{vim,lua}}'
   14              0.000034       endfor
    7              0.000006     endif

FUNCTION  <SNR>15_GetManifestPath()
    Defined: /usr/local/Cellar/neovim/0.11.2/share/nvim/runtime/plugin/rplugin.vim:7
Called 1 time
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
    1              0.000001   let manifest_base = ''
                            
    1              0.000004   if exists('$NVIM_RPLUGIN_MANIFEST')
                                return fnamemodify($NVIM_RPLUGIN_MANIFEST, ':p')
    1              0.000001   endif
                            
    1              0.000004   let dest = stdpath('data')
    1              0.000002   if !empty(dest)
    1              0.000010     if !isdirectory(dest)
                                  if getftype(dest) != "link"
                                    call mkdir(dest, 'p', 0700)
                                  endif
    1              0.000000     endif
    1              0.000002     let manifest_base = dest
    1              0.000000   endif
                            
    1              0.000002   return manifest_base.'/rplugin.vim'

FUNCTION  <SNR>13_Remove_Matches()
    Defined: /usr/local/Cellar/neovim/0.11.2/share/nvim/runtime/plugin/matchparen.vim:203
Called 479 times
Total time:   0.007655
 Self time:   0.007655

count  total (s)   self (s)
  479              0.001815   if exists('w:paren_hl_on') && w:paren_hl_on
   20              0.000058     while !empty(w:matchparen_ids)
   10              0.000060       silent! call remove(w:matchparen_ids, 0)->matchdelete()
   20              0.000063     endwhile
   10              0.000022     let w:paren_hl_on = 0
  479              0.000278   endif

FUNCTION  <SNR>15_GetOldManifestPaths()
    Defined: /usr/local/Cellar/neovim/0.11.2/share/nvim/runtime/plugin/rplugin.vim:28
Called 1 time
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    1              0.000006   let prefix = exists('$MYVIMRC') ? $MYVIMRC : matchstr(get(split(execute('scriptnames'), '\n'), 0, ''), '\f\+$')
    1              0.000014   let origpath = fnamemodify(expand(prefix, 1), ':h').'/.'.fnamemodify(prefix, ':t').'-rplugin~'
    1              0.000003   if !has('win32')
    1              0.000001     return [origpath]
                              endif
                              " Windows used to use $APPLOCALDATA/nvim but stdpath('data') is
                              " $XDG_DATA_DIR/nvim-data
                              let pseudostdpath = exists('$LOCALAPPDATA') ? '$LOCALAPPDATA' : '~/AppData/Local'
                              let pseudostdpath = fnamemodify(expand(pseudostdpath), ':p')
                              return [substitute(pseudostdpath, '[/\\]\=$', '/', '') . 'nvim/rplugin.vim', origpath]

FUNCTION  <SNR>25_set_pbcopy()
    Defined: /usr/local/Cellar/neovim/0.11.2/share/nvim/runtime/autoload/provider/clipboard.vim:70
Called 1 time
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000003   let s:copy['+'] = ['pbcopy']
    1              0.000001   let s:paste['+'] = ['pbpaste']
    1              0.000002   let s:copy['*'] = s:copy['+']
    1              0.000001   let s:paste['*'] = s:paste['+']
    1              0.000001   let s:cache_enabled = 0
    1              0.000001   return 'pbcopy'

FUNCTION  <SNR>15_LoadRemotePlugins()
    Defined: /usr/local/Cellar/neovim/0.11.2/share/nvim/runtime/plugin/rplugin.vim:58
Called 1 time
Total time:   0.000118
 Self time:   0.000017

count  total (s)   self (s)
    1   0.000109   0.000008   let g:loaded_remote_plugins = s:GetManifest()
    1              0.000005   if filereadable(g:loaded_remote_plugins)
                                execute 'source' fnameescape(g:loaded_remote_plugins)
    1              0.000000   endif

FUNCTION  provider#clipboard#Executable()
    Defined: /usr/local/Cellar/neovim/0.11.2/share/nvim/runtime/autoload/provider/clipboard.vim:184
Called 1 time
Total time:   0.000073
 Self time:   0.000063

count  total (s)   self (s)
                              " Setting g:clipboard to v:false explicitly opts-in to using the "builtin" clipboard providers below
    1              0.000003   if exists('g:clipboard') && g:clipboard isnot# v:false
                                if v:t_string ==# type(g:clipboard)
                                  " Handle string form of g:clipboard for all builtin providers
                                  if 'osc52' == g:clipboard
                                    " User opted-in to OSC 52 by manually setting g:clipboard.
                                    return s:set_osc52()
                                  elseif 'pbcopy' == g:clipboard
                                    return s:set_pbcopy()
                                  elseif 'wl-copy' == g:clipboard
                                    return s:set_wayland()
                                  elseif 'wayclip' == g:clipboard
                                    return s:set_wayclip()
                                  elseif 'xsel' == g:clipboard
                                    return s:set_xsel()
                                  elseif 'xclip' == g:clipboard
                                    return s:set_xclip()
                                  elseif 'lemonade' == g:clipboard
                                    return s:set_lemonade()
                                  elseif 'doitclient' == g:clipboard
                                    return s:set_doitclient()
                                  elseif 'win32yank' == g:clipboard
                                    return s:set_win32yank()
                                  elseif 'putclip' == g:clipboard
                                    return s:set_putclip()
                                  elseif 'clip' == g:clipboard
                                    return s:set_clip()
                                  elseif 'termux' == g:clipboard
                                    return s:set_termux()
                                  elseif 'tmux' == g:clipboard
                                    return s:set_tmux()
                                  endif
                                endif
                            
                                if type({}) isnot# type(g:clipboard) || type({}) isnot# type(get(g:clipboard, 'copy', v:null)) || type({}) isnot# type(get(g:clipboard, 'paste', v:null))
                                  let s:err = 'clipboard: invalid g:clipboard'
                                  return ''
                                endif
                            
                                let s:copy = {}
                                let s:copy['+'] = s:split_cmd(get(g:clipboard.copy, '+', v:null))
                                let s:copy['*'] = s:split_cmd(get(g:clipboard.copy, '*', v:null))
                            
                                let s:paste = {}
                                let s:paste['+'] = s:split_cmd(get(g:clipboard.paste, '+', v:null))
                                let s:paste['*'] = s:split_cmd(get(g:clipboard.paste, '*', v:null))
                            
                                let s:cache_enabled = get(g:clipboard, 'cache_enabled', 0)
                                return get(g:clipboard, 'name', 'g:clipboard')
    1              0.000002   elseif has('mac')
    1   0.000018   0.000007     return s:set_pbcopy()
                              elseif !empty($WAYLAND_DISPLAY) && executable('wl-copy') && executable('wl-paste')
                                return s:set_wayland()
                              elseif !empty($WAYLAND_DISPLAY) && executable('waycopy') && executable('waypaste')
                                return s:set_wayclip()
                              elseif !empty($DISPLAY) && executable('xsel') && s:cmd_ok('xsel -o -b')
                                return s:set_xsel()
                              elseif !empty($DISPLAY) && executable('xclip')
                                return s:set_xclip()
                              elseif executable('lemonade')
                                return s:set_lemonade()
                              elseif executable('doitclient')
                                return s:set_doitclient()
                              elseif executable('win32yank.exe')
                                return s:set_win32yank()
                              elseif executable('putclip') && executable('getclip')
                                return s:set_putclip()
                              elseif executable('clip') && executable('powershell')
                                return s:set_clip()
                              elseif executable('termux-clipboard-set')
                                return s:set_termux()
                              elseif executable('tmux') && (!empty($TMUX) || 0 == jobwait([jobstart(['tmux', 'list-buffers'])], 2000)[0])
                                return s:set_tmux()
                              elseif get(get(g:, 'termfeatures', {}), 'osc52') && &clipboard ==# ''
                                " Don't use OSC 52 when 'clipboard' is set. It can be slow and cause a lot
                                " of user prompts. Users can opt-in to it by setting g:clipboard manually.
                                return s:set_osc52()
                              endif
                            
                              let s:err = 'clipboard: No clipboard tool. :help clipboard'
                              return ''

FUNCTION  <SNR>2_LoadIndent()
    Defined: /usr/local/Cellar/neovim/0.11.2/share/nvim/runtime/indent.vim:14
Called 7 times
Total time:   0.005250
 Self time:   0.004990

count  total (s)   self (s)
    7              0.000032     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
    7              0.000004     endif
    7              0.000032     let s = expand("<amatch>")
    7              0.000012     if s != ""
    7              0.000013       if exists("b:did_indent")
                            	unlet b:did_indent
    7              0.000004       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
   14              0.000047       for name in split(s, '\.')
                                    " XXX: "[.]" in the pattern makes it a wildcard on Windows
    7   0.004995   0.004734         exe $'runtime! indent/{name}[.]{{vim,lua}}'
   14              0.000022       endfor
    7              0.000005     endif

FUNCTION  <SNR>15_GetManifest()
    Defined: /usr/local/Cellar/neovim/0.11.2/share/nvim/runtime/plugin/rplugin.vim:44
Called 1 time
Total time:   0.000101
 Self time:   0.000039

count  total (s)   self (s)
    1   0.000042   0.000006   let manifest = s:GetManifestPath()
    1              0.000007   if !filereadable(manifest)
                                " Check if an old manifest file exists and move it to the new location.
    2   0.000034   0.000009     for old_manifest in s:GetOldManifestPaths()
    1              0.000006       if filereadable(old_manifest)
                                    call rename(old_manifest, manifest)
                                    break
    1              0.000000       endif
    2              0.000002     endfor
    1              0.000000   endif
    1              0.000001   return manifest

FUNCTION  <SNR>9_SynSet()
    Defined: /usr/local/Cellar/neovim/0.11.2/share/nvim/runtime/syntax/synload.vim:27
Called 8 times
Total time:   0.019147
 Self time:   0.012261

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
    8              0.000027   syn clear
    8              0.000024   if exists("b:current_syntax")
                                unlet b:current_syntax
    8              0.000005   endif
                            
    8              0.000032   0verbose let s = expand("<amatch>")
    8              0.000013   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
    8              0.000009   elseif s == "OFF"
                                let s = ""
    8              0.000003   endif
                            
    8              0.000007   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.  Skip empty entries.
   12              0.000045     for name in split(s, '\.')
    6              0.000010       if !empty(name)
                                    " XXX: "[.]" in the first pattern makes it a wildcard on Windows
    6   0.018761   0.011875         exe $'runtime! syntax/{name}[.]{{vim,lua}} syntax/{name}/*.{{vim,lua}}'
    6              0.000012       endif
   12              0.000034     endfor
    8              0.000005   endif

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
  458   0.047093   0.039754  <SNR>13_Highlight_Matching_Pair()
    7   0.027809   0.018354  <SNR>1_LoadFTPlugin()
    8   0.019147   0.012261  <SNR>9_SynSet()
  479   0.007655             <SNR>13_Remove_Matches()
    7   0.005250   0.004990  <SNR>2_LoadIndent()
    1   0.000118   0.000017  <SNR>15_LoadRemotePlugins()
    1   0.000101   0.000039  <SNR>15_GetManifest()
    1   0.000073   0.000063  provider#clipboard#Executable()
    1   0.000036             <SNR>15_GetManifestPath()
    1   0.000025             <SNR>15_GetOldManifestPaths()
    1   0.000011             <SNR>25_set_pbcopy()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
  458   0.047093   0.039754  <SNR>13_Highlight_Matching_Pair()
    7   0.027809   0.018354  <SNR>1_LoadFTPlugin()
    8   0.019147   0.012261  <SNR>9_SynSet()
  479              0.007655  <SNR>13_Remove_Matches()
    7   0.005250   0.004990  <SNR>2_LoadIndent()
    1   0.000073   0.000063  provider#clipboard#Executable()
    1   0.000101   0.000039  <SNR>15_GetManifest()
    1              0.000036  <SNR>15_GetManifestPath()
    1              0.000025  <SNR>15_GetOldManifestPaths()
    1   0.000118   0.000017  <SNR>15_LoadRemotePlugins()
    1              0.000011  <SNR>25_set_pbcopy()

